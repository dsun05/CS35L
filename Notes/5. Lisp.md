# Lecture Notes: Scripting Languages — Syntax, Semantics, Pragmatics, and Emacs Lisp

---

## Table of Contents

1. Introduction to Scripting Languages
   - Definitions and Context
   - Three Critical Aspects: Syntax, Semantics, Pragmatics

2. Overview of Example Scripting Languages
   - Shell
   - Emacs Lisp
   - Python
   - JavaScript
   - Java

3. Key Themes of Scripting Languages
   - Ease of Use
   - Reliability
   - Scalability
   - Performance
   - System Integration

4. Emacs Lisp: An Introduction
   - Historical Context and Purpose
   - Emacs Lisp as an Extension Language
   - Emacs Internals and Evaluation

5. Syntax and Semantics in Lisp
   - Lisp Syntax Characteristics
   - Structuring Code as Lists
   - Symbols and Special Forms
   - Expressions vs. Data

6. Emacs Lisp Data Structures
   - Lists and Pairs
   - Numbers and Strings
   - Symbols, Buffers, and Vectors
   - Markers, Hash Tables, Functions

7. Evaluation and Execution
   - Quoting and Eval
   - Interactive Evaluation in the Scratch Buffer
   - Debugging Basics

8. Functional Programming Concepts
   - Lambda Expressions
   - Higher-order Functions
   - Local Bindings (LET)

9. Emacs Lisp Utilities and Commands
   - Defining Functions
   - Emacs Commands and Interactivity
   - Accessing Source Documentation

10. Summary

---

## 1. Introduction to Scripting Languages

### Definitions and Context

- Scripting languages are often thought of as languages used to automate processes, configure, or extend large systems.
- Traditional classifications of programming languages include:
  - **Syntax** — concerns rules of form and structure (e.g., semicolons, brackets).
  - **Semantics** — meaning of correctly formed syntax (i.e., what a program actually does).
  - **Pragmatics** — practical aspects: performance, security, ease of configuration, interoperability, etc.

Scripting languages emphasize pragmatics more than traditional programming languages.

---

## 2. Overview of Example Scripting Languages

### Shell
- One of the oldest scripting languages, designed to automate and configure Unix programs.
- Still widely used to run and link other programs.

### Emacs Lisp
- Originally not a scripting language; designed for AI in the 1960s.
- Adopted for scripting Emacs due to its support for program generation and self-modifying code.
- Known as an extension language, designed specifically for Emacs, not general-purpose use.

### Python
- Now one of the world’s most popular languages (estimated 25% of developer mindshare).
- Designed as a general-purpose scripting language.
- Specializes in integrating and gluing together code modules in the same memory space (vs. separate processes as in shell scripting).

### JavaScript
- Originally designed to script and extend web browsers.
- Became a language with general-purpose capabilities.
- Uses techniques like bytecode for performance.

### Java
- Not a scripting language but influenced scripting environments:
  - Introduced bytecode + JIT compilation.
- Emphasizes reliability and strict compiled checking of code.

---

## 3. Key Themes of Scripting Languages

### Ease of Use

- Scripting languages prioritize accessibility.
- Easy to learn, fast to write short scripts.
- Example: Python makes it easy for beginners to write "Hello World!" without extensive setup.

### Reliability

- Scripting languages often avoid worst-case crashes common in languages like C++ (e.g., null pointer exceptions).
- Instead, they raise exceptions or print errors.
- However, permissiveness may allow incorrect programs to execute without failure, decreasing logical reliability.

| Language   | Crashes on Subscript Error? | Throws Exception? |
|------------|-----------------------------|--------------------|
| C++        | Yes                         | No                 |
| Python     | No                          | Yes                |
| Shell      | No                          | Typically alerts   |

### Scalability

- Scripting languages struggle with very large codebases.
- Designed for small to medium programs.
- Integration often includes low-level languages (like C++) for performance and reliability in large systems.

### Performance

- Generally slower than compiled languages due to runtime checks and interpreted execution.
- Tradeoff accepted in favor of other benefits.
- JIT compilers and bytecode interpreters are used to mitigate this gap (e.g., JavaScript, Emacs now includes bytecode compilation).

---

## 4. Emacs Lisp: An Introduction

### Historical Context and Purpose

- Lisp, created for AI in the 1960s, grew to support self-modifying and program-generating code.
- Emacs Lisp is a variant tailored to the GNU Emacs text editor.
- Emacs Lisp is an extension language: enhances and customizes Emacs behavior.

### Emacs Lisp as an Extension Language

- Supports deep integration with Emacs internals: buffers, windows, syntax highlighting, etc.
- Provides primitives focused on editing rather than general computing (compare to SAP’s payroll-specific extension language).

---

## 5. Syntax and Semantics in Lisp

### Lisp Syntax Characteristics

- Simple, uniform syntax using parenthesized prefix notation.
- All function calls look like:
  (function arg1 arg2 ...)
- No operator precedence, no infix notation.
- Symbols and data use homogenous parenthetical syntax.

### Structuring Code as Lists

- Code and data blurred: both written as lists.
- Example:
  - Data: '(a b c)
  - Code: (+ 34 25)

### Symbols and Special Forms

- Symbols: Unique named atomic values.
  - Examples: nil, t, my-var
- Special Forms:
  - Control structures and definition constructs that are not function calls.
  - Examples: defun, let, lambda, quote

### Expressions vs. Data

- Everything is an expression: evaluates to a value.
- Use quote (') to distinguish data from code.

| Form              | Meaning                                |
|-------------------|----------------------------------------|
| 'abc              | Symbol `abc` as data                  |
| abc               | Evaluate variable `abc`               |
| '(a b c)          | List of three symbols a, b, c          |
| (quote (a b c))   | Same as above                          |

---

## 6. Emacs Lisp Data Structures

### Numbers

- Integers: Arbitrary precision (bignums)
- Floats: IEEE 64-bit doubles
- Example: (+ 100000000000000000 1)

### Strings

- Written with double quotes
- Supports newlines: "Hello\nWorld"

### Symbols

- Named values that point to variables or functions
- Used for identifiers, constants, or stand-alone atoms
- Special symbols:
  - nil: false, end of list
  - t: true

### Lists and Pairs (Conses)

- Basic data structures in Lisp: singly linked list
- Constructed using (cons a b)

Example:

```lisp
(cons 1 (cons 2 (cons 3 nil)))  ;; => (1 2 3)
```

| Function | Description               |
|----------|---------------------------|
| car      | Returns first item        |
| cdr      | Returns rest of list      |

### Vectors

- Fixed-size, indexable arrays
- Created via: (make-vector 5 'x)

### Hash Tables, Markers, Buffers

- Hash Tables: Key-value associative maps.
- Markers: Pointers to specific positions in buffers that adapt as buffer changes.
- Buffers: Editable text containers (contents of a file, scratch, etc.)

### Functions

- First-class objects
- Created via lambda

Example:
```lisp
(lambda (x) (* x x)) ;; Anonymous function
```

---

## 7. Evaluation and Execution

### Quoting and Eval

- `'expression` prevents evaluation.
- `(eval expression)` forces evaluation even of quoted data.

### Interactive Evaluation (Scratch Buffer)

- Evaluated using:
  - `C-J`: Evaluate previous expression and show result below.
  - `C-x C-e`: Evaluate expression at point and show in mini-buffer.

### Debugging Basics

- Emacs will drop into the debugger upon errors.
- Key command to exit debugger: `C-]` (Control + closing square bracket)

Common error: Trying to evaluate an undefined symbol:
```lisp
ABC  ;; Error: void variable 'ABC'
```

Backtraces provided for debugging call stack.

---

## 8. Functional Programming Concepts

### Lambda Expressions

- Emacs supports anonymous functions with `lambda`.

Example:
```lisp
(lambda (x y) (+ x (* y y)))
```

- Can pass lambdas as arguments or assign to variables.

### Local Bindings (LET)

- Creates local variables bound to evaluated values.

Example:
```lisp
(let ((x 5) (y 7))
  (+ x y))
```

- Temporarily masks global variables if names overlap.

---

## 9. Emacs Lisp Utilities and Commands

### Defining Functions (DEFUN)

- Named functions defined with `defun`.

Example:
```lisp
(defun square (x)
  "Returns the square of x."
  (* x x))
```

### Emacs Commands

- Functions callable via UI must be declared interactive:
```lisp
(defun my-command ()
  (interactive)
  (message "Hello"))
```

- Can query keystrokes or input with `interactive` argument.

### Accessing Documentation

- `C-h k`: Describe key bindings.
- `C-h f`: Describe function.
- `C-h m`: Describe current mode.
- Mouse over source file link (e.g., window.el) to open implementation in Emacs

---

## 10. Summary

This lecture introduced the concept of scripting languages with a focus on their unique emphasis on pragmatics — real-world concerns of integration, performance trade-offs, ease of use, reliability, and extensibility. It differentiated scripting languages from general-purpose and low-level languages, exemplified by Emacs Lisp and Python. The lecture gave an in-depth presentation of Emacs Lisp as an extension language, explaining its evaluation model, key data types (including symbols, lists, strings, functions), and its support for self-modifying code, which allows it to script and modify Emacs in powerful ways. The class also demonstrated fundamental Lisp programming techniques including quoting, evaluation, function definition, lambda expressions, local variable bindings, and debugging tools within Emacs.