# Lecture Notes: Client-Server Computing, Node.js & Event-Driven Programming

---

## Table of Contents

1. Introduction
2. Client-Server Computing
   - Fundamentals
   - Server Responsibilities
   - Client Responsibilities
   - Multi-client Environment
   - Failure Scenarios
3. Event-Driven Programming
   - Overview
   - Asynchronous Events
   - The Event Loop
   - Writing Efficient Handlers
   - Problems in Event-driven Code
   - Comparisons with Multi-threading
4. Node.js
   - Overview and Role
   - The Node Runtime
   - JavaScript in Node
   - Hello World Node Web Server
   - Code Explanation (Line-by-Line)
   - Demo and Execution
5. System Architectures
   - Client-Server Model
   - Peer-to-Peer Architecture
   - Primary-Secondary (Master-Worker) Approach
6. Common Challenges in Distributed Applications
   - Performance Problems
     - Throughput
     - Latency
   - Correctness Problems
     - Serialization
     - Caching and Stale Data
7. Historical Networking Context
   - Circuit Switching
   - Packet Switching
   - Problems Circuit Switching Tries to Solve
8. Summary

---

## 1. Introduction

The lecture covers the fundamentals and evolution of network-based computing through the lens of client-server models, asynchronous event-driven programming, and Node.js. It explores how modern web applications are structured and what design decisions underpin scalability and correctness.

---

## 2. Client-Server Computing

### Fundamentals

- Client-server computing involves two programs running simultaneously and communicating over a network.
- Old model: single program running on one machine (classic computing).
- Client-server model: dates back to the 1970s.

### Server Responsibilities

- Maintains the authoritative "state of the system".
- Handles all significant data (e.g., enrollment records at a university).
- Enforces rules of the system (e.g., capacity limits).

### Client Responsibilities

- Sends requests to the server.
- Has little or no authoritative state information.
- Acts primarily as an interface or interaction mechanism.
  
### Multi-client Environment

- Multiple clients can simultaneously interact with the same server.
- Clients do **not** communicate directly.
- Communication pattern: Client → Server → Other Clients (indirectly).

#### Diagram:

```
Client1
   \
    \
    [Network] — [Server]
    /
   /
Client2
```

If Client1 affects Client2’s view, the update must go through the server.

### Failure Scenarios

- Two users try to register for the same course simultaneously:
  - Server determines the winner.
  - Poorly designed server may:
    - Error both.
    - Accept both (if concurrency control fails).
- Engineers should ask: What can go wrong?

---

## 3. Event-Driven Programming (Asynchronous Approach)

### Overview

A different programming paradigm useful in environments where events happen spontaneously (like web servers).

### Asynchronous Events

- Events arrive from the external environment.
- May include:
  - Web requests.
  - Results from external databases.
  - File read completions.

### The Event Loop

Pseudocode:

```javascript
while (true) {
    event = getNextEvent();
    handle(event);
}
```

Key Requirements:
- `handle(event)` must run **quickly**—should not wait, block, or sleep.
- Blocking operations (e.g., `read()`) are **not allowed**.
- Instead, work is sliced into small pieces.

### Writing Efficient Handlers

Problem: Some operations (like ML training) are time-intensive.

Solution:
- Break long tasks into small chunks.
- Use scheduled events to handle subsequent parts.

Example Transformation:

From:
```javascript
for (let i = 0; i < n; ++i) {
   doHeavyTask(i);
}
```

To:
```javascript
function doOne(i) {
   doHeavyTask(i);
   scheduleNext(() => doOne(i+1));
}
```

### Problems in Event-Driven Code

Potential Issues:
- Higher overhead per action.
- Error handling becomes complex.
- Loss of execution order.
- Difficult debugging and reasoning.

### Comparisons with Multi-threading

| Feature              | Event-Driven             | Multi-threading           |
|----------------------|--------------------------|---------------------------|
| Concurrency Model     | Single-threaded, non-blocking | Multiple threads with context switching |
| Shared State         | No (single-thread = no races) | Yes (needs locks to avoid races) |
| Performance Potential| Limited CPU parallelism | High parallel performance |
| Safety               | No race conditions       | Race conditions possible |
| Complexity           | Moderate                 | High due to synchronization |

#### Key Benefit of Event-Driven

- No need for **locks**.
- Less prone to **race conditions**.

### Limitation

- No true parallelism (one core at a time).
- If an event handler crashes or takes too long, the whole system halts.

---

## 4. Node.js

### Overview and Role

- Node.js is a JavaScript runtime optimized for asynchronous, event-driven I/O.
- Commonly used to build fast, scalable web servers.

### The Node Runtime

- Operates using the event loop.
- Non-blocking I/O.
- Built on the V8 JavaScript engine.

### JavaScript in Node

- Originally a browser language.
- Node allows JavaScript to run on servers (no GUI required).
- Async nature fits web servers well.

---

### Hello World Node Web Server

#### Example Code:

```javascript
const http = require("http");
const ip = "127.0.0.1";
const port = 3000;

const server = http.createServer((request, response) => {
    response.statusCode = 200;
    response.setHeader("Content-Type", "text/plain");
    response.end("Hello World");
});

server.listen(port, ip, () => {
    console.log(`Server running at http://${ip}:${port}/`);
});
```

#### Explanation Table:

| Line | Purpose |
|------|---------|
| 1 | Load the HTTP module. |
| 2 | Set the local IP address. |
| 3 | Define the port number. |
| 5–9 | Set up request handler (callback). |
| 10–12 | Start the server and define startup callback. |

Special JS Feature:
```javascript
console.log(`Server running at http://${ip}:${port}/`);
```
- Example of a **template literal** (uses backticks ` `` `).
- Allows expression embedding: `${variable}`.

### Demo

- Run: `node app.js`
- Access: `http://localhost:3000`
- Response: “Hello World”

---

## 5. System Architectures

### 1. Client-Server Model

- Explained earlier.
- Centralized control and data.
- Problems:
  - Scalability.
  - Single point of failure.

### 2. Peer-to-Peer (P2P)

- Each peer has its own data and control.
- No centralized server.
- Pros:
  - Scalable.
  - Redundancy.
- Cons:
  - Complex consistency.
  - Data propagation challenges.

### 3. Primary-Secondary (Master-Worker)

- One **primary/master** controls the computation.
- Many **secondary/worker nodes** perform tasks.
- Used in:
  - ML Training.
  - Distributed DBs.

| Model | Use Case | Pros | Cons |
|-------|----------|------|------|
| Client-Server | Small to medium apps | Simple | Scalability |
| P2P | Decentralized systems | Scalable | Complexity |
| Master-Worker | Parallel computation | Control | Bottleneck at primary |

---

## 6. Common Challenges in Distributed Applications

### Performance Problems

Divided into two kinds:

#### a. Throughput

- Rate of processing requests.
- Common optimizing strategies:
  - Parallel execution.
  - Out-of-order execution.

#### b. Latency

- Time between request and response.
- Common fixes:
  - Client-side caching.
  - Server-side caching.

#### Example Table:

| Type | Optimization | Risk |
|------|--------------|------|
| Throughput | Execute in parallel or reorder | Data inconsistency |
| Latency | Caching | Data staleness |

### Correctness Problems

#### 1. Serialization

Ensures consistent results in unordered execution.

- A concurrent system is correct if its end result is equivalent to some **serial** order of execution.

Example:

```
Requests A, B, C → Executed in order C, A, B
But result same as A, B, C → OK (Serializable)
```

#### 2. Caching Issues

- Client caches may become stale.
- Validation Techniques:
   - **Validation Tokens**: each response tagged with a version/hash.
   - **TTL (Time to Live)**: cache expires after a set time.

Alternate Strategy:
- Design software that tolerates stale data.

---

## 7. Historical Networking Context

### Circuit Switching

- Used in traditional (1960s–1980s) telephone systems.

Mechanism:
- A **dedicated communication path** is established for each call.
- If a route gets destroyed (e.g. Chicago), the connection fails.

Problems:
- Inefficient bandwidth use.
- Not resilient to failure.
- Poor scalability.

### Packet Switching

- The backbone of the modern Internet.
  
Mechanism:
- Data is split into **packets** (~1000 bytes).
- Each packet routes independently via routers.
  
Advantages:
- Resilient: if one node fails, packets find alternative routes.
- Efficient: no need to hold a full path open.

Key Contributor:
- Paul Baran (RAND Corporation): Designed robust communication schemes anticipating network failure (e.g., due to nuclear war).

---

## 8. Summary

This lecture introduced students to the evolving paradigm of client-server computing and the rise of event-driven programming with asynchronous handling, focusing on practical implementation using Node.js. It contrasted classic single-program computing with client-server models, emphasized the critical distinction between synchronous and asynchronous operations, and underscored the design advantages and challenges associated with each system architecture. The discussion also explored error handling in asynchronous environments, highlighted architecture alternatives like peer-to-peer or master-worker systems, and traced the historical transformation from circuit-switched to packet-switched networks, explaining how the modern networking stack emerged out of both engineering necessities and wartime resiliency goals.