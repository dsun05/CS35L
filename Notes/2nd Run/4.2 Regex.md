# Comprehensive Lecture Notes

## Table of Contents
1. Pattern Matching in the Shell
   - Globbing
   - Special Characters and Syntax
   - Globbing Exceptions
   - Globbing Examples
   - Globbing in Directory Hierarchies
   - Globbing Exclusion
2. Shell I/O Redirection
   - Standard File Descriptors
   - Redirection Syntax
   - Here Documents
   - Advanced Redirection
3. Shell Commands and Scripting
   - Exit and Return
   - Shell Functions vs Shell Scripts
   - Aliases
4. Regular Expressions
   - Design Philosophy and Purpose
   - Extended Regular Expressions (ERE)
     - Core Syntax and Operators
     - Matching Behavior and Precedence
     - Bracket Expressions in ERE
     - Special Characters and Escaping
   - Basic Regular Expressions (BRE)
     - Syntax Differences from ERE
     - Backreferences
5. Emacs
   - Efficiency Philosophy
   - Cursor and Region Operations
   - Buffer and Window Management
   - The Kill Ring and Yank Operations
   - Emacs Modes
   - Accessing Help
   - Mini-buffer Operations
   - Integration with Shell

---

## 1. Pattern Matching in the Shell

### Globbing

- **Definition**: Globbing is a simplified form of pattern matching used primarily for file name expansion in the shell.
- Commonly used with commands like `echo`, `ls`, and `rm`.
- It can also be used within control structures such as `case`.

### Special Characters and Syntax

| Symbol | Meaning |
|--------|---------|
| `*`    | Matches any sequence of zero or more characters. |
| `?`    | Matches exactly one character. |
| `[...]`| Matches any single character enclosed in the brackets. |
| `[a-z]`| Matches characters in the specified range (`a` to `z`). |
| `[!...]`| Matches a single character not in the specified set (negation). |

- Use `-` in brackets to denote ranges. To include the `-` itself, escape ambiguity by placing it at the end.
- Directory separator `/` is not matched by `*` or `?`.
- Filenames that start with `.` (dot files) are not matched by `*` or `?` unless the pattern explicitly starts with `.`, e.g., `.??*` matches hidden files of at least three characters.

### Globbing Exceptions

1. Characters like `/` are not matched by wildcards.
   - This prevents expensive recursive directory traversals.
2. Leading `.` (dot) files are not matched by patterns unless the pattern explicitly includes a dot at the start.

### Globbing Examples

| Pattern | Description | Match |
|---------|-------------|-------|
| `*`     | All files except hidden ones. | `foo`, `bar.txt`, not `.hidden` |
| `?.txt`| One character followed by `.txt` | `a.txt`, not `ab.txt` |
| `[abc]*` | Files starting with `a`, `b`, or `c`. | `apple`, `cat`, not `dog` |
| `[!abc]*` | Files not starting with `a`, `b`, or `c`. | `dog`, not `apple` |
| `*.sh` | Files ending with `.sh`. | `script.sh` |
| `.??*` | Hidden files with name length ≥ 3. | `.xrc`, not `.x` |

### Globbing in Directory Hierarchies

- Directory matching needs explicit structure:
  - `*/foo*` only finds `foo*` in direct subdirectories.
  - `*/*/foo*` required for two-level search.

### Globbing Exclusion

You can use bracket negation to exclude specific starting characters.

Example:
```sh
echo [!abc.]*
```
Matches files that do not begin with `a`, `b`, `c`, or `.`.

---

## 2. Shell I/O Redirection

### Standard File Descriptors

| Descriptor | Description      |
|------------|------------------|
| 0          | Standard Input   |
| 1          | Standard Output  |
| 2          | Standard Error   |

### Redirection Syntax

| Syntax          | Meaning |
|-----------------|---------|
| `>`             | Redirect `stdout` to a file (overwrite). |
| `>>`            | Redirect `stdout` and append to file. |
| `2>&1`          | Redirect `stderr` to where `stdout` points. |
| `3< file`       | Open file on descriptor 3 for reading. |
| `3> file`       | Open file on descriptor 3 for writing. |
| `3<> file`      | Open for reading and writing on descriptor 3. |

### Here Documents

- Used to pass multi-line input to commands.

Example:
```sh
cat <<EOF
line one
line two
EOF
```
This feeds the lines into `cat` as `stdin`.

- Supports variable substitution unless quoted:
```sh
cat << 'EOF' # prevents variable expansion
cat << EOF   # expands variables
```

### Advanced Redirection Examples

```sh
command 3>&1 1>tempfile
```
- Redirects file descriptor 3 to the current `stdout`, and `stdout` to a file.

---

## 3. Shell Commands and Scripting

### Exit and Return

| Command   | Effect |
|-----------|--------|
| `exit`    | Terminates shell (or script). |
| `exit 1`  | Exits with status code 1. |
| `return`  | Exits from a shell function only. |

- `exit` exits the shell completely, but `return` is confined to functions.
- You can check the exit status using `$?`.

### Shell Functions vs Shell Scripts

Two approaches:

#### Shell Function
```sh
g() {
  grep "$@"
}
```
- Defined in `.profile` or directly in the shell.
- Lightweight and executed in current shell.

#### Shell Script
```sh
#!/bin/sh
grep "$@"
```
- Saved in file in a directory listed in `$PATH`.
- Executed in a new process.
- More portable and global.

| Feature | Function | Script |
|---------|----------|--------|
| Scope   | Local to shell | Global in environment |
| Overhead | Low          | High (new process) |
| Portability | Low     | High |
| Speed    | Fast for small tasks | Better for large tasks |

### Aliases

- Used for simple command substitution.
```sh
alias g='grep'
```
- Not suitable for complex logic; use functions instead.

---

## 4. Regular Expressions

### Design Philosophy

- A little language tailored to string pattern matching.
- Variants exist because different tool authors chose different syntaxes.

### Extended Regular Expressions (ERE)

Use `grep -E` or `egrep` to invoke EREs.

#### Core Syntax and Operators

| Pattern       | Description |
|---------------|-------------|
| `.`           | Any single character (except newline). |
| `P*`          | Zero or more of pattern `P`. |
| `P+`          | One or more of `P` (like `P P*`). |
| `P?`          | Zero or one of `P`. |
| `P{m,n}`      | Between `m` and `n` occurrences of `P`. |
| `P|Q`         | `P` or `Q` (alternation). |
| `(P)`         | Grouping of pattern `P`. |
| `^`           | Anchors match to the start of the line. |
| `$`           | Anchors match to the end of the line. |

#### Example: Palindrome Matching
```bash
grep -E '^(.)(.)(.).\3\2\1$'
```
Matches six-character palindromes.

#### Bracket Expressions

| Syntax    | Description |
|-----------|-------------|
| `[abc]`   | Matches `a`, `b` or `c`. |
| `[a-z]`   | Matches any lowercase letter. |
| `[^a-z]`  | Negation: Match any character not in the set. |
| `[[:digit:]]`| POSIX character class, matches digits. |
| `[[:alpha:]]`| Letters only. |

Special handling required for:
- `-` (range): Put at the start or end to avoid ambiguity.
- `]`: Put as first character to match literal `]`.
- `^`: Only special if first character (negation).

#### Escape Sequences

Backslashes are used to escape special characters.
- Must escape metacharacters: `\* \. \( \)` etc.
- Caution: Shell may interpret before `grep` does.

To match `\`, you'll often need `\\\\`.

### Basic Regular Expressions (BRE)

Used with `grep` without `-E`.

Differences from ERE:
- Metacharacters like `+`, `?`, `{}` are NOT special.
- Use `\(...\)` for grouping.
- Use `\{n,m\}` for repetition.
- `|` is not supported directly.

#### Backreferences (BRE only)

| Syntax | Description |
|--------|-------------|
| `\1`   | Refers to first captured group. |
| `\2`   | Refers to second captured group. |

Example:
```sh
grep '^\(.\)\(.\)\2\1$'
```
Matches 4-character palindromes.

**Performance Note**: Backreferences are slow and non-regular — avoid when possible.

### Common Pitfalls

- Regular expressions with just a backslash (`\`) are invalid.
- Quoted expressions inside the shell need escaping.

---

## 5. Emacs

### Philosophy

- Keyboard-driven efficiency.
- Emphasis on not taking hands off keyboard.
- Modular via modes and the mini-buffer.

### Cursor and Region Operations

| Command         | Description |
|-----------------|-------------|
| `C-@` or `C-Space` | Set mark for a region (select text). |
| `M-w`           | Copy region (Mark to Point). |
| `C-w`           | Cut region (Kill). |
| `C-y`           | Paste (Yank). |
| `M-y`           | Cycle through kill ring. |
| `C-x C-x`       | Exchange point and mark. |

- Kill ring supports multiple yanks using `M-y`.

### Buffer and Window Management

| Command       | Description |
|---------------|-------------|
| `C-x b`       | Switch buffer. |
| `C-x C-b`     | List all buffers. |
| `C-x o`       | Switch windows. |
| `C-x 2`       | Split window horizontally. |
| `C-x 3`       | Split window vertically. |
| `C-x 0`       | Close current window. |
| `C-x 1`       | Maximize current window. |

### The Kill Ring

- Stores multiple text entries from kills.
- Cyclic navigation with `M-y` after `C-y`.

### Emacs Modes

- Major modes (e.g., Fundamental, Dired) tailor behavior to the file type or buffer.
- Minor modes add auxiliary behavior (e.g., Line numbers).

Use `C-h m` to describe current modes and key bindings.

### Accessing Help

| Command    | Description |
|------------|-------------|
| `C-h k`    | Describe key binding. |
| `C-h m`    | Describe current mode. |
| `C-h i`    | Info documentation browser. |

Meta key (`M-`) is typically `Alt` or `Esc` key.

### Mini-buffer Operations

- Executes internal commands or inputs.
- `M-x`: Execute Emacs command.
- `M-:`: Evaluate Emacs Lisp.
- `M-!`: Run shell command.
- `M-|`: Run shell command with region as input.

Example:
```emacs-lisp
M-| sort
```

- Sends region to `sort` and displays result.

---

## Summary

This lecture provided an in-depth exploration of shell pattern matching via globbing and advanced shell I/O redirection. It contrasted shell functions with scripts and introduced powerful concepts for process control and script optimization. Regular expressions were comprehensively covered, comparing extended and basic syntaxes, special characters, patterns, and backreferences. The fundamentals of Emacs were highlighted, emphasizing keyboard efficiency, buffer manipulation, help facilities, and integration with the shell and system commands to support effective software development workflows.