So if I'm in the right room, this is Computer Science 35L. And my name's Paul Eggert. Oh, I guess I don't have to be in the right room for that. And the class is supposed to be about software construction. And we should start by saying what that really means, right? So you've all taken CS 31 or equivalent. And in 31, which is a prerequisite for this course, you learn basic algorithms and data structures. And you learn how to express them in C++. So you learn the very basics of writing sequential programs, right? So this is sequential programs. on one computer. On a single core, in fact. Sort of the heart of the computer. And that's very important stuff to know. It's sort of the basics of computer science and all that sort of thing. But to be honest, these days, it's just a small piece of what people normally do when they're writing software. This field moved at a rapid pace. So the average half-life of what you learned at university was maybe seven years. That is, after seven years, half of the stuff they told you was either wrong or obsolete or both. With time, the field settled down. Okay? That is, we learned how to do this stuff pretty reliably and the half-life of the stuff that we teach grew and grew and grew until it grew to be about 15 years. Still, of course, that means you have to spend a good chunk of your professional career learning stuff that we didn't teach you, but that's better. Recently, the half-life has shrunk. We're getting back, at least temporarily, to a pretty rapid evolution on how software is actually built in practice and that revolution recently has been machine learning. I am not a machine learning expert. I do not know the guts of machine learning better than the average reasonably well educated computer scientist, all that sort of thing. I go to the research talks about machine learning. In fact, I went to one today and I'm left thinking, oh my goodness, this is complicated stuff. Sort of the way you are. However, Not knowing the guts of how machine learning works doesn't mean you can't use it, as many of you already know. You can use ChatGPT or its equivalents without understanding exactly how ChatGPT works. What we're going to be looking at here is, I hope, by the end of the course, how this stuff is affecting how software is built. Right? How AI assistants, like co-pilot, and Cloud Code and those guys can help you construct software faster than if you do it all by hand. That being said, you still have to know how to do it by hand. These AI assistants have a success rate for simple stuff these days of maybe 75%, which will get you fired in most companies. They ask you to write something and you say, "Okay, here it is, boss." And there's a 25% chance that it's completely bogus. You're not gonna last very long. So you cannot rely on these tools yet to automate yourself out of a job. And opinions differ, but there's a good chance that you won't be able to automate yourself out of a job next year or the year after. That being said, this area of software construction is moving pretty rapidly and in fact it might even change between now and the end of the quarter when we're going to actually assign you stuff in this area. So that part of the course is still kind of up in the air. Oh my goodness. I'm trying to give you a pep talk on how great this course is and here I am trying to telling you that you're going to be automated out of existence. We have a remote control here that does not control that So you zoom in and it doesn't work either. Oh wait, it's totally delayed. It's delayed by 10 seconds. What is that? Here we have an example of software that isn't working. was zoom in on the on the blackboards. All right. Oh, this is. Yeah, it's sort of work and working well enough. All right. Thank you. Did you want to. I'll take. Yeah. All right. So you have the old one, but I should leave that in the bag for the next. Yes, that'd be great. All right. Thanks. Sure. Sorry about the technical interruption there. All right. So that's kind of the long term goal or sort of the long term project here. Any questions about the big picture? Well, I guess I should take a little poll. How many of you have used Generative AI to write code? More than 100 lines of code. Excellent. So we have a number of students here who already know this stuff and can help teach the rest of us, probably including me. it gives me wrong answers. So maybe I'm doing it wrong and you can help me out as well. In fact, for the final exam last quarter, it was late at night. I was writing the exam. It's like 2 a.m. I'm really tired. I have this interesting question involving Python. That's another thing we'll do with this course. And I just can't remember an important detail on how Python actually behaves. So I asked Gemini, And it gave me a very good looking answer. It was like, oh, I would have given it a hundred on, you know, and all that sort of thing. Except it was totally wrong. Right? And I knew it was totally wrong because it justified its answer with working Python code saying, here's how it works. And I tried the Python code and it worked exactly the opposite of the way Gemini said it would. And it worked actually the way I thought Python would work. So I was patting myself on the the back and sort of you have to watch out when you use these tools and that'll be one of the themes of the later part of this course. Anyhow, so I guess to some extent, you know, what we're doing here is software construction which is more the big picture, say the bigger picture. And when we talk about construction, some of that construction will be writing code, just like it was in CS 31. But a bigger part of it is going to be how to glue sort of code together. You'll be building applications at least for your project and for some of the other assignments in which you don't write most of the code that's running. Somebody else has written modules or packages or that sort of thing. And most of the time that your program's running is not going to be running your code. It's going to be running someone else's code. The idea is that you build on the shoulders of giants rather than try to reconstruct the entire statue yourself. So we're going to be focusing on this stuff. Now, of course, they told you how to glue code together in CS31. You could write pieces of your program and hook them together. How? How do you glue code together in CS31? Louder please. Header files. Header files which specify interfaces to classes, modules, compilation units. These phrases all mean ring a bell with you, right? So you'll be doing some of that stuff in this course as well. But to be honest, we're going to be focusing on other aspects of how to glue code together that are just as important as the classical object oriented programming stuff that you learn in CS 31 and 32 and which provide ways of hooking code together that's more convenient, more flexible and that sort of thing than many of the object oriented concepts are. And so that's kind of what's going on here in terms of sort of the bigger picture of software construction. However, I should Try to limit what we're talking about. Say it's the bigger picture, but it's not the even bigger picture. Right? The even bigger picture is a focus of a more advanced class, which a good many of you will take at CS130, which is software engineering. And as its name suggests, this focuses on a lot of stuff that is sort of assumes you know how to do software construction and then how can you build off of that. For example, software engineering talks about how to schedule software projects. Right? How do you plan for a software project? All that sort of thing. We are not going to be focusing on that here. Our focus is going to be at most say 5 person projects. The kinds of technology that you need to build even bigger stuff, we'll talk about some of that because some of that is useful even in 5 person projects, but the much bigger stuff, that's too fancy. We'll be saving that for CS130. So to some extent this is outside the scope of the class. Alright, so when you're doing software construction, Well, in some sense, your goal is to change the world. You want to make the world a better place by building a program that people will actually use. So not just a toy program that you write and submit on course web and then people throw it away. The goal is to build stuff that works. Right? But we're not building enormous stuff. We're building what some people will call an application. Right? So you want to build an app that people will use. Ideally, in the project that you'll be doing in the second half of the course, you will do that. At least that's the goal. I realize that's a big goal, right? Ideally, you guys will all start companies based on what you do in this class, right? And become, you know, reasonably wealthy and all that sort of thing. That doesn't really happen. But maybe I'll change this to want to use. You'll build a student quality application that is good enough so that it can be a demo or that sort of thing. It'll be an app that people would say, "Yeah, I might want to use that," and that sort of thing. So, for an example, one possibility. I'm just throwing an idea out for you. Say, a groundskeeping application for UCLA. As you've probably noticed, as you walk from point A to point B on campus, occasionally you will run across people that are making sure that the trees don't fall down and the grass gets mowed and all that sort of thing. That turns out to be a difficult scheduling problem because you have a bunch of needs, a bunch of problems that need to be solved. You have a bunch of people and you have to schedule which person will do what at the particular time. And that schedule is constantly changing as people call in sick, as people quit their job, as people get hired, as trees and the needs on the ground is changing. and all that sort of thing. So you might have an app for scheduling that. In order to write that application, you're going to need to understand the problem reasonably well. You'll have to write a specification for it, at least an informal one. We're not talking about anything fancy like for a 500 person project, but you'll need to know what you're going to do. And for the purpose of this class, We're going to have you do a project that fits into a fairly simple mode. We'll want you to do what's called a client server application. In which the basic model is that you have a server which is connected to the internet. and you can have multiple clients. These clients might be running on cellphones, they might be running on laptops, whatever. These clients will be communicating to the server. The server will give them answers back. So for example, if you're doing a groundskeeping application, The server will keep track of everybody's schedule, all the groundskeepers in the system, what they're planning to do today and all that sort of thing. And the clients, if they want to find out what the schedule is, or if they want to change the schedule, they will communicate to the server. This model is a relatively simple way of doing applications because in some sense what matters here is what's the state on the server. I'm going to draw a little picture of a This is probably on flash these days, right? Here's the important state of the system, the shared state, right? It's the shared schedule. And in some sense, clients never have to communicate to each other directly. There's no communication between this client and this client directly. All communication is done indirectly by talking to the server, right? A fairly simple way to do applications these days and so we're going to start with something simple. All right. This is going to be the basis of your project. And what we're going to ask you to do is to group together in teams of approximately five, come up with an application that you five people would like to do. Doesn't have to be groundskeeping. In fact, I suggest you do something and then specify the application and then go off and build it. That's kind of the, how shall I say it, the practice or the practical side of this course. In order to do this, we're not going to ask you to write any C++ code at all, totally code free from a C++ point of view. Won't that be nice? C++ is like the world's worst programming language. So it's going to be nice to escape from the C++ jail that you've been sitting in for the first part of your career here. That's the upside. The downside is that you'll be using a technology that you probably don't know. But that's okay because one of the major themes of this course is coming up to speed quickly. on a new technology. By new, I mean new to you, not necessarily new to the rest of the world. And learning how to use that as efficiently and effectively as possible. To some extent, what that means is this isn't a course so much on software construction as a course on how to learn software construction technology quickly. So in addition to this project, which will be based on pretty much whatever technology that you like, but we will suggest Node. and React. You don't have to use those, but at least we'll talk to some extent about this technology. This is all sort of JavaScript based. How many people here know how to program in JavaScript? Oh, good. You can teach the rest of us. All right? Okay. And so, you know, that will be one of the technologies that we use, but it's not going to be the only one. because I want you to learn other sort of basic technologies ranging from pretty old stuff to relatively new stuff to stuff that's even newer than that. All right, so in addition to this project we have a bunch of assignments. The project is a group project. Groups of 5. The assignments are going to be solo. And these assignments will give you a spec for what we want. You can go off and write code for how to do it and all that sort of thing. And they're more typical of sort of programming assignments that you might have seen in CS31. And you submit them on BruinLearn. We have test cases for them and all that sort of thing. All right, so any questions so far? All right, well, let's talk about sort of topics here. One way to think about the course is to list the technologies that we'll cover in detail, and eventually we'll get around to that. a little bit more abstract coverage of topics before we talk about the concrete software technologies that we'll be using. All right. So first topic is file systems. Okay. This is a fairly prosaic thing. Your data and your programs are stored in the computer in these things called files. Files are organized into collections of things called files. How does that stuff actually work? And we'll use as our case study, file systems on Linux. Which follow a model for file systems called the POSIX model. POSIX is short for Portable Operating Systems X. And the X doesn't really stand for anything. Okay? But the idea here is that we have a particular implementation of file systems. We have a spec for file systems. I'm going to talk to some extent a little bit about both. The next topic I want to talk about is scripting. Scripting is to some extent a pejorative name for programming. It's programming for amateurs, right? At least that's how it originally started out. Nowadays, I think it's fair to say more code is written this way than is written in the traditional sort of C++ or Java or that sort of thing way. It's a very popular technique for writing code. A lot of you have already done it. We will be talking about scripting with several different technologies, all, you know, the scripting in some sense. One is the shell. We'll be using Bash, right? which is a particular implementation of the shell. We'll also be doing some scripting in Emacs, which is a relatively simple and straightforward interactive development environment for writing software, very traditional. I pick it partly because I helped write it, partly because it's one of the simplest ones out there and we like to keep things simple. We're going to be doing a bit of Python scripting. Python partly because it's popular and partly because it's actually a nice system to be scripting with. How many of you guys have written more than 100 lines of Python code in the last two months? All right, so this part should be really easy. Third one is we're going to be doing sort of building and distribution. Here the idea is that it's not enough to just write the code or to write the configuration or to write the script or whatever it is. You also have to actually arrange for this system to build a running application out of the source code or specs that you've written. That process, the build process, ought to be simple. You ought to just be able to say run. But it turns out to be more complicated than that. Furthermore, even if you've built the program for yourself, that's not the same thing as getting the program to work elsewhere, to have your users run the program in production. That's the distribution process and we'll have to learn a little bit of how to do that as well. So here the kinds of technologies we're talking about is traditionally make, which is something you've probably used already at least under the hood. There's also NPM. There's a couple other technologies that we'll talk about that deal with building and distribution of software. Next major topic is going to be version control. Here the problem is that you'll have an application that is mutating. It's changing because you're making changes to it. You're making changes to it's a successful application. An application that doesn't change, at least in this business, is a dead program. That means nobody wanted to use it. If people want to use a program, you're going to have to update it reasonably often. And then you have the problem that you have lots of different versions of your program, and you want to keep track of all those versions. It's the most important topic. It feels like it should be, oh, you just keep, you know, write down version one, version two. What could be hard about that? No. It's going to be trickier than that if you want to do it well. Here, the technology that we'll be using is Git, which is the technology that underlies GitHub. GitHub is a front end for Git. And we will look at Git both from the user from the user's point of view and from the implementation point of view. We're going to look, well I would say at Git internals, maybe a little bit of Git internals, but at least at how Git is built atop of all of this other stuff. To some extent that will let us review the basics of file systems and scripting and that sort of thing in the context of a version control application. The topic that we will be investigating is low-level debugging. This, to some extent, sort of overlaps with CS31 and 32 because from the point of view of this course, C++ is a low-level language. It's pretty close to the machine and that sort of thing. Also, to some extent, this topic overlaps somewhat with CS33. How many of you guys have taken 33? Well, I haven't taken it, but I gave it. All right. I guess that counts. All right. So most of you have taken CS33. Some of you haven't, but you all had somebody sitting next to you that has, right? And what we'll be doing here, though, is a little bit higher level than what CS33 was thinking about. They were looking at single instructions and that kind of low-level stuff. We'll be looking at a somewhat higher level if you want to do, for example, dynamic linking. How's that going to work? If you want to do something that's machine specific but has a fallback when the machine isn't there, that sort of thing. And ideally, so this is going to be looking at things like GDB. And this is the assignment that I want to actually use some generative AI on. Haven't quite figured out how to do it yet, but I'm sure there's a pony in there somewhere. All right. Let's see. What else? Those are, there's six assignments. I only have five topics. What did I leave out? Any thoughts? All right. Well, I guess that's good enough. We'll figure out what the last assignment is. All right. What's that? Oh, client server. Oh, yeah. I guess we have sort of a client server intro, right? This is to get you going on Node and React. In some sense, this is the easiest assignment. That's why I sort of forgot about it. All right. So that's the topics for this course. And what I'd like to do is contrast that with CS-130 topics. Right? Remember, that's the software engineering course. That's the course that we're not going to be doing. But in some sense, I'm going to be telling you maybe what we're not doing. It's not clear. So, you know, obviously, you know, the topics here include software construction. They will talk about many of the things that we do. They'll assume that you know all this stuff and maybe build on it. But they also talk about things like the following. Integration. That is, in general, how to glue things together and what can go wrong as you integrate. You guys will be doing integration as part of your projects, but I'm not going to give you any lectures about it or any of the theory behind integration. I'll let you sort of learn that on the fly and then you'll go back and hear a more theoretical basis for integration when you take CS 130. Also, configuration. In practice, the configuration is a crucial part of software engineering. I'm not going to give you lectures on configuration. You're going to have to do it though, just to, you know, even doing some of the simple stuff. You'll say, "Do this step, do this step." Sort of get your software configured correctly. You'll follow that. For your own applications, you'll have to specify configuration. It turns out that this is a big topic and we'll just scratch the surface of it and I'm not going to give you lectures on it. Testing. In many real world software projects, more than half the budget is spent on testing. And I'm not, I don't mean half the budget in terms of CPU I mean half the budget in terms of human time. It can consume a great deal of effort if you want to build reliable software, reliable enough to run banks or to make sure your car doesn't crash and all that sort of thing. We're going to, you know, have you do test cases and all that sort of thing, but I'm not going to be doing the theory of testing, which is a fairly advanced subject. Forensics. The field of forensics in software engineering is figuring out what went wrong after it went wrong. That's sort of the core of forensics, right? Oftentimes when someone has successfully attacked your system, how do you figure out what they did? How do you clean up after the mess to make sure they don't do it again? All that sort of thing. Like detective work. It's a very important field. A lot of time gets spent in this. We're not going to be doing much forensics in this class. Any other big topics, do any other big topics come to mind? Things that you would like to see included in this course or excluded from this course? We only have 10 weeks. I'm using I don't stop two minutes of our precious time just asking you this question, but it's an important question, right? What's the best way to learn software construction without getting bogged down in that expensive time sink over here? You're gonna spend a lot of money on this, but we don't want you to get bogged down. In some sense, software engineering is the depressing part of building applications. I want you to focus I want you to get sucked in to the fact that software construction, building something and getting it to work can be a lot of fun. It's more fun than playing video games. Come on. So I want to make sure that we do the fun stuff and exclude the big ticket, not so fun stuff. All right. That's part of the motivation here. So any ideas for other things we should cover? or not cover? Yes? Data management and security. All right. Well, we have a whole course on database management systems, right? You know, this is like CS, what's the number? 140 something? 143 is it? Don't quote me on the number, right? All right, yes, let's do a little bit of that. I'll give you one lecture, or maybe half a lecture, on data management. Just enough so that you know what a database schema is and what ACID is and all that sort of thing, but not enough to do any real damage. Oh, the other topic here was security. We have a security course, right? What's the number on that? I don't know, 144? I'm just making these numbers up. up since I haven't taught the courses. We'll talk about that too. Maybe a half a lecture or one lecture. Again, enough to get you going but not enough to really be more than the bare introduction. To some extent, the reason I want to talk about data management and security here is those courses are optional. You can get a degree in computer science in UCLA without knowing anything about data or security, which is ridiculous. So we will at least get you an hour's worth of lecture into your brains. Even if you hate the topics and never want to think about security. I should mention a couple things, I guess, on this. We can just do a little bit of an aside here. So traditionally, a lot of people come into this major because they liked video games and they want to do more of that. How many of you have looked at the video game developer job market in the last year or two? How's it going? It's a boom and bust field. It's a bust right now. By the time you graduate, who knows what it's going to be. I'm not here to teach you video games. That's a whole bunch of other courses and that sort of thing. But I hope I can teach you the software construction principles behind video games. But really, you know, the two growth areas now where I have sort of employers saying, do you have more majors that know this stuff? One of them is machine learning. And the other one is cybersecurity. Right? Those are the two areas where there are jobs now. Okay? Again, who knows what it'll be like in three years or four years or six years when you graduate. But those are the hot areas now. Any other topics that you'd like to cover or not cover? Yes? I will give you your choice. That is, you have a project that can, you know, based on Node and React, that Node server can be a front end for a relational database server. And that'll be perfectly fine. That's actually a very It won't be required though. You can pick, say, an object oriented database instead of a relational database. Other topics to include or exclude. Yes? Real deployment means you have more than 10,000 users or something. Obviously we're not doing that. But yeah, you can really deploy application and get your fellow students to try it out. That's, in fact, I encourage that sort of thing. I can't promise that I will recruit the users for you, but real deployment is a good thing here. Other topics that we should include or exclude. Scope is an important thing. That's one of the things you'll learn in your project. You'll have to figure out what your project What the project will do and what is out of scope. It's too hard or it's not important enough to make the cut. And to some extent, I'm trying to do a scope for the course right now live as we talk. It may be your last chance to get a topic that you want into the course. Yes? Prompt engineering. Vibe programming, is that what you want? Well, I am not an expert in VIBE programming. I'm one of the worst VIBE programmers out there because the essence of VIBE programming is you can't know what you're doing. But I will try to do maybe a little bit on prompt engineering, a quarter of a lecture, shall we say. All right. And no promises here because there's a lot more to I'm not going to be lecturing on anything, you know, that entire world of Docker and Kubernetes and all that sort of thing. I'm going to skip over that. That's more of a CS-130 thing. I will do just very basic sort of building and distribution, it's going to be relatively traditional. Okay? To some extent, part of the problem there is you really need to know networking as well as everything else. Other topics. Yes? Distributed systems. Yeah, that's an excellent topic to do. And we have actually a course on distributed systems, a parallel and distributed computing. We also have a course on networking. I'll talk a little bit a little bit about distributed architectures, but not very much. One-eighth of a lecture. Because really it's a huge topic. There's a lot of fun problems there, but it's just too much for 10 weeks. We will stick with client server for the projects we're doing here, which is the classic way of doing a distributed system. but by no means the only way. Other ideas. Okay. Well, let's see. What should I do? I should tell you how to get a hold of the material for this course. We have something on Brew and Learn. So you should log in and go there at least temporarily. There are some people that are trying to get into the course, but they don't have PTEs or that sort of thing. They can look here. Web.cs.ucla.edu classes Spring 25 CS 35L. And you'll be able to find the core sort of material of the course. including the first assignment which is due of what two weeks from today I think approximately right so you get a little bit of time to get the first thing done and so you can look there for much of the stuff that I'll be talking about you know the organizational material for the class and that sort of thing in this talk all right anything else why don't we take a little break now and start up again at about 4 minutes to the hour. Professor, have you seen the iPoding ID on these like Windsurf and Cursor? Essentially they have these chat thing on the right where it understands all your context and you're able to type the stuff in. I was very lazy. I was just doing a neural network for something. Oh no, it's really good at that sort of thing. It's bad at what I want to do. That's been my problem with it. What is the stuff that you want to do? Let's see, what's the latest thing? The February version of the GCC complains about a variable being vulnerable to long jump attacks and the January version of GCC says it's okay. Why does the February version say that it's busted and how can we pacify it so it doesn't complain anymore? That's a problem I just ran into. three hours ago. And but if you ask that of these tools, they'll think for a while and then spit out nonsense. At least that's been my experience. They're getting better, but they're still not good at the really detailed stuff that I tend to get stuck with. Now this sort of stuff, at least if you know the field is easy, so these tools tend to be better for areas where you don't know what you're doing. Oh, no, no, absolutely not. At least not for software development, maybe some other fields, but not ours, not yet. Wait five years. All right, let's start up again. All right, so I really have the obligation of telling you the mechanics of the course as opposed to the sort of overall goal. That stuff is at this URL, which I've now put up on the screen. So to some extent, I'm just verbally telling you what you could find out just as well by reading, but that's also true for textbooks, so here we are. And this is reasonably important stuff, so it's worth my repeating, but that doesn't mean you shouldn't read it. Please go read it as well. So first off, we have sort of the course overview. I have the prerequisites listed here which is 31 for those of you that have transferred here from other universities that means you know basic algorithms and data structures. This course is a four unit course which means there's four hours of lecture, two hours of discussion or lab, I think they're officially labs in this course but whatever discussion and then six hours of outside study. That's the numbers we tell the registrar in from the dean, it's not the true number for this course because outside study will be more than six hours some weeks and less than other weeks. You know, some weeks you'll only do five hours and some you'll do 15. And the lecture isn't really four hours. I just gave you an eight minute break and there's ten minutes chopped off at the end of the lecture and the laboratory is also really, you know, one point 7-5 hours or something like that. So these numbers aren't quite correct, but they should be reasonably close. If you find yourself spending 15 hours a week every week, then that probably means you're not doing it right. And it suggests that you should be coming to discussion more often, coming to office hours more often, perhaps talking to the tutors that UPE offer. They're a very valuable resource. Talking to your fellow students. A lot of that can be done during the project, but in the early part of the course we don't have a project, so talk to your fellow students anyway. Basically the idea here is we want you to learn a lot in this course. We want the learning curve to be as steep as possible, but we don't want you beating your head against the wall. We don't want you staying up until 3 a.m. because you put the semicolon in the That's an inefficient way to learn. If you find yourself beating your head against the wall, stop doing that and contact one of us and get some help. We'll be happy to help. All right. The middle part of the screen is the official content of the course from the registrar's point of view. And then the ACM and IEEE, which are the two major professional organizations in computer science, have a list of curricula for computer science programs all over the country. And the idea being that each course should be connected to a small number of topics in the computer science curricula. I don't have a small number. They want like three or four topics per course. We have what, about ten? That's, and so to some extent that means this course is broader than typical for courses. and also shallower. We won't be able to go into each topic as deep as a true course on, say, security would go. All right, so if we take a look at, oh, we use Piazza for communication. You have to log in. I'm not going to log in here. So if you have questions that you'd like to ask the TAs or the LAs, that's an excellent place to ask. I encourage you to use Piazza. I encourage you so that if you use it you'll even get points that will help you get a slightly higher grade. Okay? So please use it as best you can. There's a news section here that talks about the news only from the point of view of the static web pages of the class, right? So this is all maintained independently of Bruin Learn or anybody else. And here I'm just talking about the changes to the core part of the class that we're going over today. There will also be announcements on Bruin Learn and on Piazza, so you know, have a tab open to each of those. This page won't change very often. All right? But the news for today is assignment one is available. It's relatively straightforward, but there's a lot of little things to do. Since we're going to be using CSNet or a CSNet style environment to make sure that your assignment works, you should create a CSNet account, make sure that you can get your code working on CSNET. Do that now rather than just before the due date because occasionally there's glitches in getting your CSNET account. If you are not enrolled in the course and not on the waiting list, I do try to squeeze in as many students as I can. I like to do that and I used to be able to say I haven't been able to turn anyone away for the last five years. Unfortunately, last quarter I broke that streak. The class was too crowded and I just couldn't squeeze everybody in. Something happened while I was on sabbatical last fall. I'm not quite sure what. And so I'd like to say again, you know, I'm good at squeezing everybody in. I try to do it, but I just can't guarantee it. We'll see what happens, right? But in the meantime, you can visit this webpage and sort of stay along with the course. Also, if you are not yet enrolled, Please click on this URL here and follow its instructions. This is good advice to follow, you know, for this class or for any other class where you're trying to get enrolled and you can't squeeze yourself in. Next topic is going to be the syllabus. And here are all the topics we're going to cover. Oh my goodness, there's a lot of stuff here. I'm not going to go into the, to some extent, I've already mentioned that in the first half I'll just focus on the first subhead because this is the stuff we'll be doing in our first assignment. This course is very assignment oriented. Okay? That is, I try to structure my lectures over what you need to learn in order to do the homework. The discussions are even more focused on that. And I sort of delegate the homeworks and the projects to the TAs. They're in charge of all of the heavy lifting about teaching you the details you'll need to do to homework one and all that sort of thing. My focus will be more on sort of the high level of stuff, right? Basically how the Unix file system organization, I'll draw pretty pictures and that sort of thing. They will give you more specific examples and that sort of thing. All right. And we'll also be doing a little bit of the second bullet, I suppose. commands and basic scripting, the first assignment does a little bit of both. There's more on this. I don't have an exact mapping of syllabus topics to dates of lecture because I'm not that organized, right? I'm going to talk as long as I can about, you know, the organization of the course today and then next time I'll talk about this stuff. The more questions you ask, the slower I will go. The fewer questions you ask, the faster I will go. So in some sense, you can think of it as being in your self-interest to ask good questions in class to slow me down so that you have less to study for the exam. On the other hand, maybe you just want to hear me blather so you learn as much as possible. I'm happy to do it either way. I really want to rely on feedback from you to tell me what I should talk about. All right. Next topic is going to be... Oh, resources for written reports and oral presentations. So by the end of the class, you will have to generate some reports and you'll have to. You'll get to do presentations for your final project and all that sort of thing. Oftentimes, questions come up, well, what are we looking for? and those presentations and to some extent this is some of the things we're looking for. I'm very big about giving proper credit to other people's work that your work is based on. So if you write a report and if you've used some paper or some news article or whatever in order to do your report you should cite them and cite them in such a way that people can find them now and also find them later. Very good practice. Obviously, you know, it's overkill for this course, but it's a good practice to get into now for when you do this stuff later and this stuff really matters. So I suggest a format for references and citations and I say things about document object identifiers, which you need for scholarly papers and all that sort of thing. So please follow that advice whenever you do a report. When we are grading written reports, we look for things like the following. So here's a bunch of people that say here's what we're looking for when you're writing a good technical report. To some extent, again, this is overkill. Here they're talking about how to write a research paper that you could publish in a computer science journal or proceedings or something like that. You don't need to go that far, but you should know some of that territory. I'm not asking you to follow all these and read them, but you should at least follow some of them to get a feeling for what's going on. Right? So for example, the second from the last bullet there says, here are some templates to use when writing a scientific report, a computer science report. Well, go and look at the templates, look at what the papers look like, because this is where a lot of the academic world actually spends a good deal of their time. The last bullet here is an example rubric that we might use when reading one of your reports. And it shows what the grade will be dependent on. The last major area here is for oral presentations. Because you'll be doing an oral presentation for your project at the end of the quarter. Again, the same basic idea. You don't have to read everything here. But look at a couple of them and follow those tips. There is a classic talk like how to give a bad But anyhow, David Patterson's classic, "How to give a bad talk." I recommend that because it's short. He gives you several bullet points for how to really do a bad talk and then you can basically do the opposite of everything he suggests. Any questions on these resources? All right. Here's the work that you get to do for this class. All right, first off, we have exams. There'll be a midterm at the end of the fifth week. There'll be a final exam at the time and place scheduled by the registrar. They've already picked the time. The place is still up in the air, but we'll just go wherever they suggest. All right. I'm also going to ask you to do some work in evaluating me and my TAs and the LAs. So you'll be asked to do four evaluations. One midterm evaluation for our learning assistants. One final evaluation for our learning assistants. One will be about the time of the midterm exam. One is going to be at the end of the quarter. And at the end of the quarter, I'm going to ask you to do the usual course evaluations that you should be doing for every class at UCLA. But, you know, the end of the quarter, you're pretty busy. You've got other stuff to do. I get it and all that sort of thing. So to sweeten that, we're going to do a lot of We'll give you a few points for actually doing that. A big part of this course is a project. I'll be talking a bit more about that later and the TAs will be spending a lot of time talking about in discussion. And then the assignments, which I've already briefly mentioned, are typically, not all, but typically divided into two parts. There's a laboratory part, which at least in theory you can do during discussion. And then A homework part, which in theory you don't do in discussion. In practice, the distinction between the two parts isn't as sharp as you might like. Some students just get the whole thing done in lab. Some people do it all at home. That's fine either way. These are solo projects, so you're expected to do them by yourself. Please don't share code or anything that detailed with your fellow students. code on their own, but it's okay to share general ideas. That's fine. Let's see. You have to write your code robustly. Don't put in stupid limits like strings can be at most 255 bytes, that sort of thing. That kind of thing is okay for CS31 perhaps, but not for this class. We want to have code that won't fall over if it's given unusual input, right? So even if someone feeds you an input line that's 100 kilobytes long, it should still work. That sort of thing. Let's see what else. Some of our assignments will come with skeleton code with a particular style. Please stick with that style in the code that you write rather than invent your own wonderful way of programming that is going to be hard for the grader to understand. And let's see. Assignments are due by, I should not say by, before 5 minutes before midnight on the due date. So if you turn it in and the clock says 23:55 exactly, that means it's late. It has to be 23:54:59.99, then you're alright. I'm being very precise here, A, because I'm sort of a time nerd, and B, because students have actually tried to say, well it came in on... anyhow, that's a long story. a proposed schedule for all this stuff. All right? And here is the proposed schedule. It's not a complete schedule because I haven't put in all the project interim due dates here, just the end due dates. But this should give you a feeling for when stuff will be due approximately. This stuff is all tentative except the first line, we have the first assignment out. You can click on all those others to find out We may and often do change them before we officially release the assignments. So please don't rush ahead and do all the homeworks in advance. You may have to redo them. Okay? The first assignment though, we've pretty much figured that one out. The due date for the first assignment is the 14th of this month, which means, oh, it's less than two weeks. It's 13 days. Okay? Next to all of this, I have the percentage of the total grade for the course for each assignment. Okay? And these numbers do not add up to 100%, as you can probably tell. I'll do more details about grading later on. But as you can see, the assignments are typically worth about 3% of the grade. The assignment 5 is the hardest one, so it's worth 4. Assignment number 1 is pretty, and 3 are pretty easy, so they're worth 2, that sort of thing. Any questions on this? work schedule. Okay. Next topic is going to be grading. So the overall weights, I gave you more detailed weights for assignments in the previous screen. This screen is the overall weights of the course. So these numbers do add up to 100%. You're going to see the assignments, the six assignments are collectively worth 18%. They're not all 3% but they average out at 3%. Class participation, which we measure by how much you engage on Piazza, is worth 1% of the total grade. The two feedback surveys for LA's are worth half a percent total, which means each is worth a quarter of a percent. Similarly for the two course evaluations, which you do at the end of the quarter, The midterm is worth 18% of the class. Final exam is worth 27%. And the project is worth a little bit more than a third of the course. We have a lateness penalty that is a little bit unusual. If you submit something that's one day late, and by that I mean anywhere from zero to 24 hours late, then we only take one point off, you know a hundred point assignment so it's it's no big deal but then it grows geometrically after that it's three to the n minus one if you are n days late so the penalty is one point for one day late three points for two days late nine points for three days late then 27 points then 81 points then please don't bother to turn it in okay in some sense this is unrealistic in the real world if your software is You talk to your boss and say, "We're going to be late on this. We just can't get it done on time." And then you negotiate with your boss. The boss might be your customer, whatever. Sometimes you decide to make the deadline anyway, but you submit a subset of what you originally promised. Sometimes you can't do that, and so then you either negotiate an extension to the due date or you get fired. Something like that. I also don't want people to sort of keep negotiating extensions over and over again. So to some extent this is a weird simulation of the real world that's not very accurate but it's kind of the best I can do. Because the real world oftentimes you can be at least somewhat flexible. There's an exception though to this lateness policy and the exception is Friday 10th week is the drop dead date for everything. So even if the due date is say Wednesday of week 10, you can turn it in two days late, Thursday, Friday, but not more than two. There's a couple reasons for that. First, I don't want you guys working on projects when you should be studying for the final exam for this or other courses. Second, having people turn stuff in late puts a lot of burden on our readers and graders and that sort of thing. They have the exams of their own to do. I don't want to overburden them. All right, so any questions on grading or the mechanics of grading? Now I get to talk about academic integrity. You've probably heard this boilerplate before, but it's worth emphasizing. You are expected to hold the highest standards of academic integrity, which means when we say you work on stuff by yourself, you work on it by yourself, you don't get help from outside. This is kind of a tricky business these days. Because you can easily search for solutions to the homework assignment already posted on the net by people who took this course in previous quarters. You can use Google or any of the other search engines to find that. You can also find this stuff indirectly because my code and code by students who've done this stuff previously has been and fed into generative AI engines as training. So in effect you can use copilot to search for solutions and not know where the solutions came from and not care, but there's a solution that pops up on your screen. Don't do that. A, you're not going to learn anything. B, you're not going to learn anything. And C, if we catch you, it's not very likely, but if we do, you'll be in big trouble, right? But A and B are really the important things here. To some extent, what typically happens here is people get pretty high grades on the assignments. We have an auto grader. You can submit the stuff. If it says you got this wrong, you can resubmit it and all that sort of thing. So you should be able to get pretty high grades on the homework. And if you use these extracurricular methods to get the homework, you've kind of cheated yourself, right? And, you know, to some extent, that's That goes against the principle that I already suggested, which is that you should give proper credit to your predecessors. And if you use generative AI, that's one of your predecessors. So to some extent, what I'm going to suggest here is that we attack this problem as follows. You can use Google searches and you can use generative AI, but make sure you use it only to find out general ideas rather than specific code for this particular problem. I realize that's a blurry area, but we're exploring this blurry area together. And the way that I would like to address this issue is if you use these techniques, you don't have to, but if you use them, write down all of your questions, all of your prompts, write down all the answers you get back from either from all the URLs if you did a Google search or the code that, you know, You know copilot prompt gave you back. Just write all that stuff down and I'm going to ask you to submit that as an appendix to your assignments along with a very brief sort of after action report in which you say whether using these tools helped you learn the stuff or in some cases gotten the way of learning the stuff right. Sometimes you'll find that using these tools actually makes it take longer for you to figure out how things and I'd like a brief action report about that. To some extent, this is my way of gathering information about how students use these tools, right? Most of you are using them. I don't know how you're using them, but we're going to find out by doing these after action reports. Any questions? I hope there are some since this is the first time I've asked for this in this class. No questions. No questions, really? Yes? Will this be on the website? Oh, yes. Well, so for example, if we look at homework one, which is posted somewhere, right? So here's the first homework. It goes on and on and on and on. But then right here at the very end, it says, oh, you know, So here's where you put all this information about the generative AI that you did, right? And it's just going to be a simple text file. I'm not asking for a particular format and all that sort of thing. Just log what you do and give us the log. Question? No. Yes? Yeah, you don't have to give me all of the URLs that gave you back. Just give me the list of URLs you follow. That's good enough. Okay? Other comments and that sort of thing. I'm old enough to remember when I taught this course and a TA wrote part of the first assignment and in that assignment the TA said do not use Google searches. You'll be cheating if you do. I quickly learned that was a mistake. We've erased that part of the assignment and to some extent that's what I'm saying here for Copilot or Claude Code or whatever. questions about this? Okay. So let's see, what else do we have? I think we've gone through all of the organizational material. We've gone through grading, work involved, that sort of thing. Okay. Well, I guess we have a little bit of time left to do something real. And if this is working, Let's try doing a little bit of files and shell scripting. So what I'm going to do now is do something that may look very primitive and low level, but that's okay. I want to do something primitive and low level now. I want to log into CSNET. I have here a laptop running Linux. And so if you're running Linux, which you're You should learn how to run one way or the other. I can SSH into penguin. Oh, not penguin. That's the machine I'm on. What am I talking about? That's going to take a while. Let's try that again. Now it's hung. We will try this in a different way. All right. into LNX SRV 11. There's a number of servers on CSNAT that are all running Red Hat Enterprise Linux 9.5, which you can tell by doing this command. And what I'm doing here is I'm talking to the Linux shell. The Linux implementation of the shell is called bash. It's a very straightforward command It's a command line interpreter or CLI for short. Right? Right? And it's a command line interpreter. If you're used to doing software developer development in the ordinary way with a mouse or a touch screen or that sort of thing and you do a little bit of typing but most of the stuff you do is, you know, done indirectly by a graphical user interface, this will seem very old-fashioned and low-level and all that sort of thing, which is true. But there are some important properties of command line interpreters that you should know about, and the way you know about it is you actually use it. So to some extent, here's a diagram of how this works. At the bottom, we have the hardware. On CSNET, this particular hardware is an Intel Actually, what is it? Let's take a look at that. I've forgotten what kind of hardware they're running. CAT PROC CPU info. Let's do a less instead. So this is an Intel Xeon 4116, right? This is a very popular model on servers. It's an x86-64 architecture. The exact model might It might depend on which CSNet server you use, but this is the particular one we have now. Running atop the hardware is going to be all of your software, right? But that software is partitioned into a bunch of pieces that you need to know about. In some sense, the core piece is the Linux kernel. This system is running Linux, or sometimes called GNU Linux, which is an operating system. The operating system is a very big thing with a lot of moving pieces, a lot of parts and all that sort of thing. The core part is the Linux kernel. It can talk to the hardware the same way your applications can talk to the hardware. So it can issue loads and stores and all that sort of thing. And it can do ads and all that sort of thing. But it can do some hardware operations that ordinary programs cannot do. A simple example of such an instruction is it can issue a halt instruction which will power off the machine. Your application program cannot do that. You cannot log into the CSNET server and compile an application that executes the halt instruction and run it and expect it to work. So these instructions are called privileged instructions. They're rarely executed. Almost all the instructions that the Linux kernel issues are the ordinary add, subtract, multiply, load, and store instructions that do things that you did in CS31. But it can also do these privileged instructions. And then there are unprivileged instructions, which are most of the instructions instructions at least by execution time. Things like add and load and that sort of thing. And your programs, which sit up here, can execute this. Your programs can also talk to the kernel indirectly by issuing what are called system calls. From the point of view of a C or a C++ program, these system calls look like like ordinary function calls but they act completely differently. Ordinarily in a function call when you execute the function you are executing the same unprivileged instructions that anybody could execute. You're doing ads and loads and stores and calls and all that sort of thing that's unprivileged. But system calls are special because they drop into the kernel which has more rights than you do. An example of some system calls would be things like open, open a file, do a read, do a write, do a close. So they look like function calls but they're more complicated than that. Because they're more complicated than that, they're actually more expensive than ordinary function calls. There's more overhead associated with the system call than with a function call that would do approximately the same thing. Another important part of the operating system are a bunch of libraries. The most important library is going to be the C library. It's a low level library that pretty much everybody else is going to use one way or another. But there's a whole bunch of other stuff, right? There's one for standard C++. There's, you know, a bunch of, there's some crypto libraries, a whole bunch of other things. You can tell which library, an application might want to use by running the shell command ldd. So for example, I just ran the command less. I can see what libraries it's going to use by running this command. Less lives in user bin and ldd inspects less and says to less, "Hey, what libraries do you want to sort of have your beck and call when you start running. And LDD will say, oh, Les needs libc.so.6. That's the C library that I mentioned. It also has a bunch of low-level Linux libraries. And then there's libtinfo, which is a terminal info library because Les wants to be able to sort of use cursor motions on your screen. Running atop of these libraries are going to be your applications. These applications are programs that are running. They may use some of these libraries, but these libraries get their work done typically by doing system calls. Now I want to draw a clear distinction here between a program or an executable, which is a static object. And in Linux these programs are files, just like data files are. And they sit there and you can copy them, you can look at them and all that sort of thing. There's sort of that's one thing, right? We have executable files. Often just called executables. Microsoft Windows actually sort of has that distinction very strongly. These files have file names that end in.exe. Linux, executable files can have any name you like. They don't have to end in.exe, but the basic idea is if you look in this executable file, you'll see a bunch of machine code. But there's another way that we can think of programs that in some sense is more important. These executable files are not running programs. They're just potential programs. The real applications in Linux are called processes. Each process is a program that's currently running or maybe paused, but it's a program that's running on your machine. The relationship between processes and executable files is not one to one. You can have a single executable file that corresponds to several different processes. So for example, this could be the executable file for Emacs. I can log in and I can run emacs you can log in and you can run emacs we will have two different processes both running the same executable file the same program it's a very common thing to have okay and is the let's see that's two difference of these running the same one of these is the reverse possible no you can't have two different ones of these corresponding to a single process that doesn't work All right, so what we have here is a shell. And how does the shell fit into this? There's two ways to think about the shell. The first is sort of, you know, its name sort of reflects the idea. You have the operating system here. Inside the operating system you have a bunch of programs that you want to run. So here they are. And surrounding the operating system and all the executables that you might want to run, you have a thin layer. This is the shell. The idea here is that the shell gives you a very thin window around the real system. The shell itself doesn't It doesn't do much of anything. All it does is it lets you run the programs and that's really what you're trying to do. We want the shell to be as transparent and as simple as possible. We don't want the shell itself to do very much computation. All we want to do is to set up the programs that will actually do the real work. So it's very common to have shell scripts that do fancy, I don't know, machine learning or or whatever. The shell itself isn't doing the machine learning code. It's just setting up Python to be invoked in the correct way. That sort of thing. Another way to look at the shell, and it's also a valid way, is that when you log in, here's the machine code for the shell. It's just another program. So when the shell is running, you know, we might You might be running bash, which is a particular instance of the shell. Here's a bash. When you log in, you get a process that's running the shell, which is a program. And in some sense, it's like any other program. In fact, what you can do, if you like, is go read the source code to bash. Bash has somewhere in the source code a main function and you can see how bash will run if you start it up. It's just like any other program. But what Bash will do very often is it will start up new processes. So I'm going to draw yet another diagram. You can think of at the top level of the Linux system, there is a single boss process that starts up when you boot. The name of this process depends on which Linux flavor you're running. on this particular one, it's called systemd. On other ones it's called init and that sort of thing. When you log in to CSNAD, systemd will arrange to be running a bash process. This again is a running process on the machine. When you then type a command into bash, like I did with less here, right, what bash does is it runs yet another process, a subsidiary process called less. While less is running, bash just waits. It's not doing anything. It's just waiting for less to finish and bash is totally out of the picture. We are just talking to less. But the minute I exit from less by typing in this case q, which is less is way to say I'm done, then we're running bash again. process tree here. Somebody else might be running bash as well. There might be a third person that's running some other shell. That sort of thing. And there will probably be other possibilities. Each of these people can be running their own commands independently of the other people. So what I'm going to do here is I'm going to run a command that's near and dear to my heart called emacs. Which is short for editor macros. It was originally written as a macro package believe it or not. So what we can do here is we can run Emacs. And at this point we are in what you can think of as being a text editor except this text editor is sort of a Swiss Army knife text editor. You can edit text files with it and you can do a whole bunch of other things. Any questions about what we've seen so far? Yes? What does that say on the right of the second pass? Oh, TCSH. It's another implementation of the shell. MacOhess has their own shell. You know, there's lots of different shells. The idea of a shell is a common one that you'll see implemented in many different ways. Other questions about this? All right, so what I can do here is I can just type, you know, some text, right? Some text. And Emacs, if you just type ordinary characters into an ordinary window, basically that means please insert this character wherever the cursor is and then move the cursor. It's just like a text editor. But Emacs has a bunch of other stuff you can do and that other stuff is introduced by characters that are not ordinary ASCII characters. So Emacs commands. Sort of the simplest case is an ordinary character. That means insert that character. What's the most important thing you should learn about a program when you're first starting it up? Any program? Yes? How to exit. Very good, right? So to exit Emacs, you type control X, control C. So I'm going to write this down. This is the notation that the Emacs documentation uses for control characters. And the way you type it is you hold down the control key, okay, and you type the character. You know how to type control characters. I do this so often with Emacs that I've remapped my keyboard. The caps lock key, which is totally I now have as my control key. That way I don't have to move my little finger so far and I'm less likely to get carpal tunnel syndrome, which is a hazard in this business. All right? Okay. No, I'm serious about that. I have it. Richard Stallman has it. Bill Gates has it. Everybody that's done a lot of hacking is going to get carpal tunnel syndrome unless you, you know, be very careful about your key usage. All right? So this means exit Emacs. And you know how control characters work, right? Is this stuff they teach you on CS31? What's a control character? All right, let's do a little brief summary here. The ASCII character set has sort of, you know, you put ASCII characters into an 8-bit byte. An ASCII character is in the range 0 through 127 which is the same as 0 through 7f hexadecimal, which means the top bit of an ASCII character is always 0, right? Because a byte can go up to 255. Well, if you take a look at the ASCII character set, you can find a map of it on the net and that sort of thing. You'll see that it's divided into four major areas, each with 32 characters in it. The printable characters are in this region. So in particular this character here is a space. This character down here is a del. The del is the character that has this bit pattern. It has all ones for the bottom seven bits. Top bit has to be zero because that's asking. All these other characters are going to be sort of printable characters. And right about here is an at sign. Here's an A, here's a B, here's a C, here's a D, right? So at sign is character number 64. Capital A is character number 65 in decimal and that sort of thing. When you type control A, what the keyboard will send to Emacs is the A that you type except with that bit cleared. So right here is the character control A. If you look at the bit pattern, it's character number one. Right? Because over here we had character 65, we turned off the top bit, or I'm sorry, the top bit of ASCII, the second bit of the 8 bits, and so we get this character. So there are 32 control characters here. The first one is character zero, which is the null byte, which you were told terminates a string. But in the real world, the null byte is a perfectly valid ASCII character. And you can type it by typing control at sign. So when I type control X, control C, what's happening is Emacs gets the two bytes, control X, which is roughly here, control C, which is roughly here. And that's what Emacs EMACS uses to figure out, "Hey, it's time for me to exit." You can find out more about what a command sequence will do by typing a special command. We'll start up EMACS again, which is control H. Control H in EMACS is the help key. See, it says, oh, I can give you lots of help. Which kind of help would you like? I'm going to type control h k. And the idea here is after you type control h a, you can type whatever control sequence you would ordinarily want to do something. It won't do it. It will just tell you what would happen if you typed it. I'm going to type control X, control C. And what it's going to do, at least what it should have done, is put up a help window. What happened to my help window? Oh, here it is. I have a slow network connection. Sorry about that. So here, if I type this sequence of commands, this means help on exit. It has a whole bunch of commands that will tell you about its commands. In some sense, you can think of it as being, I don't know, fairly... Emacs likes to gaze at its navel. It likes to look at itself. And that's actually for sound technical reasons. We want to have this software development program because that's what Emacs is mostly used for, to develop software. If it's really good at developing software, it should be good at developing itself. One of the things you want to have in any decent software package is good help for when people get lost. So Emacs has a help button to sort of figure that out. And here's one way that you can sort of figure that out. This sort of description here, oh my goodness, goes into a lot of detail. But basically it says if you run ctrl X, ctrl C, that runs this emax command. You can run it yourself by the way. So let's do that. If you prefer to run it the long way, you can type meta x and then what is it? Save buffers kill terminal. Save buffers kill terminal. RET is Emacs's way of saying you just hit the enter key. Return is another control character that's sort of hardwired to that. What is this meta X? Well, the idea is that you have another key on your keyboard that's the meta key. The meta key is like the control key except What the control key does is it clears the second bit from the top. This bit right here, right? It turns this bit to zero on what you were already going to type. What the meta key does is this instead. Instead of clearing the top of the second bit, it puts a one in the top bit. So if I type meta x, right, emacs says, oh, you typed, you know, this character with the top it's not an ASCII character, but that means that you want to be going into the bottom line of the EMACS, which is the sort of the command line, and type whatever command you like. We want to do save buffers. And you can, you know, type tab here to get, right? And if I now type enter, That's the same as if I type ctrl x, ctrl c. So you have a long way of doing things and a short way of doing things. Sometimes you'll want the long way for reasons that we'll discuss later and sometimes you'll want the short way. All right. Any questions about what we've done so far? It's been very simple. We've just logged in, started up Emacs, figured out how to exit Emacs. We'll do more next time. And we'll be starting to talk about the file system.