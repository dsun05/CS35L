All right, let's start up again. We still have a few more things to talk about with the shell. And I also want to talk about regular expressions. And I also want to talk about Emacs, not necessarily in that order. So first off, last time I briefly alluded to globbing, but I realized in looking back at what I did, I didn't tell you everything.

This is a particular form of pattern matching that's commonly used for file names. And as I mentioned last time, it doesn't always have to be used for file names. You can use it in a case state. Either one. In some sense, it's a subset of regular expressions. It's a notation that attempts to be simpler and also faster than the full regular expression syntax. It's also designed kind of for file names. So it has a few extra sort of rules for file names. So I'd like to start off with it first, partly because it's simpler. So in globbing, you have a pattern. And then there's a question of what it matches in terms of what file names or other strings it will match.

And the simplest pattern is just any ordinary character, which just matches itself.

There are, however, a few special characters. The ones you've probably run into are star, which matches any string.

So any sequence of zero or more characters, star will match it.

Question mark which matches any character. That is, it has to match one character, exactly one character, no more, no less. And then a more complicated syntax which can match any character out of a set. And we use square brackets to denote that it's matching a set even though in mathematics you always use curly braces. We know better. We'll use square brackets You can put whatever characters you like in here, like this, and that will match any character in that set of characters. But it'll always match exactly one character, no more, no less. So it's like question mark, but it's pickier, right? It will always match one character, but it won't match any character, the characters in this set. There are some shorthands you can use here. You can use something like this to match any character in the set A through Z. If you want minus sign to be in the set, like you wanted to match any lowercase ASCII letter or the minus sign, just stick it in the end like that. That way there won't be any ambiguity.

There is or are a couple of exceptions to this general rule for pattern matching. The first exception is the following. Slash, of course, matches itself. But none of these other guys match slash if we're talking about file names. Right? Do not match slash.

That is, these patterns only match file name components. That is, the parts of file names that don't have slashes in them, right? So a file name component in a directory will tell you how to get from that directory to the next file in your path, and that's what these patterns are good for. They're good for matching file name components. They're not good for matching directory seven which is the slas itself. So that's one exception. The other exception is even a little trickier. And this comes from the common convention in Linux that file names starting with dot are file names you don't want to see. So for example, if I create a file name starting with a dot, well in fact there is one here called del.

and say echo star. Star should match all file names in this directory, right? Because they all have names. You know, star says I'll match anything. But notice that it matches bar and bay and baz and boof and all that. But it doesn't match del, dot del. And that's because it begins with a dot, right? And so the idea here is that dot star does not match a a string that starts with a dot if the star is at the start of your file name as well. If you want to match a file name that begins with dot, a file name component I should say that begins with a dot, you got to actually put a dot there. Actually now I wonder what happens if we do this? Echo question mark del. Notice question mark doesn't match the dot either.

So the file names beginning with dot are supposed to be hidden. You're not supposed to normally sort of want to see that. Now if you actually want it, of course you can sort of say it. We could say something like this echo star and something like this. And that will match all the file names in the current directory including the ones that start with dot as long as they have at least two characters after the dot.

Any questions about file name matching?

One other thing that you should be able to tell by looking at the previous echo is that in the shell, if you write down a pattern and it doesn't match any file name, then they just leave the pattern as is and pass that on to echo. That's what happened with this echo question mark del. It didn't match any file in that directory.

because question mark at the start can't match a dot. So it just gave that question mark del to the echo command which just obediently echoed it. Yes? That's right. None of these guys match slash. Right? So that was the first sort of exception. And the second exception is they're not going to match something with a dot. Right? We don't want to match dot because we want those dot files to not get in the way. They sort of, we want them to be hidden. And we don't want to match slash because that would be too expensive. It's relatively cheap to look at a single directory and say, give me all the file names in that directory. But if star could match slashes, that would mean we'd have to do a recursive descent through all the files in a directory hierarchy, and that would be relatively expensive. That's why star does not match slash.

Question. Question. The dot in the first character? Yeah, if you want to match a dot, you've got to start with a dot. Yes, a leading dot, I should say. Oh, yes, I could. And in that case, this echo that I just gave you wouldn't match it, right? So we can say touch dot x, and then we can say echo dot question mark.

and that's only going to match.del, it won't match the x. If on the other hand, I say something like this, that's going to match the.x, but it's also going to match. and.dot, which is kind of annoying. So you can write a series of globbing patterns that will match every file in the directory except for. and.dot, but it's going to be more complicated than what I've already given. All right, other comments?

Yes?

Can you put slash inside of the expression?

Oh, yeah. So for example, we can say echo slash bin star sh, right?

So what that does is it causes the first star to match anything under slash that sort of where any of the rest of the pattern works. In this case the only such thing is slash USR and then once we get to user bin the star SH says give me every file name in user bin whose name ends in SH and whose name does not start with a dot. Yes? Is there a way to write a command so it doesn't list certain things? So it doesn't?

You want to do sort of match everything but something. Yes. You can do something like this. That is if your bracket expression begins with an exclamation point right after the open bracket that negates the sense of the bracket expression.

something that looks like this. Not ABC. Is that going to do something? Yes. Star, right? And what that did is it says, I want every sort of file name in this directory that doesn't begin with A or B or C or dot. And that's that list of file names there. Yes?

echo dot star. Oh, if I said echo space dot space star? Yeah, that's different from echo dot star. Dot star says match all file names in this directory that begin with dot. Whereas if I say echo dot star, the dot and the star are treated separately, right? Oh, yes. So, for example, we can say, I don't know, No. Echo boof star. That matches boof. So star matches zero characters. Correct. Oh yeah. Yeah. You can say echo star b. And it still just matches boof. Yes.

So if the pattern has a slash in it, that's going to match a directory boundary. Or you know, you'll have to set a, like if you have a pattern, you're running along the pattern, you see a slash in it. That means everything in front of the slash has to match a directory. Right? Because that's the only way that slash is going to match anything. It has to match sort of, you know, I'm at a directory and I'm about to go into a subdirectory. Alright. Other, well, let's see.

Let's try a more interesting one here. We can do something like this. Echo user. So what this pattern did is it looked under /usr. It looked for all file names under that. But then it made sure that the file names named directories. So it won't list anything under user that's a regular file. It'll only list the directories because there's a trailing slash on the pattern. Other comments on Yes?

There's no other way to search for something that's in a different level of a directory.

Well, you, right, so what do we have, the du command gives me the directory structure here. So I could say echo, you know, stars, star diff, star, right? And that will look for every diff in a subdirectory from where I am.

But it has to be an immediate subdirectory, right? I'll get a different answer if I do something that looks like this. Star, star, star diff. Now we get the diff files that are two levels down from where I am. But the pattern has to tell you exactly how many levels to go. Question? Can we combine the square brackets with a star for a square?

bracket, it loses its special meaning, it stands just for itself. Other questions? Yes? Oh yeah, that'll work. Echo dot dot slash star. And that will list all of the sibling directories of this directory, including this directory.

Why is which? Why is dot dot slash sibling? Is it dot dot like parent directory? No, sibling, not symbolic link. Sibling means that these directories or files share our parent. Yes. Yes. Would this also list which? The directory that we're currently in. Yes, because if you go to dot dot, that's our parent directory and then star will match the name of our directory. Correct. Other questions on globbing? One more. Yes. A slash after a file name means that file had better be a directory otherwise you're naming something that doesn't exist.

That's what the slash really means. Right? So for example, one of our siblings is HTML grammar dot text, right? So if I say, I don't know, LS minus L dot dot slash HTML grammar text, but I put a slash here, it'll say, that's not a directory. You can't fool me. Yes? Why is it called blogging?

Because the original function that implemented this was called glob. And I don't know why they called it glob. They liked short names back then. All right. Other comments? Okay. All right. So that's one thing I missed last time. Another thing I missed last time was when I told you about IO redirection, like this funny thing here, which means I think file descriptor 2 the same thing that file descriptor 1 currently points at, I didn't mention a couple of things and I'll mention them now. First off, there's this funny notation. You can put any command you like here. What this means is take all this text in here and treat that as the standard input for the This thing is called a here document. It's a little funky, but it's almost like saying this. Echo and then all this funny stuff, which may be in multiple lines, and then pipe that into the command. It's just that this may be more syntactically convenient than this. Okay? And if you like, you can also, you know, put a thread in there.

3 in front of here, which means that it's now on file descriptor 3 rather than file descriptor 1. There's another syntax that's a little less commonly used, which is this one. Greater than, greater than means append to the output file rather than destroying its contents and starting afresh.

Of course you can do something like this as well. This means take standard error and append that to the file rather than recreating the file from scratch. There's even a fancier version which you'll hardly ever see. But I'm mentioning it because I want to do everything. This says open this file for both reading and writing.

and you can write to it. Okay? And make it file descriptor 3 and it's up to command to decide whether to do a read or write or it can do both. It can read for a while and then write for a while. It can do whatever it likes. You don't see this one used very often but there it is. Question? Which one? Oh, this means, you know, standard files internally in a program are numbered.

By convention, we have the input channel, standard in, the output channel, standard out, and the error channel are zero, one, and two. But the list goes on. And sometimes you want to be able to have more than just the three standard ones, and the shell will let you do that. But you stick a digit immediately in front of the I/O redirection operator. No space is allowed here. And then you're talking about that file descriptor rather than zero, one, or two. Yes?

less than less than like this means the shell will read up to a line containing the token after the less than less than. Take all the stuff that's in here and say okay I'll make that standard input to this command. And you can in here put ordinary text like this you know and you can put variables like I don't know This will interpret the value of the shell variable V as far as the text goes. So it's a fairly flexible kind of thing you can do. Other questions about aisle redirection? A couple other things. I mentioned programs can exit.

that will let you exit the shell. And not surprisingly it's called exit. Alright? When that happens the shell immediately terminates. Anything else that you were going to do it's not going to do that anymore. If you've run some processes in the background they're still running. This only causes the shell itself to exit. But there's something else you can do with exit. You can put a number after it. This says exit with with status one. By default, the exit command, if you don't give any argument to it, acts as if you did this. And if you'll recall from last time, this means the exit status of the most recently exited, executed command. Right? So by default, if you just exit, after a failing command, your shell will, command will fail. And if you exit after a successful command, then your shell script will succeed.

There's another command that's sort of like exit, but not the same thing. It's the return command. The return command acts like exit, except it only affects functions. In shell you can define a function that looks like this. Let's say I'm tired of typing cat all the time. I just want to type C.

I can well in fact with me it's a rep I just want to type G for grep all right you can say something like this this tells the shell here's a shell function okay you never have to give any arguments here and if you want to refer to any arguments you do it this way. So dollar sign one here inside the contents of the shell function refers to the first argument of the shell function. And once I've entered this into the shell later on I can just type GAB right and that's equivalent to running grep AB and it returns with the same exit status that grep returns. This is such a common pattern that you don't need to say this by default returns with the exit status of the most recent command and you don't even need to do this. By default if you fall off the end of a function then it returns with whatever the most recent exit status was. So there's kind of two different ways to implement functions or function like things in the shell. If I want to implement G as a shorthand for grep, here's one way.

Type this into the shell or put it into your.profile file, which gets read when you logged in so it's available at any point. You can put this into it. Another option is to create a shell script that looks like this. By convention, the first line of the shell script is a comment that has to begin with exclamation point. I'm sorry, sharp sign, exclamation point, and then the name of your shell.

and then here you can say grep $at. Put this into say squiggle egart bin g. So we have a file, it'll be a shell script whose contents are the same as the contents of the function. Make sure that this is in your path.

"path" equals "home bin path". By convention, the path variable in the environment specifies the list of directories that the shell will search for when you type a command that doesn't have a slash in its name. And then, once we've done this, then we have a shell command that will operate like the function.

You can have a function, you can have a shell script. Why are there two? Shouldn't there just be one mechanism here? Is there an advantage of doing it one way versus the other way? Any thoughts? Right? This is a question of why. Why are things the way they are? Which you should be constantly asking yourself after I tell you anything in this class.

Not just what, but why. Why do they have two different things like that? Yes? Yeah, these things are more global, right? These are visible to all programs. Any program, doesn't have to be the shell, can be Emacs, can be anybody else, can run a command called G, and it will work here.

Here, this shell function is only visible to the shell that you're running that shell function in. It's not visible to anybody else. Emacs won't know about it. Python won't know about it. Nobody else will know about it. So in some sense, these are heavier weight way of packaging up functionality. This is a lighter weight of doing it. Conversely, this is almost surely going to be more efficient than this. When you start up a shell script, That basically invokes a whole new shell process. The shell has to wake up and initialize itself and all that sort of thing and that's going to take a while. Whereas when you execute a shell function, your shell has already started up and it can immediately start doing whatever is in the function. So to some extent, shell functions are best used for fairly lightweight things and calling grep is not that lightweight. This might be a better way of doing it. You could do it. This one is a wobbler.

But generally speaking, once things get complicated enough and you want to export them to the rest of the world, you want to do it this way. This is for the simple stuff that you want to be fast and shell only. Question? Oh, good point! There's also an alias command. I don't like to talk about that. You can do this, which is roughly equivalent to this.

But the alias command is really only good for really, really simple things. I want a different name for an existing command. Whereas here, you can put whatever you like in here. You can put a whole bunch of junk in here. And so I tend to prefer this approach to this. But this is simple. What can I say? Aliases were added when people were a little dubious about shell functions. But now we're not so dubious. Question? Yes, it's lighter weight.

How does the compute like heaviness of grep affect how? Oh, the point is if grep is expensive, relatively expensive, then why bother to optimize G? Because you're about to call this slow thing anyway. You might as well use something slow. It's sort of like, you know, Python is so slow that who cares if you do some order n squared algorithm versus order n for anything small. It doesn't matter, right? Same general And you know, the shell is pretty slow. So don't worry about super optimization with it. Generally. Sometimes you need to, but there's less of a pressure of optimization once you're in scripting compared to when you're in the C++ world or the Java world, that sort of thing. Other comments about shell functions versus scripts? Okay. Well, that means we get to talk about regular expressions. Excellent.

And part of what's going on here with regular expressions is that computer scientists by and large, software developers, you know, people like me, tend to be an unruly bunch. We don't like to do things the way that mathematicians did them or other people. We like to reinvent the wheel from scratch because, hey, that's part of the fun of this field. You can build stuff any way you like.

So one of the lessons you're going to get about regular expressions in this lecture is that there are multiple sort of syntaxes for regular expressions. We'll learn at least two, maybe more if you like. And the reason for that is that the computer scientists who implemented them in the first place didn't get along or didn't entirely agree with each other. That's probably a better way of putting it. So we have multiple notations for the same idea. And that can cause trouble. Because you can get confused. You think you're using one notation, you're really using the other. You're going to have to be careful about this in the real world. grep uses two kinds of notations, actually three. Python uses a fourth. You know, JavaScript uses a fifth. They all sort of disagree with each other, but you need to learn the notation that you're using and you also need to know the general principles of regular expressions which you can apply to any of these notations. All right, so what's going on here is also sort of a design philosophy that sometimes works pretty well and sometimes doesn't. It's the design philosophy called little languages.

This arose in rebellion to fairly complicated languages like C++, for example.

How many people in this room know C++?

And if you raise your hand, you're not entirely telling the truth, right?

Notice I didn't raise mine. Part of that is because I last used it in 1993 and I swore I'd never use it again. But part of it is because it's a really complicated language. It's hard to learn it all and there are corners that trap even the most, you know, experienced C++ programmers. So in rebellion against that, there's a different philosophy which is to say for every well-defined problem you have in software development, define a language sort of tuned for that problem that will help you solve that kind of problem really efficiently and easily and you'll understand it. And it's not general purpose but that's fine. And that way you can be like, you can know everything about the language. You know exactly how it works. You can be just as expert in it as a Turing Award winner and you can solve problems just as well as they can in that relatively small domain. So we've already seen one example of of that, right, which is the shell itself. It's quite a simple language compared to C++, right? Granted, I've been talking about it for two lectures, but to learn C++, it takes you, what, 20 lectures? And even then, you only know about a quarter of the language, right? Here, we've covered the whole shell. There's an even simpler language that I'm about to talk about, which is the ERE language.

ERE is short for extended regular expressions.

The shell doesn't know this language, but GREP does.

And so we'll be looking at how GREP works and taking its argument as an ERE.

The way you invoke grep with an extended regular expression is with grep minus e and then a pattern where this thing is going to be an ere. If you don't use the minus e option grep uses a different language for the pattern. We'll talk about that language later. I'm using ere's because in the original design sort of bake-off between regular expression the one team won, they got to be the default. I always like to root for the underdog. So I'm rooting for the E team as opposed to the B team. We'll talk about the B team later. So here are the elements of EREs. First off, here we have a pattern and here we have what it matches.

and the simplest pattern is going to be an ordinary character.

C, right? And it matches itself. So unless otherwise specified in an ERE, if I just write down any character, it's going to match just that character and nothing else, right? So if we have a pattern that looks like this, it only matches six character strings that have my last name and lowercase in it.

I guess I've used two patterns here. Second kind of pattern is the pattern PQ, where P is a pattern and Q is a pattern. What does that match? That matches anything that P matches followed by anything that Q matches. So it matches the concatenation.

of strings matched by P and Q. Respective. So in some sense, I've used that here. I've used that row one, two, three, four, five times. Alright. Next one is dot. Dot is a pattern that matches any single character other than new line, right?

All right.

Now, let's say you have a pattern P and you put a star after.

You probably know what that matches, right?

That matches zero or more occurrences of P.

Right, it matches the empty string, it matches any string that P matches, or it matches the same thing that P matches, that sort of thing. P question mark matches zero or one occurrences.

of P. You can think of it saying is an optional P. And P plus is equivalent to P P star. So we have a little language here for building up patterns. And now you can see what this this pattern will match. It'll match either Eggert or Eggert without the T. And then if we change this G to a star, it'll match Eggert. We'll also match E with no G in it, right? And no T in it, right? At each point here, we have an option, and this thing matches a whole bunch of strings. Question?

He's pretty good. Yeah, he may be one of the 27 people on the planet that knows C++. All right. Although, you know, part of the problem there is that it's mutating as we speak. They keep changing C++. And so, you know, he has to keep up to date with that sort of thing. By the way, how do you guys keep track of the C++?

C++ changes? You don't? Hey, this, you know, one of the things about UCLA is you guys are supposed to be really good at lifelong learning. The dean keeps telling me about lifelong learning. And what that means is the half-life of the stuff we teach you is seven years or ten years or some small number. So if you take careful notes of everything I say in this lecture and come back in ten years, only half of them will be useful. The other half will be correct but not all that useful. Actually you might think that now but let's ignore that. So this field is mutating rapidly. If you want to sort of have a career in which you do C++ stuff, you're going to have to keep up to date. There's a C++ 17, a C++ 20, a C++ 23, there will be a C++ 20 something and a 30 and so forth and so on.

If you don't keep up, that means you don't care and you won't be working in that area, right? Sorry. To some extent, the shell stuff here is actually better for you because it evolves much more slowly. It's more standardized. The standardization body is slower moving and there's less need to sort of improve on it like there is with C++. Anyhow, where were we? Oh, patterns, yes. Let's do some more patterns.

If you have a pattern and you immediately follow it with a number in curly braces like that, no space is allowed anywhere here. It has to be immediately followed by. It's the same as that pattern that many times. And you can give a range.

That matches either P or P followed by P or P followed by P followed by P. That matches anything that those three patterns will match. I almost left off in some sense the most important operator. This means or and it matches anything that either P matches or Q matches. This is the disjunction operator.

This is a very powerful operator and in some sense you can do so much with it that, for example, this thing is equivalent to saying P or PP or PPP. We're using the disjunction operator here to say what that more compact notation stands for. You can also say this.

That matches anything that p matches. Why do we need parentheses? Because we have a whole bunch of operators here and we have to worry about precedents and that sort of thing. These operators have very high precedents. So if you write something that looks like this, this means a single instance of p followed by zero more instances of q. If you want to do it the other way, you write it like this.

This means zero or more instances of an instance of P followed by an instance of Q. Both of these make sense. You might want to write it this way or this way, but they mean different things. And that's why you need parentheses as part of your notation. Yes? So let's suppose P is the regular expression, I don't know, A.

and Q is the regular expression BC, like that. Then this thing is going to be ABC star, which means I'll match A or ABC or ABCBC, oops, or and so forth and so on. Whereas this thing, which is ABC star, says I'll match zero more instances of this, which means I'll match the empty string. I'll write that this way. That means there's nothing there. Or I'll match ABC or I'll match ABC, ABC and so forth. Yes? Because pattern star says I'll match zero or more instances of the pattern. Zero is allowed. And that if you have no If you have instances of the pattern, that means you have the empty string. Yes? This one here versus this one here. Right? So, well, we'll take our same P and Q here. Right? And let's take a look at the difference between PQ, which is this, and P or Q, which is this.

This matches only this string. It won't match anything else. That's the only option. This will match either A or the string BC. So disjunction, you take just one of these patterns and use them, whereas concatenation, you have to take both of them and they have to appear in order. Question?

P? is sort of equivalent to this, P or nothing. Although, strictly speaking, this isn't valid. We're not allowed to have empty regular expressions, so I'm doing some hand-waving here. P? and what? P plus. Oh, P plus is equivalent to either P or PP or PPP, as many P's as you like, right? So it's equivalent to at least one P and then zero more P's after that. Star binds more tightly than concatenation, so this star applies only to the preceding P. Question? Is the which operator? The or operator can apply to as many things as you like. For example, you can write A star B or B star A.

Yeah, the OR operator has lower priority than concatenation or star or plus or those sorts of things. Question? Yes, you can say A star star, although there's not much point to saying it just like this because that's equivalent to saying A star. These two patterns match the same thing. You are not allowed for reasons that escape me.

to say this. It's not allowed in the syntax, but I don't know why they do that. I think NuGREP allows it anyway, but other questions? Yes? Oh, well, I'm talking about, that's a good point here. Quotation. The way you quote things in regular expressions is like this. Where this X, has to be a special character, right? The special characters are kind of fairly obvious from the list. I think I have a list of special characters here. Here's the special characters in EREs. Specials. Dot question mark.

plus open curly brace, vertical bar, close curly brace. Oh, close curly brace is not special. Oh, that's very interesting. Open paren, close paren, open square bracket, close square bracket, backslash, and we have a caret and dollar sign. Well, I haven't gotten to those yet. All right.

So if you want to quote something that's special, just put a backslash in front of it. Backslash is a special character, so if you want to match a backslash, you better have two backslashes. Notice that here we're talking about quoting for regular expressions. Suppose I run this shell command.

What does that mean? First, the shell says, "Oh, that's a double quoted string." Backslashes are special in double quoted strings. They quote the next character. So what the shell will do is it'll pass this pattern to grep. This is what grep will see. And what will grep do with the two backslashes? It'll say, "Oh, that's this pattern." So that grep command will search for a single backslash.

And this kind of thing is pretty common once you deal with quoting issues. I've seen eight backslashes in a row. Or 16. Once you get that many, you try to do something else. All right? Question mark. If I wanted a quote, if I wanted to grab for quotation mark. Oh. It still means the same thing in this particular sentence.

particular case, right? I mean, the fact that it was quoted doesn't change the way that it works. But, you know, if you had a pattern that looked like this, then you're going to need to have the double quotes because this space would otherwise turn into, you know, a new word. Question? Can you go over again for this P curly bracket one comment screen, like in fact, not getting the word? That means one through three repetitions of P. So it's equivalent to this.

And you can specify any integers you like here as long as the first one is less than or equal to the second one and they have to be literal decimal integers. You can't put expressions here. Well, no. If you say something like this, that's a syntax error. Well, you could say something like PQ13, right?

Yeah.

Okay, question.

Yeah, what this means is the shell sees these two backslashes and say, oh, well, I'll just turn that into one.

So it passes a string that looks like this.

backslash space A star B. Strictly speaking, that's an error because you're only allowed in portable scripts to put backslash in front of special characters. However, grep, when it sees that thing, at least GNU grep says, oh, that just means space. So it's equivalent to just saying space A star B, right? So you could instead have just written this.

And with GNUGREP, you'll get the same. This is supposed to be a single space. Other questions about these special characters? Yes. Louder, please. Oh, forward slash? Oh, so if we say GREP minus e this. Like that. Which means we're giving that regular expression to grep. That's a syntax error in regular expressions. We can check that by doing this, right? And it'll say, you've got a trailing backslash in your regular expression. You probably didn't mean that. Question?

Yes? Why is two backslashes passed into a grep instead of a grep? Oh, because if you write something that looks like this, the shell says, oh, this stands for a backslash. I have an escaped backslash. What's this? Oh, it's another escaped backslash. So it will pass two backslashes to grep. All right. One more question, then we'll take a break. Yes?

Why doesn't the double backslash work here? It's independent of the quotes. You'll get the same result without the quotes. Either way, this means just give grep a single backslash, and a single backslash is an invalid regular expression. You have to have something after the backslash, and it has to be a special character for it to be valid. All right, let's take a break. We'll start up again at 5 o'clock.

And the most complicated pattern in an ERE is called a bracket expression. And I've already covered it to some extent because globbing has bracket expressions too. And to some extent all I'm going to do here is tell you more gory details about them. And as usual you should be thinking why?

Why is the expression so complicated? See if you can come up with an answer for that. So the first one is something like this. You just put any set of characters that you like inside a bracket expression and it matches any one of those characters. So in some sense it's just equivalent to notation we've already seen. It's just that it's more compact. Also it's probably going to be implemented faster. It depends on the on the regular expression engine, but typically the thing on the left will run faster than the thing on the right. You can also use ranges. You can say something that looks like this. That means any lowercase letter except b, because we left b out of the list. You can also negate the sense of the set of characters by using a caret, not exclamation points. That's the globbing notation.

but caret because the two teams couldn't agree. And this basically negates whatever set of characters you put in here. This matches any single character that's not in that set. Now, that raises the issue. Suppose you want to have a character set that includes the caret. In that case, don't put the caret first.

So you can write something that looks like this. That matches any lowercase letter or a caret, a circumflex, right? Whatever you want to call that. Just don't put it first and it doesn't have any special meaning here. You can also do something that looks like this.

Let's do a couple more. In your set of characters, you can put all sorts of funny characters that you like, but if you put something that looks like this into the set, open square bracket colon followed by a name that is typically five letters long, then as long as this name is one of a small set of names that includes alpha digit al num which is short for alphanumeric that is either letter or digit print a few other characters like that then this stands for the set of all alphanumeric characters plus these other four characters here. So you can use that to write something that more convenient than actually spelling out all the alphanumeric characters. If your grep is suitably configured this will match alphanumeric characters in any language not just English. All right so it can be quite a large set you couldn't have possibly have written it down in a very compact way. All right so let's see question.

That's right. So backslash just stands for itself here. It's not special. Star? All those funny characters, they just stand for themselves. Vertical bar just inside a bracket expression is just another character. However, we have some weird special cases here. And it's a little complicated. Sorry about that, but there it is, right? So the special characters inside a bracket expression are this one, and this one, because that means something different than an ordinary character, and this one, because that ends the bracket expression. So how do we mention these characters as is inside a bracket expression? You can't fix that by sticking a backslash in front of them because backslash is not special inside a bracket expression. The way you do it is as follows, right? If you want to put this in a bracket expression, put it at the end. If it's at the end of the brackets expression, just before the closing square bracket, that means it's not part of a range expression anymore. So stick it there. If you want this to not be special, to just stand for closing square bracket, put it at the start. After any sort of circumflex that means negation. So, for example, this bracket expression. Oh, I like that one. Oh, isn't that a cool bracket expression? Because this is a bracket expression that matches either closing bracket, because it's the start, that means it's not ending the bracket expression, or it matches This is opening square bracket. This is a bracket expression that will match either an opening square bracket or a closing square bracket. Also, further illustration, if I write this, this matches any single character that is not a square bracket. And then, okay, what about this guy? Suppose we want this one to appear literally in a bracket expression.

Put it anywhere but at the start. And you're off to the races. It will be just treated as ordinary. Question? Because the rule is that a closing square bracket is not special if it's at the start of the contents of a bracket expression. So this is not It's just an ordinary character. Yes? Oh, opening square bracket, notice it's not special inside a bracket expression. It's just an ordinary character. So this is just an ordinary character. This means negation. This means just an ordinary character because it's at the start of the regular expression.

after an optional negation. Now, part of what's going on here is I'm giving you these fairly arcane rules that, to be honest, a lot of grep users don't know about. But what the reason I'm doing this arcaneness is to sort of expose you to how complicated things can get once you start doing quoting in arbitrary regular expression or similar notations, right? The reason for all these weird rules is they wanted to be able to let you put backslashes in here without thinking about it and that forced them to have all these kind of weird special rules for everything else. Right? So for example, what does this regular expression mean? I'll make it a little easier.

All right, this means A through B and C through Z. This means A through minus sign. This means A through minus sign and then minus sign through Z. All right, what does this one mean?

from Z through A but Z comes after A. What's going on there? Right? This turns out to be have sort of undefined or this is sort of don't do this. How shall I say that? Some greps treat it as if you had typed A through Z. Others treat this as a pattern that doesn't match anything. Yes? Yeah, I'm assuming ASCII here. Things get more complicated and if you're not Yes, good I, right? You have a similar problem here. This can't possibly make any sense. All right, and by the way, you could try this stuff out. Just log into CSNet, run grep, see what happens. Yes? Either carrot or hyphen. Well, obviously this is wrong, right? Because this means anything but hyphen.

So how about doing it this way? Yes, a hyphen at the very start of a regular expression stands for itself, always, because it can't possibly be part of a range. And I guess I didn't list that over there, but that's an extra, extra special rule. Good eye. Yes? So the first example that you gave with the three hyphens or minuses, that'd be the same as the higher example one? I believe so.

All right, question.

This matches any of these three characters because this carrot is not special.

You could do it this way too or you could do it this way. They all mean the same thing.

Question in back.

Match a character starting where? Match characters and select characters not match. You want to have a set of characters but you want to remove some entries from the set? Match A but don't match C? Well, this matches A and it doesn't match C. I don't need bracket expressions for that.

Within a bracket, it's either a positive expression like this, you list all the characters you want, or it's a negative expression. You list all the characters you don't want. You cannot do sort of a union of this with that intersection. It's just positive and negative examples, that's it. Yes? Oh my. This is not well defined, but I think Grep just treats it like this, because it sort of gives up. Yeah. All right. Question. I believe this matches everything from A through minus sign and then Z. But it turns out that minus sign occurs before A, so this is bogus. No, it's an error. It's just like this thing will be an error, at least in the greps that are picky. I hope. Now you've got me wondering.

All right, so minus E and then we do what was it? A minus minus Z? Yes, it treated this as being A through minus which is invalid because minus occurs before A. Once it's an invalid regular expression it gives up, it doesn't try anything else. Yes?

Right after an opening square bracket is when it's special.

And it's only in that position?

In bracket expressions.

Okay.

We have another meaning for caret.

We haven't got to yet.

Yes?

Why don't you do single quotes around the brackets?

Up here?

Yeah.

Because I didn't want globbing.

If I'd left off those single quotes, the shell has its own meaning for bracket expressions because of globbing. I already told you about that. And I didn't want the shell to try to match this pattern against file names in the current directory. I wanted this pattern to be given directly to grep. Generally speaking, if you do anything unusual with a pattern, quote it in the shell before you pass it to grep. Otherwise, it's going to do globbing and you don't want to do globbing. All right. So what else do we have? Oh, we have two more of patterns and I apologize because it's sort of well all right here we go this extended regular expression matches P followed by the end of line and in fact you don't even need the P I should say that this is good enough and this caret or circumflex by itself, not inside square brackets. Different meaning in square brackets. This matches the start of the line. Ordinarily, GREP looks for any occurrence of the pattern in the input line. It doesn't have to start at the start of the line. It can be anywhere in the line. But if you anchor it, these things are called anchors, with start of line or end of line, then it will only match the pattern if it appears at the start of the line or at the end of the line. So if we say something like this, It's going to find every line in et cetera password that has an e in it and there's a ton of it. Whereas if we do this, and I suppose I should be using a capital E here, it'll only give us the lines that start with an e. All right? So, let's see if we can do a quick Quick quiz based on this. Suppose I write this pattern. What does that do? That matches any line that has the characters x, then y, then z, then the start of the line. Which means it cannot possibly match This is a pattern that will always fail to match no matter what. In some sense it's the first pattern I've shown you that do that. In general this pattern and this pattern never match anything. So for example if you want to build up a pattern that is a bunch of, how shall I say it, you want to say this pattern or this pattern or that sort of thing you can write a little loop that looks like this. In the shell, you can say, "I'm going to start off with P equals this." And then you can say, "For IN dot star do P equals $P vertical bar $I done." As a result, P will be all of the arguments, well we should make this.at, right? All of the arguments to the current shell script separated by vertical bar and at the start we'll have a pattern that doesn't match anything so it won't contribute anything to the overall pattern. And then when we're done we can say grep minus E dollar P.

and we'll get the sort of the meaning that we want. Right? Because we start off with a pattern that doesn't match anything at all, which is the identity element for disjunction. All right. Any questions about all these patterns? All right. So I said there was multiple syntaxes. So I now want to talk about basic regular expressions, BRU.

When you just say grep and don't give any flags, you're just writing some pattern here, you're using the BRE syntax rather than the ERE syntax. For technical reasons, the BRE syntax tends to run a little bit faster than the ERE syntax, which is why they made it the default back in the 1970s.

All right, and BREs are like EREs.

Except the following characters are no longer special.

All right, so you lose a lot of the special characters that you had with EREs.

That's part of the reason BREs are faster.

they don't have to implement as much. However, you do get substitutes to get some of it back. All right? So you do get parentheses. You do get repetitions. The big thing that you lose to my mind is OR. You don't have OR. You don't have these either, but the OR is sort of like the big deal.

are going to be more efficient. But there's one other thing you do get, which in my mind is a mistake, but I'm teaching you this system warts and all. You get these patterns. And what these patterns do is they let you match a string that you've already matched. It works like this.

If I white grep, let's try backslash open paren a b star, right? Backslash closing paren x y z backslash one. Backslash one says please match whatever the first parenthesized sub-expression matched. Don't match anything else, just match that. So, you know, if we put a caret at the start here and a dollar sign at the end, then something like this, ABBB XYZ ABBB, that'll match. Because this guy matches this substring, we match the XYZ, backslash one matches exactly what the first guy matched.

will not match. Why not? Because all these guys matched. The first parenthesized sub-expression matches this. But this guy isn't right. Backslash one says I have to match exactly the same string that this guy matched. This notation is called a back reference.

And I should warn you that it's the one part of VREs that's slow. It's really slow. You don't want to be doing back references if you can help it for various technical reasons that once you take the theory class you'll see immediately why it has to be slow. Any questions about VREs? Yes? This one? Right. So basically backslash one means find the first parenthesized sub-expression in this regular expression. Okay? And whatever that matched in the target string, match it again. You have to see another occurrence of whatever this guy matched here. All right? So, for example, we can try to match palindromes. Like this.

What does this do? It matches a single character dot, another single character, another dot, another single character, another dot, and then it has to match whatever this guy matched, and then whatever this guy matched. So it will match this.

And it won't match this. Right? Because the D is not the same as the C. Question? It's a back reference, right? The syntax is a backslash followed by a digit. It has to occur later in the regular expression after we have, you know, a parenthesized sub-expression.

matches the nth sub-expression that you wrote. So if I were to write backslash 2 here, that's an error. Because there's only one parenthesized sub-expression here. There's not two, so grep will yell at you saying, "What's this 2 doing here?" However, if I do something like this, then this has to match a y. Other questions about back references? Yes?

Over here? Why do I need backslashes here? Oh, because these are BREs. Right? In BREs, parentheses are no longer special. However, you have substitutes for them, backslash paren. So I had to put backslash in front of those paren to have them mean. Please parenthesize this sub-expression. Question? How do I escape from what?

you say escape from you mean I have I want to match a backslash followed by a one oh well you just put two backslashes right this means match a backslash then match a one other question yes curly brace any areas right okay other comments questions right to some extent I've gone off the deep end but that's all right yes If I wanted to match a square bracket, I would do it this way, right? I mean, you could do it this way. These two regular expressions are equivalent, but most people would probably write it that way. Question? Yes, a nine-year-old.

is too many. If you ask me, the limit should be zero. All right? But, you know, what can I say? I see people using this feature all the time, especially in like Python and Perl and that sort of thing. Not so often in grep. Because the people who use grep, they care about performance. The people who use Python don't. Right? And so they're happy to use these things. Yes? What happens if you don't have like the care and the dot and it just starts to fly? Oh, if you do it this way, This will match any palindrome of length 6 anywhere in the line. If you put it this way, the entire line has to consist of that palindrome with no extra characters before or after. Other comments? Grep has a minus v option. Minus v says print out all the lines that don't match. So what's the difference between this and this? All right. This should be something that you practice on till you get it right away. It should not take you five minutes to figure this out.

3 seconds. Once you get used to regular expressions, you'll immediately see why these two commands are not the same thing. All right. Well, let's see what else have we got. Any questions on all this stuff? I've gone through it in more detail than I will go through any other topic in this course. Right? And I'm doing it partly to tell you about quoting and interactions of features and all that sort of thing. But I really want you to see all the screaming details of this thing. All right. We have a little bit of extra time, so let's talk about Emacs. That was the other thing I wanted to mention. You've already done a bunch of Emacs. So I feel like I don't have to tell you much. You've used it. You've probably sworn at it. You're saying, why does it have all these funny keystrokes and all this other stuff?

stuff, right? Why can't I just, you know, talk to it or something like that? And actually, I once had a coworker who used voice input to control Emacs instead of the keyboard. He had good reason because he was a polio victim. And what he found was that in order to do stuff, his voice would get strained, right? So yes, you can You can control a text editor like this with voice input, but it's going to be inefficient and you're going to wear out your voice. You can also control it with a mouse or trackpad and do clicks and clicks like most people develop software, but you will find again you are less efficient than if you can keep your fingers on the keyboard and just type away madly. I'm afraid that's just how things have been historically. Now perhaps We'll have generative AI bots that can do voice input better than traditional voice input in a few years, but we're not there yet. So to some extent, when I show you these keystrokes and all this sort of thing, it's not about knowing those particular keystrokes. It's about whatever development environment you use, learn to use it effectively. And often that means don't take your hands off the keyboard.

Some people are very dogmatic about this. Bill Gates famously told his developers, "If I can't control Visual Studio just from the keyboard, you're fired." So they did. And you can run Visual Studio just from the keyboard. You don't need a mouse. Mouses are for WIMPs or mice are for WIMPs. All right? So let's talk about some of the keystrokes here. All right? First off, we have I think I've mentioned this but we'll start over again. You have control at sign. That's actually the null byte. And this says mark where you are. Place the mark. So if I type say I'll go up to here. Oh how did I do that? I typed control P and control N for a previous line.

You can use the arrow key for this stuff, but on many keyboards the arrow key is kind of out of the way and control P is faster to type. So I usually type control P. So I can type control at sign here, which is a null byte, go up here and notice what it's doing. Oh, you can't see what it's doing. What it's doing is it's highlighting the region between mark and point.

So point is where the cursor is. It's the current location. And probably the best way of thinking of point is that it's a location in your current buffer that's between two characters. Similarly for mark. Mark is between two characters as well. Typically you'll see something that looks like this.

and there'll be either a cursor that looks like this or maybe a cursor that looks like this. But the real thing here is that point is sitting between those two characters. And when you type control at sign it says set mark equal to point. Now you can then move around. And then you can type meta w.

which means copy. Everything that's between point and mark. If point is before mark, then you copy everything from point up to mark and/or vice versa. Question? Yes. Control, add, and control space. If you look at the ASCII characters, they end up being the same character. Yes?

Yes, and there will be times that say a mouse would be faster, okay? But there will also be times when just using the cursor motions and faster. What I find is often something like this. Say I'm here, and I want to go up to the previous command. So I'll do control R, dollar sign, space, right? And then up to here. Now, if you type control X, to control X, oh that means exchange point and mark. Let's do that, right? You can use that to easily see sort of the region of characters you've just identified even if the display is screwed up, which it often is if you're SSH'd into some other server. And then I can type meta W, right? And what I've done is I've saved all that region between and mark into a temporary area. I can then go into the other buffer, control x for b xxx. Let's write that one down. Control x for b. That means switch to buffer in other window. And I can now type control which is short for yank which basically says take that string that I've just saved and copy it into here. You can do all this with a mouse but it's going to be faster if you do it with a keyboard once you get used to it. And there are a lot of sort of commands in Emacs that basically say glop this text and then plop this text over there and I find myself typing control y a lot. Now, There's not just one sort of place this stuff gets copied. There is an area called the kill rig. Originally named because what people would typically do is type control W, which means cut instead of copy. In Emacs, that's called kill. That means you're taking a blob of text and removing it from wherever it is.

and then yank basically says take the thing that's at the start of the kill ring and place it here. But there's a good chance that you don't want to yank the most recent thing that you cut. You want the second most recent thing. After you've done ctrl y, you can say no I don't like that and you can type meta y which means yank the next thing.

It's called a kill ring because if you keep yanking and yanking and yanking eventually you get back to the thing that you yanked in the first place. So it's a ring of text that you can use as sort of a source of temporaries for cutting and pasting from one spot into another. Any questions on this part of Emacs? Yes?

If you type control at sign twice, you deactivate the mark. And by the way, it's funny how this works, and you'll see this happen to you too if you ever use an IDE often enough. I can't remember the explicit keystrokes anymore. The only way I can remember is go to the keyboard and do it, and then I look at my fingers and they will tell me what characters that I'm typing. Once you get good at this sort of thing, it will be hardwired into your lower part of your limbic system. You won't have to actually use conscious thought. Yes? Yeah, you type meta Y, meta Y several times. Okay, any questions about these commands? All right, let's try a couple more. If you want to find out about any of these commands, you type control H and I will type control h k control y. So control h is our general purpose help sort of key. And control h k and then any key sequence will tell you what that key sequence will do. In this case it says oh that's going to run the yank command and here's all those sort of internal details about how it's implemented and we can go look at the source code if we want to but today we don't want to. So that's one way to find out what keystrokes will do. But to some extent I use this mostly when I've done the following. I type some keystrokes by accident that I didn't mean to and they do something and I say what did I just do? Well I can use control hk to figure out what in the world I just did by mistake. More helpful is, at least often, is sometimes something like this. Control H M. This tells you about your current mode. Emacs is a modeful editor. That means the way that it reacts to the characters that you type or the mouse motions that you make or the clicks that you make, all that stuff. The way that it reacts depends on the buffer that you're currently talked to. Each buffer can react differently to whatever characters that you type. If you're typing into an ordinary buffer and you type the character X, you'll see an X on the screen. But if you're typing into a directory buffer and you type an X, that means please execute all the commands that I intended to execute for this directory.

how your current mode behaves, type this. It will give you a high level description of what it does. We're in fundamental mode, which is the simplest mode there is. That's why it's called fundamental. And it'll also tell you about minor modes, which are sort of, you can think of them as being like mix-ins. They're extra features that we've added to fundamental mode. And this will tell you how it works. So if I type, say, control X D and get a listing of the current directory, and then type control h m. It will say, oh, we're in Dured by name mode, which means I'm editing a directory via its names. And here are some of the commands that you can run. We can go over to this other buffer. Oh, control x o does that. Switch to other buffer.

and then we can type control V and meta V to go up and down because page up and page down are for WIMPs and we can then find out all the sort of commands that you can do and it'll give you a brief summary of that mode and that sort of thing. I'm not expecting you to memorize how Dured mode works but I do want you to know how to find out about it and how to get started with it and this is a little bit of that.

What else have we got? Control H I. This is designed to give you information about not only Emacs, but the other programs in your system. You can think of this as being an alternative to man pages. And if you log into CSTAT, you will see that there's a whole bunch of programs that you can run and they're For example, we'll just go to core utils down here, we'll type enter, and here's the all of the documentation for core utils. Now you can get this stuff off the net as well, but that's going to slow you down. The idea here is you want to be able to get to this stuff as fast as possible without thinking. Alright, any questions on getting help? Alright, what else can we do?

Well, we can type, I don't know, control X B, we'll go back to help, control X 3. That means split the window vertically. We can type control X 2, that means split it horizontally. What some software developers will do is they'll use Emacs to take over the whole screen. Unfortunately, we're kind of stuck with primitive display technology here, so you can't really fit much on the screen.

But once you have a big enough screen, this is your window manager. Because you're doing your development in Emacs, you don't need anything else. You can also type control X zero to make a particular sort of window go away. Right? So control X zero, one, two, three. There's, you know, all of these things basically are window control.

Control X1 means take the one that I'm currently in and have it take over the rest of the screen like that. Control X1. All right. What else can we do? Yes? Sorry, what? Oh, you type Control X and you say, oh, I didn't mean to do that, right? Control G in general says, stop what I'm doing. Get me back to the top level.

So control G means interrupt EMACS and get back to the safe mode. Yes? Does control one delete what was in the other window? No. The buffers are still there. You just don't see them. If you want to delete buffers, oh, let's do that. Control X, control B puts you in buffer editing mode. So this is like DURED mode, except here we're not actually editing files in the file system.

We're just editing emacs's own buffers which it keeps in RAM. So the changes that we make here will affect the current emacs session but they're not going to make any changes to file somewhere else. So for example here if I've got this xxx buffer and I don't need it anymore I just what do I type I thought I typed x I've forgotten right we'll go to control h m we'll say remove the current buffer from the display, delete the buffer. Ah, control K, of course. Control K, right? That marks the buffer for deletion and then X actually executes my commands. So I'm editing Emacs' buffers here. All right, other questions about these modes? All right, let's see what else have we got. Suppose we go to a buffer, X, B, X, X, X, X, X, X, a new buffer. We sort of type some stuff and we type control X, control Q. So control X, control Q means make the buffer read only or more accurately toggle read only. What that means is temporarily at least I don't want to be able to modify what's in this buffer because I'm afraid I might screw up.

If I now try to type stuff, it'll say, "I'm sorry, this buffer is read-only." You can't do that. If you want to be able to go modify it again, you type control X, control Q again, and we've sort of made it read-write and we can keep going. So you have fairly fine-grained control over what goes on into a buffer and, you know, who's allowed to modify it and all that sort of thing. Let's see what else.

There's one special buffer that I haven't really mentioned. And in fact, if we get a list of our buffers again, it's not even listed here. This buffer list, it's sort of like ls doesn't like to list file names starting with dot. This control x control b doesn't like to list buffers that are supposed to be hidden. And one of the most important buffers that's not in this list is this buffer right here.

That line is intended for you to type commands to Emacs and it's called the mini buffer and when you type something like control x control f you are now editing the mini buffer which once you're finished editing it will name the file that you're trying to open and pretty much anything you can do with an ordinary buffer you can do the mini buffer you can cut and paste you can set the mark you can do all that stuff.

You can also, in the mini-buffer, do sort of meta colon, and at this point you are now dropping into Lisp code, and you can be running Emacs Lisp code, which I will talk about next week. You can also, in the mini-buffer, I'll type control G to get out of this, type meta X, and meta X is basically a way of saying, I'd like to run a command by its name rather than running it by one of these shorthands with characters and you can type all sorts of stuff in here at this point. So for example you can type the replace string command and it will start prompting you for stuff it won't let me prompt it here because this is a read-only buffer. Another thing you can do it in the mini buffer is meta exclamation point.

is, please run this shell command and tell me what it outputs. So I will run the shell command date minus u and what it's going to output on the mini buffer by default is the current date in universal time. So this is the time in Greenwich, at least it would be if they didn't observe daylight savings time. All right. You can also do one more thing What we can do is we can do mark here and then type meta vertical bar. Where's my vertical bar? Right here. So meta vertical bar, meta exclamation point means run a shell and put the output somewhere. Meta vertical bar means also run the shell but run it with standard input being sort of the all the text between point and mark. So at this point, if I type, say, sort, it will take all the stuff that was in my buffer between point and mark, feed it to the sort command, so it's running the sort command, and then tell me what the output is, and it'll put that output in a buffer called shell command output. Right, so there's a fairly tight integration here between Emacs and the file system, and the shell. You can run Emacs under the shell. You can run the shell under Emacs. There's a lot of functionality here. Next time we'll talk about what goes on under the hood to make this functionality happen.

