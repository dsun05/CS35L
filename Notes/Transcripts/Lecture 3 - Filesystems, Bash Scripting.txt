So, we are going to continue today in our discussion of Emacs and the shell and files in sort of an intermixed order. And if I recall from last time, we were talking about links and symbolic links and hard links. And if you'll recall, the picture you can have if we use this symbol for directories and this symbol for regular files and this symbol for symbolic links is that you have a root directory that you can always find out where that is just by typing slash, right? Slash is the name of the root directory. Under that, you have a whole bunch of directory entries.

a lot more than I'm drawing in this picture, but some of the important ones are the ones like, say, bin, and over here is user, and there's another one here called home, and that sort of thing. And these might be symbolic lengths, they might be other directories, there might be other directories under the directories, and so forth and so forth, and eventually, you hope you get to some good stuff, whereby the good stuff I mean something like, I don't know, gitignore, right? Which is a regular file. And the whole point of this directory structure really is to organize all those regular files. Most of the entities in this system are regular files. It's much bushier than I've drawn here. There's a ton more regular files floating around and all that sort of thing. But the basic idea is that each entity in this system has a unique ID which is its inode number, right? This one might be inode number one, this one might be inode number seven, three, eight and all that sort of thing. And you can, if you are inside the operating system and know the inode number, then you immediately know what file we're talking about, right? Here's file number nine, three, seven, one, six, two. We can find that out by running LS.

and ls minus lgit. Do I have it? Oh, I have a git config. There we go. Let's make it git config. That's much better. And if we use the minus i flag, we'll see that iNode number. Directories map file name components, that is the parts of the file names with no slashes, files. Hard links exist when you have two different directories, right? I could have another subdirectory here called d that both link to the same file, the same inode number. And symbolic links, they also have inode numbers. We can see it here. ls minus li bin, right? And it'll say, oh, that's a symbolic link with inode number 12, right? And the contents of a symbolic link, is interpreted by the file system in our case user bin so if you use this file name component it's equivalent to using this subsidiary file name now there's one thing I forgot to mention and that's going to lead into about five or six other things I forgot to mention but that's alright which is symbolic links come in two flavors relative and absolute This one is relative. The one you see on the screen is relative. You can tell whether symbolic link is relative or absolute if it starts with a slash. Absolute file names start with a slash. Relative file names start with something other than a slash. So we can see that this symbolic link is relative, which means the symbolic link is interpreted relative to where it's located. You look to see where the symlink is.

And then you say, oh, well, that points to some other name, right? So this one, since it says user bin, it's living in this directory. We treat it as if it were over here, user bin this directory, so this symbolic link points over to here. Once you have this mental model of the relationship between entities which have actual addresses inside the file system, and symbolic lengths that are merely textual things, then you can understand how naming works in this file system. Right? So the idea here is what we want to do is we want to resolve a file name, sometimes called a path name, to an actual file. And by resolving it to a file, I mean I want to know what that internal number is, 73738 because inside the operating systems once I have that number I can figure out everything having to do with the file. So you can think of inside the system there's a function called name_i which basically is pretty simple in its API. You give it a string, that's a file name, and it returns a number, an integer, which is the And if I sort of gave you as a programming assignment or a midterm question, please write the source code for name I, how would you do it? If you can figure out how to do that, you will understand how naming works in a POSIX file system. So briefly the algorithm is as follows. All right. So you first, you look at the first character.

If it's slash, that means this is an absolute file name. So that means start at the root, right? Root is ls minus li slash, right? Oops, ls minus lid slash, we'll get there. Right? It is file number two, I guess, here. Okay? Right? Otherwise, you start at the root directory.

If not, you start at the home directory. I'm sorry. You start at the current directory. So the idea is you take this string, which might be something that looks like this. Let's make it a little more interesting. Bin sh.

You walk through that string left to right and at each point in time you're pointing at a directory. You start off here at the root directory. You say, "Oh, I need to look at /bin." Once you look at /bin eventually you'll find out what directory that stands for and you say, "Oh, okay. Now I'm in this directory over here." And then you keep going. At each point you're walking across the file name saying, "Here's the directory I'm at I'm going to go next. Question?

Could you give an example if it didn't start with a slash?

Ah, if it didn't start with a slash, it would be something like this.

Oh, I don't know.

Bin slash, I don't know.

What do I have in my bin directory?

I've forgotten.

Ls bin, right?

Oh, I just have bin vcdwim.

So every program as it's running, that is every process, has its own idea of what the current directory is. When you log in, you are stuck, you know, initially in your home directory. So this is your current working directory. So this sort of file name, bin bcdwim, is going to be interpreted relatively to here. I have a bin subdirectory of my own. And underneath that I have a file called vc.duem, which is short for version control do what I mean. It sort of is a front end to git because git doesn't do enough, that sort of thing. And, you know, then this is sort of the file that we're talking about if we start here. So each process has its own idea of the working directory. You log in, you'll be in your home directory.

and there is a shell command. Oh, we're talking about the shell. A shell command called CD, which is short for change directory, which says, oh, from here on out, I want the shell's working directory to not be where it was before, but to be here. So if I type CD bin at this point, then all of a sudden my working directory in my shell isn't here.

It's down to here. So we can try this, right? CD bin xxx. It'll say there's no directory by that name, but if we say CD bin, then if I type LS, I'm in that subdirectory and LS will tell me about the contents of that subdirectory. All right? So what's going on here is that file names are interpreted this way, but I I left out something which is what the system does when it encounters a symbolic link. And in fact that's what's going to happen with this particular file name because bin is a symbolic link, right? We go to here, we see bin, oh it's a symbolic link. What happens then is that the system mentally substitutes the contents of the symbolic link. If it's relative, it's relative to wherever you were before, if it's absolute it starts over again. You come up with a new file name in effect and then the system interprets this new file name instead of the file name that it was given originally. Pretty straightforward except the system I just described to you has trouble. It can go wrong.

One thing that it can go wrong with is you can create a symbolic link that points nowhere. We've already seen that, right? I can say ln minus s nowhere foo, right? LS minus L. Here's a symbolic link to something that doesn't exist. And if I say cat foo, it'll say, oh, there's no file called nowhere, so that doesn't exist. But there's a more subtle problem that can happen. You can have something like this. Here the symbolic link says, "Oh, if you ever see an A, just mentally substitute B and keep going." And B says, "Oh, if you ever see a B, just mentally substitute A and keep going." The algorithm I just described to you will loop forever. So let's try and see what happens when we use that problem, right? Whenever you see some problems like this, give it a try.

What the system does is it has an internal counter when it's interpreting a file name. If that counter gets too big and in Linux I've forgotten the exact number but it's about 20. It says I give up. You've got 20 symbolic links to interpret this file name? You must be on drugs or something. And then it says I'm going to pretend that the symbolic link doesn't work. Even though it might work it could just be that you know you have a lot of symbolic links.

And this is how the system prevents infinite looping in file names, which would be a bad thing. One other thing I forgot to mention last time is that you can have hard links to symbolic links. So you can do something like this, foo, bar. Notice that foo and bar now have a link count of two.

different names for the same symbolic link. Both names are valid, right? And if you remove one of the symbolic link, one of those hard links to that symbolic link, the symbolic link will still be there. Also, if we do something a little odd like this, oh, I didn't mean to do that. Let's try that again. Make their e, ln foo e dot baz, right?

Now we have dot and E, right? So now notice we have three hard lengths to that symbolic length. And if we do something like this, touch E dot nowhere, I can cat E dot Baz because that's an empty file.

So the symbolic link works when it's sitting in the subdirectory E, but it doesn't work up in our current directory. Foo and E/BAS are the same symbolic link, but since relative symbolic links are interpreted relative to the directory they're in, one of these hard links works. Hard link to a symbolic link works.

The other one does not. Question? What does touch do? Oh, touch is a command that creates a file if it doesn't exist, and if it doesn't exist, it just updates its timestamp to be the current file. Yes? Can you explain an absolute versus a symbolic link? So when the system encounters an absolute symbolic link, well, let's create one. ln minus s slash bin slash sh to sh, right?

So now when we sort of do something, something that looks like this, I need to move this over so it stops popping up like that, right? Here we are, we can say home egert bin sh and oh, we started to run a command and it didn't like what I was doing, but basically the idea here is that this actually, you know, So it's a symbolic link. Symbolic link, yes. Well, let's do it this way. So when I use the minus capital L command, that tells LS, if you see a symbolic link, don't tell me about the link, tell me about what it points to.

This particular one sort of shows us that we've got four dangling symbolic links in the current directory and four that are valid. One of the valid ones is this absolute symbolic link sh which points to /bin/sh which means that whenever you refer to that one you always start at the root directory rather than from the current directory. So the way a symbolic link works is you splice it into the file name that you currently have But if it's an absolute symbolic link, you throw away sort of everything to the left of where you are. Questions? Other questions about how this is interpreted? Yes? So a hard link is just a directory entry. It's just an area in a directory entry that says this name maps to this file. You can have as many hard links to the same file as you want, but there's nothing It's like a pointer in a C++ program. Right? And in order to figure out what a hard link is you just say, "Oh, it's file number 97311." Right? It's like following a pointer. It always sort of points to something. A symbolic link is just a little squib of data in the file system that contains a string. That's all the symbolic link really is. It's just a named string.

The difference is that when that symbolic string is link is used, we take that strings value and plop it into the file name in place of whatever name the symbolic link has. So it's a difference between sort of a pointer versus like in C++ a string constant that you have to go look up in a hash table to figure out what it really means. Other questions about these Yes?

What's LN?

Oh, LN is a program. Any program, by the way, you can look at its MAN page. If I'm in Emacs, I type MAN LN. You can also look it up on, you know, with Google and that sort of thing. And what the MAN page does is it tells you the synopsis, which is a short version of all the ways that you can invoke LN, and then a description and then a whole bunch of options that you can run.

We have not used most of the options. But one of the options in LN is the minus S option, which is right here. It says make symbolic links rather than hard links, right? So ordinarily, if you just say LN A B, it creates a new hard link B that points to the same file that A points to. But if you say LN with a minus S option A B, it creates a new symbolic link B whose contents is this text.

whatever this text happens to be. So here A has to exist. Here A doesn't need to exist yet. Maybe you'll create A later. All you're doing is you're creating this symbolic link. I must say sort of to some extent this seems like why do we have two kinds of links? Why not one? And historically And the idea behind hard links is you want to basically share files with different names. So for whatever reason you want to have two different names for the same file and you'd like that to exist. Part of the reason there to be honest was I want to rename a file from A to B but I I'm not sure if I want to do it so I'm going to put my toe in the water. Give that file the name B and later on I'll decide to remove the A, right? In the meantime I'm always safe and I've never lost the data. So part of it is that motivation. Okay, if we can do this why not stop here? Why not just have hard links but no symbolic links? Symbolic links were added later because people couldn't stand some of the restrictions of hard links.

What are those restrictions? First off, you cannot create hard links to directories. If you want to have a link to a directory, you need to use a symbolic link. Why can't you have a hard link to a directory? Because if you could, you could create sort of file systems that look like this. You could have cycles in your system. It would be a disaster. People would get very confused. The system would never know when to sort of garbage collect free space and all that sort of thing. So no hard links to directories for good reason. We still want to have multiple names for directories so we invent symbolic links. Another reason to have symbolic links is you want to have an alternate name to a file that doesn't exist yet. So we want to allow dangling links. You can't have dangling hard links but you can have dangling symbolic links and sometimes that's a useful thing to have. But to be honest, I think the main reason was to have sort of symbolic links to directories. So you can do, if you want to cause trouble, something that looks like this. Oh, let's get out of this subshell. All right. ln minus s dot xxx, right? Now we have a symbolic link named xxx that points to the current directory, which means if we do something that looks like like this, xxx, xxx, xxx, xxx, xxx, what's going to happen? Well, it's just another name for the current directory. You can put as many xxx's as you want. You're always going to end up at the same place where you started. Or if you wanted to cause even more confusion, you can do something that looks like this, ln minus s dot dot to parent. All right, that means we now have a symbolic link that points to our parent directory.

And you can imagine all the fun that you can have with this particular symbolically. All right. Well, I've talked a lot about files. Let's talk about something else, unless there's some questions. Let's talk about the shell. So the shell is, to some extent, the first successful scripting language. And the goal of the shell, is to be a very simple language for sort of setting up other applications. That is, the idea is that you don't do any serious programming in the shell, although people have done that. It's not really intended for that. Instead, the whole point of the shell is to sort of get some other programs running and then get out of the way. What we'd like to do in the shell is do all the setup stuff so that the programs themselves don't have to worry about setting things up. The programs can assume a nice standard environment that's just the way they like it and they don't have to worry about routine operations like opening the input file or opening the output file. Everybody wants to do that anyway.

Why should every program have code to figure out which file to read? Put that in the shell, right? Because that's a configuration thing. And that's why one of the first primitives you learn about in the shell are these operators. You can say cat foo, right? This syntax of the shell tells the shell arrange for cat's input, standard input, to come from the file foo.

This works regardless of what command you're going to run. You can use the command head. You can use whatever command you like and these commands don't need to know what their input file is because the shell will arrange it for them. So we also have syntax that looks like this. This says run this command and then pass its output to bar and again the idea is we shouldn't need to have have a separate flag for every command to say, that flag will say where the output file should go and then the command has to go open it and all that sort of thing. Just let the shell do it. So when you run a command in the shell, the way it works is if you're running at the command line, you specify as many arguments as you like. Those arguments the shell treats as strings.

and it arranges for those strings to be passed to the main part of your program. So a goodly amount of sort of figuring out how the shell works is figuring out, depending on what you type, what main sees when it starts up. And what it's going to see here in this particular invocation is the shell will arrange for standard input and output, but these things are things that the shell has to tell the application. So it's going to say the argument count is two. We always count the name of the program itself as one of the arguments. An argv is going to be an array of three pointers, right, because it's char star star. The last pointer is an all pointer, and the other two pointers will point to strings which will be the same as what the shell was given by you. And then it's up to your program to figure out what to do with that. Now, when we're doing this kind of execution, there's a lot sort of fancier things we can do with commands than just do this kind of redirection. Let's see what else can go on here.

Alright, so first off, let's talk about shell tokens. And quoting and words. So the basic idea is when you type a command like this, the shell first has to figure out what strings you intended to type. And the simplest model for these strings is put in whatever character as long as it's not a space and it'll just keep reading all those characters and when it hits a space it says okay that's the end of this token let's see what the next token is. So some of the standard ideas here is all right we need sort of to know sort of the rules for tokenization because it turns out you can't just put any characters into a token, some of the characters are going to be exceptional. So the following characters are sort of unusual in the sense that you can't sort of put them into a shell token without doing some extra stuff. First off, of course, we have space and tab and newline. Basically, all the white space characters, carriage return, all that sort of thing. These aren't going to be part of a token ordinarily, just like they wouldn't be part of a token in C. We also have seen some characters like this, right? These are tokens used for IO redirection. There's more than just less than or greater than. We also have less than, less than, greater than, or greater than.

and we'll see later vertical bar and all that sort of thing. We also have some tokens that are sort of operators. These two tokens or or and and which means roughly the same thing in the shell that they do in a C program. And let's see what other tokens do we have. We have ampersand I should say which is running stuff in parallel. Looking at my keyboard, let me see of what other tokens we have. Oh my goodness. Well, we have sharp, which is for comments. Although the rule for shell comments is a little unusual in that you have to sort of start the line or have some white space in front of the sharp sign for it to count as a comment. Otherwise it's just part of the token that it's already in. And let's see what other characters we have. We have dollar sign, which is for variable interpolation or variable expansion. And grav accent, which is for command expansion. It's a different kind of expansion.

Let's see. Parentheses, of course. This is going to be used for subshells. And some other tokens are going to be used for file name expansion. Maybe it would be better if I just listed all the ASCII special characters that are not part of tokens, but I guess we're mostly here. What else have we got?

Now, quoting is worth learning about in pretty much any language because one of the most common errors you can make in a scripting language is going to be messing up the quoting. One of the commonest forms of attacking a badly written shell script or a badly written piece of JavaScript code is to get the program to screw up its quoting. So it's worth knowing the quoting rules fairly carefully. So the simplest one is backslash, which quotes the next character. So for example, if I were to type backslash, oh, I don't know, vertical bar, that basically says, I want to run a program whose name is vertical bar. There isn't any such program so it says vertical bar command not found. Notice that it didn't put a backslash in front of it because the backslash was not part of the command name. Or you can quote a backslash itself. Backslash in front of anything will just quote that thing. What happens if you just type backslash by itself? We quoted the new line.

And so it's waiting for us to finish the command that we ran. All right. So the next one is single quote. A single quoted string can contain any characters you like except for a single quoted sub. There's no backslash escape or anything like that. Whatever characters you like. So we can say, you know, And that's going to be, we want to run a command with the contents of that single quoted string. Notice that you cannot say an apostrophe in a single quoted string. If you want an apostrophe, the way you do it is something like this. Three O'clock.

is two single quoted strings, one is three space O, the other one is clock, separated by backslash apostrophe. That backslash apostrophe is an escaped apostrophe. So you can jam as many sort of tokens together as long as there's no spaces separating them, they still count as a single word. Any questions on quoting so far? All right. And the last form of quoting is a double quoted This works like a single quoted string except escape characters do work in here. In particular, what can happen in here is variable expansion or command expansion. Also, you have to use backslash to escape characters in here.

something like this, you know, 3 o'clock is good, right? And then pwd, which is a standard variable, which stands for the current directory. And notice it said, oh, well, in this case, that expanded to 3 o'clock is good, and then the pwd expanded to slash home slash egert slash bin.

All right. Can anybody see any problems that you can run into with quoting that I haven't covered? Yes. All right. So we'll do, that's a good one, right? So we'll say x equals, and we'll put, you know, some interesting stuff in here.

And then we can say 3xy, something like that. And what you'll see is that after variable expansion, the contents of that string, of that variable, is still stuck inside the string. It doesn't escape in the way that you might worry that could happen. Other questions about this sort of thing?

I guess I should mention you put new lines in strings. And then you can say you know something like this. And you can see that that string had a new line in it and the shell is perfectly happy to have whatever characters you like in a string. Okay. Other tricky situations.

Well, here's one. In C and C++, you cannot put a null byte into a string, right? It's not allowed. Strings, by definition, end at the first null byte. But can we do that with a shell? Well, here's how we can print out a null byte. Printf C and 0, all right. Oh, what did I do wrong?

Well, what's the right way to do a null byte? I thought that was the right way. Let's try it this way. All right, printf a backslash 0b. We'll get there. All right, so Emacs denotes the null byte with this control at sign because that's really what the null byte is.

can we put that into a variable? The way you can take the output of a command and put it into a variable is with dollar sign open paren. So this syntax means run that command, take its output, and then interpret that into the command that you currently do it.

So, you know, if I run something that looks like this, what is it going to do? It's first going to run this command. This command outputs the string echo space x. We interpolate this as meaning echo space x. It runs this command, and then it outputs x. So what I'm doing here is I'm saying take the output of that print of and put it into x.

and the shell says, I'm not going to let you put null bytes in a string. I'm going to ignore those null bytes and just take everything else. So I guess there are some limitations on what characters can go into a string in the shell. Normally you don't mess with null bytes so this shouldn't come up. Okay, I think that's enough quoting for now. So let's next talk about reserved words in the shell.

To some extent, you can name commands whatever you want. There's a command called cat. If you want to create a command called dog, it's easy to do that. You can create another one called moose or pig or whatever. But there are some limitations. Some commands you can't name because they're reserved words.

These are not quite the same as the reserved words in C or C++. In those languages, a keyword like if is basically reserved anywhere. You can't use it anywhere in the program except as the if keyword. But in the shell, these reserved words are only reserved when they start a command. So here is a simple reserved word.

You just type it like if cat x and then you can say then cat y else cat z v.

V is short for end if it's just if spelled backwards.

And basically what this means is run this command, whatever it is. If it succeeds, then run this command. But if this command fails, don't run this guy. Run this guy instead. You can put whatever commands you like in the if part, the then part, or the else part. It could be as long as you wanted, right? You can say if emax who and then sort minus c bar, then else.

So the if part can be as many commands as you like. The general rule is that a command succeeds if its exit status is zero and it fails otherwise. So what this will do is it'll run this if sort c minus c succeeds, we'll run the then part. If it fails, we'll run the else part. Over here we have if cat x then cat y else cat z.

cat x fails because there is no file x so cat exits with a nonzero exit status so that means it has to run cat z cat z also failed right so in some sense the entire if failed you can tell whether or not the most recent command failed by inspecting this special variable right this is the exit status Most Recent Command. Currently the most recent command that got executed was that IF command and if we look at its exit status we'll see that its exit status what? Which is a failing exit status. All the nonzero exit statuses indicate failure. Which is really confusing. Because if you're used to C and C++. Zero means false. Everything else means true. In this language, zero means success or true and everything else means false. Question. Why is cat what? Why is cat Z not the most? Why is cat Z not the most? Why is cat Z not the most? Why is cat Z is the exit status of the then or the else part, whichever got executed. Since CADZ failed, the exit status of the if is the exit status of the CADZ. And CADZ failed, so the if failed. Question? If you execute a bunch of commands in sequence, the shell basically discards the exit status of the earlier commands.

So this means I don't care whether emac succeeded or failed. All I care about is whether sort succeeded or failed. Now it's very common in shell scripts for you to care. You want both of these guys to work, right? You don't want just a single guy to work. And there's a built-in way to do that. It's this operator I already mentioned. Ampersand, ampersand in the shell means roughly the same thing it does in C except with zero and non-zero requirements.

This means if emax foo succeeds then run sort minus c bar and exit with its exit status. If emax foo fails immediately fail with that exit status. Don't run the sort command. And you can probably guess what or or means if you write c or or d that means run this command. If it succeeds then immediately say oh I'm done. Exit status is zero. If this command fails then run d and exit with whatever its exit status is. So in some sense, you know, we don't really need these guys, right? That is, instead of writing this, you can write this. If C, then true, else D, C. These two things, this one and this one, mean the same Same thing. True is a very, very simple command. It always succeeds. It doesn't do anything. So these two commands are equivalent, but most people write it this way because it's a lot easier to read. And you should be able to come up with a similar sort of equation for ampersand ampersand. All right. So here is one set of reserved words. That means you can't have a command called then because the shell will treat it as a reserved word and tell you you have a syntax error.

Here's another set. This is a while loop in the shell. So what this does is it keeps executing the loop so long as this command succeeds. If this command succeeds, it runs this command, then it tries this command again. If it succeeds again, it keeps going over and going. But the first time this command fails, then the while loop sort of says, okay, I'm done. All right. There's a related version called until, which is like the while loop except it negates the sense of the test. It's not all that commonly used. Let's do some more. We have this one. The case statement is in some in the same sense like the switch statement of C++, except it's considerably more flexible in the sense that you can specify sort of whatever patterns you like in order to see which case to evaluate. So you can say something like this. This means basically take the value of the variable x and interpret that and see which of the patterns that it matches.

So you can say, well, if it's a star dot c file or it's a star dot obj file, then we'll do this, right? We'll run gcc dollar sign x. Two semicolons, separate cases. And otherwise, we will run clang on x.

ESAC marks the end of the case statement, it's case spelled backwards just like phi is if spelled backwards. And the idea is you take whatever this expands to, find the first pattern that it matches, go and execute the corresponding statement, the corresponding command I should say, and then the exit status of the case is the exit status of whichever branch you executed. So in some sense, Just as I explained here, we don't really need ampersand, ampersand, and or, or. We can always use if. In some sense, you don't even need if. Instead of writing this, you can write this. Run a, and then look at its exit status.

0, well then you run C. Otherwise, you run B. No one would ever write a case statement like this. You'd always use the if-then-else or ampersand ampersand or something, but in principle you could write it this way if you liked. Question? Yeah, the last one, the very last one isn't needed, but I like to write it down for symmetry, but it's not required.

Also, the opening parens are not required. If you don't like parentheses, you can get rid of the opening parens. Questions about these reserved words? Yes. Oh, did I get it wrong? I did. Thank you. I always get those reversed. True and false, zero and non-zero. But yes, you caught me on that one.

Other comments? On this one, yes?

The thing that executes, it's always like a program, but can you just do like one less than two and do a return?

Oh, you want to do arithmetic? You want to add two numbers? Yes, you can.

I never do this or at least hardly ever but if you want to add two numbers you can say something like this so dollar sign open paren open paren these have to be right next to each other it's sort of a special case it means The stuff inside the double parentheses is not a command to run. Oh. It's an arithmetic expression that you should interpret sort of by the rules of arithmetic expressions. But to be honest, I almost never do this because if I wanted to be doing computation, I'd be writing Python code or C++ code or something. I wouldn't be doing it in the shell. But if you really, really need it, there it is.

Oh, can I put x less than y here? Well, you can write, I don't know, something like x less than 1. I would never write this code, right? This evaluates to 1 or 0 and then put a 1 or 0 here. But no, this is not something that I would write. Another question? Yes?

Yes. Does that mean that it fails unless it runs? Oh, suppose no cases, suppose no patterns match, right? Then I believe the exit status is zero. That counts as success. Yes? Right. I believe that's what it does. But, you know, try it. We can try it here, but it would take some time. Yes? This one here?

The double paren one says take everything between the double parens, treat it as an arithmetic expression, and expand to the value of that expression. The single parens, like this, mean execute this command. The command will generate a bunch of output, take that output, treat it as a string, maybe with some new lines in it, assign that string to z.

These two things mean quite different things. And that's one of the reasons I don't like this notation because it looks so much like this one. And this one is what the shell is for. This one is for amateurs. Other comments about quoting or interpolation? Why don't we take a break and we can start up again at the hour. All right, let's start up again. We were doing the reserved words.

And somehow my microphone got louder. All right, let's try that again. All right, so we have a few more reserved words. One is the for loop. You're used to C++ for loops where you iterate an I++ and all that sort of thing. The shell has a somewhat higher level view of for loops. And the idea is you have a control variable and then you specify a whole bunch of words here and the loop executes once for each word.

that you type. So we can do something like this for v in a, b, c, x, x, x, 27 or 23, do echo, I don't know, $v in parentheses, done. So what it does there, it's a bunch of words, and then you can say do like this, or If you like put it on the next line. Commands. Done. They should have spelled this OD, but they didn't. I guess they got tired of spelling words backwards. So you don't actually have a control variable that you increment or that sort of thing. The variable is just assigned to each of the words in sequence. Now it's very typical for to have these words be the result of a previous expansion. So you might do something that looks like this, equals a, whoops, x equals a, b, c, for v in x, do echo v, done. So what happened here is x expanded to a, b, c, separated by spaces, they got expanded, then we iterated through the loop three times, v got set to a, b, c, c, c, c, c, c, c, c, c, c, c, each one of those values in turn. Commonly this is used with file name expansion, right? So right now we have these variables here and we can say for v in star do echo v done and that will iterate through the loop once for each of the files in the current directory, everything that star expanded to. All right. Any questions about loops?

We did while loops. We didn't actually do any while loops. Yes? This last command here for V and star. Right? So star is a pattern. We'll get, we'll do a little bit more patterns later that expands to all of the files in the current directory, at least all the file names that don't start with dot. Right? So if you just use star all by itself as a word in a command, it expands to all those names. So when we said for V and It was equivalent to saying for V and A, B, bar, E, foo, parent, blah, blah, blah. And then so the loop got executed. The loop body got executed one, two, three, four, five, six, seven, eight, nine, ten times. All right, question. Yes, so all of the reserved words we're talking about, they're only reserved at the start of a command, right? And so do is okay here because I put it at the start of a command.

It would also be okay to put it here except I need to say oh it's at the start of the command and I need to tell the shell that by putting a semicolon in front of it. Do is not reserved in other places, right? So I can say something like this and it's fine. It's not a reserved word in that sense or I can say this for I in for I in do done do ECHO I done. Notice that all of those guys were not reserved because they weren't at the start of the command. Question? A couple of spaces above, you did ECHO in double quotes for end of C dollar sign B. Right. And then you started doing just dollar sign B. Are those the exact same or are there situations where you would want to do one and not one? Oh, that's a very subtle point.

Let's try that. So let's do something like this. V equals AB. If I say cat V, it's going to actually expand $V into the two words A and B and it's equivalent to typing cat AB. On the other hand, if I say cat V in quotes, that means we have a single word here. It's a quoted string. The contents of the string might be arbitrarily The contents of the string might actually contain spaces, but it's all passed as a single argument to cat. So cat sees a single file name, a space b, which doesn't exist. So it gives me a single error message rather than two, right? It's equivalent to me typing this. I don't have any file named a space b in the current directory, so the cat doesn't work. Good point. Thank you for bringing it up. Other comments? Yes?

When you put in a string, it's basically kind of like the same sign or something? The same line. Why does it only print out one error? Because in these last two executions, I have run cat with argv being two, one for cat, one for ab, and argc being sort of a pointer with just two strings in it, cat and then the string a space b. Above, where I said cat ab without the quotes, argv was three, cat and then a and then b. Similarly, if I say cat dollar sign v without quoting it, it expands to the equivalent of cat a b. So it's a question of whether the arguments are split or not. This turns into, to be honest, kind of a subtle point in the shell. Knowing when things get split by spaces and when they don't turns into something of a hassle. All right? Question?

So it looks like you can, how long does like the shell remember variables? Until you exit the shell. Yeah, right now we're only looking at global variables and all that sort of thing. You can have local variables, but I'm not going to waste, that's just a minor detail. For now, everything's global. All right, other comments? All right, well let's do, there are two more sets of reserved words. Here's one of them.

exclamation point. Exclamation point in front of a command negates the success or failure of the command. So if I write this, this command fails if cat foo succeeds and succeeds otherwise. So we can say cat a, right, and say what's the exit status? And it'll say oh, it's one.

we can say not cat a and what's the exit status and they'll say oh that succeeded. Right so you can use exclamation point in the shell pretty much like ampersand ampersand and or or. Right you can say if this thing failed and this thing succeeded and all that sort of thing and that's what the exclamation point is for. Question? The command still executes the only difference is how the shell treats its exit status.

Everything else about the command is exactly the same as before.

Then the other reserved word that's worth mentioning is this one, which comes with its pair, this one.

This you can use to collect a bunch of commands and treat them as a single command.

So you can write something that looks like this: "ket_poo" ampersand ampersand "ket_bar" or "ket_bats". So this basically says just treat these commands, you know, as being on the left hand side of this OR and then in here you can put whatever commands you like. So it's a nest, it's sort of a nesting thing. The same thing that it was in C++. The difference, however, is here you gotta put a semicolon there because if you don't put a semicolon there it won't look like a reserved word. Right? So either have a semicolon in front of this closing brace or put the closing brace on a new line. All right. Enough reserved words. Let's talk about variables. We've already mentioned some things, right? A very simple thing is you can just get the value of a variable v.

by typing $v. But we have some special variables as well. You can say this. These are special variables that refer to the arguments of your shell. This is important when you're writing a shell script, which is a file containing a bunch of shell commands. When the shell executes that file as a script, set dollar sign one dollar sign two and so forth and so on to be the arguments to that particular command that were typed when you ran the command. We also have this which means all the arguments. All right that means in effect dollar one up through dollar n right which is this the last guy it may be dollar nine or something.

$0 is the name of the command itself. So to some extent this acts like argv in a C program, it's just that it's a little bit more concise. There is a special case though. Suppose you do something, well let's see what we have here. I don't think there's anything interesting here. We started up this shell with no arguments.

we can do something like this.

So what happened here is I invoke the shell with a special flag that says don't start up a subshell to execute a file, don't start up a subshell to read commands from the terminal. Instead just pretend that I type that command echo dollar sign two and take everything else afterwards as being argv0, argv1, argv2 and that sort of thing. So a is the name of the command, b is its first argument, c is its second argument and so forth and so on. And so the shell said okay and it outputs c because c is dollar sign two. Suppose we do something like this minus c for i in dollar star do echo i done.

Notice that I've told my subshell to go off and, you know, kind of do the right thing. Now suppose I do something a little trickier though. In some sense the shell did not work here the way I I wanted it to because what it did was dollar star expanded to the values of all the shells arguments separated by spaces but then it took the space in CD and said oh that's a gap between two arguments. I didn't want it to do that and the way I can prevent it from doing that is with a special variant of dollar star called dollar at sign. This is also all the arguments but it works right if you spell it sort of this way. All right, let's try that. So we'll take this same command and we'll use @ sign instead. We'll try to anyway. It didn't work.

I forgot to quote it. I did say about an hour ago, quoting is very important. And here's an example of where it's important. So if you say $at and then put it in double quotes, it expands to all the arguments of your shell script but properly sort of broken apart the same way they were in the original arguments without taking any embedded in the arguments and splitting them apart. Question? Say, what's that? Because A in this particular use of SH minus C, A is the shell's, is the command name, right? So we would have to say something like this if we wanted to actually see the A. So we can say something like this, dollar zero, right?

and now you'll see the a. Right? So these guys do not expand to $0. If you want $0, you have to spell it out explicitly. Question? So it, oh no, because you know, so if I do cat, see? Like that. It's just a string as far as this command works, right?

you can say I don't know you can even say for right it's just a string that we're giving it and in effect this means we're telling the shell that the name of this command was for you can't really ever have a command name for right because that's a reserved word but we're telling it that and it says well I believe you question well I mean this has to do If I wanted to create a command called for and I said for a b, right? The shell is saying it's a syntax error. Now there's a way around that. If this command for is in user bin, I can do this. Because now all of a sudden for is not starting the command, it's just part of a string, and then it will try to run an actual command named user bin for. I'm not sure I answered your question, but The idea is reserved words are special to the shell syntax engine and it does that before it does anything else. It looks at the reserved words first. And so you can't sort of name a command that's going to be something like that. But over here we're not asking the shell to parse anything so it says okay you can call it four if you like. Other comments. All right let's try this one.

tells you how many arguments you have. At the top level here, we have no arguments, so it'll say zero. So you can use that to figure out whether you have arguments or you don't want to have any arguments. Suppose you say something like this. This expands to the value of the variable x if x If it doesn't have a value, it expands to default. So you can say something like this, echo foo x dash x, y, z. And because I haven't defined a variable called foo x, it will then output x, y, z. If I had assigned a foo x, it would give me foo x's value.

There's a whole bunch of things like this that you can do to a variable's value before you actually use it. Right? So you can do something like this. Pwd plus set. This expands to whatever comes after the plus if the variable is set and it expands to nothing otherwise. Right? Or you can say something like this.

If you put a question mark, basically it says interpolate the value of that variable if it's set, but report an error and don't execute the command if it's not set. What's going on here is the shell is a configuration language. A lot of the things you do when you're configuring a program have to do with setting up parameters exactly the way you like them. And when you're doing that, you will find these operators of variable to be helpful in sort of saying, "Oh, well, I'll use the user-specified value if there is one, and I'll use my own if not." Another option that you can have is something like this. This interpolates the value of the PWD variable if it exists, If it doesn't exist, it sets pwd to be the value after the equal sign. Since I have pwd set, this is going to basically say, oh, I'll just use homemaker bin, which is the value of the variable, ignores everything after the equal sign. But if it weren't set, it would have used the string after pwd to initialize pwd. So it means use this variable's value. If it's not set, set it to this value, the default value, and use the default. And that's all sort of bundled into it.

a single dollar sign equals thing. Okay. What else have we got? You can unset variables if you like. Well, all right, set. That's a lot of stuff. Let's go back to where it was. The command set outputs the values of all your variables, right? So there they all are, okay? It also outputs the values of all your function definitions. I've left off function definitions for now and all that sort of thing but you know I have a lot of them in my environment so you can see there's a whole bunch of things that you can find out about your shell session by looking at the environment variables for example you can tell from this list what my favorite text editor is sitting there about two-thirds the way down editor equals emacs right and so what's happening here is we have a notion called the environment which is a set of name value pairs.

The shell models this environment just as a set of shell variables that you can assign to.

Not all your shell variables are taken from or put into the environment, just some of them.

You can sort of say which variables you want to export with environment with this command. You say export XYZ means export XYZ equals whatever its value is to the environment. With the environment, any commands that you run will have access to the environment.

and can use that environment to follow your preferences. If I tell the environment, "Oh, my favorite editor is Emacs," then when some command wants to start up a text editor, it knows which text editor to run. Okay. Let's see. We have some more built-in variables that I should mention. I have a list.

"$$" which sounds like it must be a very important command, and in some sense it is. Every time you run a command in Linux, it gets a process to run in. That process is identified by a process ID, and this is going to be the shell's process ID.

So if we type sort of echo $$, it'll say I'm process ID number 5402. You can look at all the processes on the system by using the PS command, which I believe I've already mentioned. So I'm going to do a PS minus EF and then grep for 5402. And notice that, sure enough, The first one listed is process 5402. The other guys are related to 5402, but I'm interested in the first line. Okay? There's something else you can do interesting with process numbers, which is you can run commands in parallel with the shell. So if you have some big command, a big sort, right? So this sort, you're sorting a, you know, a 5 terabyte file. And you don't want to wait for it to finish. You can find an ampersand after it. That tells a shell, don't wait for the command to finish. Immediately give me another prompt. When we get to here, the shell is running and this sort is running. They're both running. And at this point, dollar sign exclamation point is the process ID of the last command executed in the background, which is what this command was. Now, I don't want to sort a multi-terabyte file on my poor little laptop, but I do know a command that will take a long time to run, and that's the standard command sleep. You give sleep a number, and it waits for that many seconds.

So here we can run sleep of 0.001 and it only waits a millisecond. Or we can run sleep and it's going to sleep for quite a long time. So we don't want to wait for that long.

out of it. But what I wanted to do is do this. I'll put a space in front of that ampersand, right? So now what we have, and the shell helpfully tells us sort of the subsidiary process ID, we have another process that's running. It's not actually doing much of anything since it's sleeping. But if we do a PS, we can see that it's there. Oops.

There it is. Okay. Now, as sort of an SIS admin or something like that, I could at this point sort of say, I don't want this process to run anymore. Let's kill it off. 5885. The kill command will send a signal to the process saying, hey, wake up. I want you to die. And sleep obediently does that because it's gone now, right?

But it's more common to do something like this. Sleep, 1E308, 30 is good enough, right? And now we can say the sleep PID, I'll call it SPID, equals dollar sign exclamation point, right? Echo SPID, and that's going to be 5890. There is another command called wait.

which tells the shell please wait for that particular process ID to finish. So what you can do, we don't want to wait for 10 to the 300 seconds, but what you can do here is you can program something that will sort the big file, do something else, and then when you really need those results then you can say okay let's wait for this guy.

some other stuff and then say wait dollar sign p. So this is a very simple primitive mechanism for synchronization. Now I should say that I hardly ever do this. It's there if I wanted, occasionally I'll do it, but it's pretty rare that you'll actually want to do this because the shell has better methods for synchronizing amongst processes.

that want to cooperate. And these better methods have to do not with something as simple as just wait for the guy to finish and then we're done. But it's to let multiple subprocesses coordinate with each other and to exit when you're happy with that set of processes doing all that they want to do. And that standard method of synchronization or concurrency in the is called the pipe. It's a very important data structure inside the kernel. When you take the operating systems class you'll learn how they're built and all that sort of thing. But essentially what the pipe is is it's an efficient substitute for a temporary file. We want to run two programs. We want the first program's output to be sent to the second program as input. But what we don't want to do is to stick all the output into a temporary file, thus filling up our file system, and then run the other program and read all the output from that output file as input, and then remove the file. That's inefficient for two reasons. First, it chews up space in your file system. Second, and more important, it means you have two trips through the data. You've got to ship all the data out to the flash drive, in the flash drive. We want something faster. We want to keep the data in main memory at all times. You don't want it to go to a file system. Files are really slow. So that's what a pipe is. A pipe is a bounded buffer inside the operating system. And what's going on here is we have two perfect We can have more, but for now let's just have two. And the first program outputs to this bounded buffer and the second one reads from the bounded buffer. Neither program can access the buffer directly. The only way they can affect what's in the buffer is this program does writes and this program does reads. As far as the programs are concerned, they could be writing to a file and reading from a file. They don't care. They're just reading, writing from standard input, standard output, all that sort of thing. Except there's no file here in between the two. There's just a little bit of main memory. How big depends on the operating system, but we'll just say 10 kibby bytes. The actual number is probably a power of two, but it doesn't really, well, no, it's not. Anyhow, the actual number doesn't matter.

The basic idea. Initially, the pipe's empty. Initially, when this program tries to read from an empty pipe, the operating system says, "Hold on, there's no data there." And this program hangs. Doesn't do anything. It's waiting for the read to finish. Initially, when this guy does a write, it quickly puts as much data as it wrote into the buffer, and now the operating system can wake up this guy and it can read.

It's a race. If the writer is really fast and the reader is kind of a slow thinker, what's going to happen is the writer is going to quickly fill up this buffer, the reader goes and the writer is going to sit there twiddling its thumbs, not doing anything, not chewing up CPU time, but it'll slow down to match the reader's speed. Similarly, if the reader is really fast, I can read it and the writer is kind of slow, put a few bytes in, put a few bytes in, what's going to happen?

the reader will slow down. Because oftentimes when it reads there's nothing there. So the operating system will suspend it and go off and do other things. So this is a way that you can do concurrency in a very simple way in which the programs themselves don't even need to know they're running concurrently. They're just reading and writing. But you're building an overall application in which you are synchronizing the speed of all of the different parts of your system that they don't step on each other's toes and they each get work done. Now, if you run several of these in a row, and let's say this is the command A and B and C and D, the shell notation for this is pipe A's output into B's input, output into C's input and pipe C's output into D's input. That is a simple command in the shell. You can just run that pipeline. The shell will arrange to create all these mysterious little buffers and do all the arrangements of the IO and it will all just work. When you do this, A starts up with its standard output being this pipe. A's standard input is whatever, you know, the pair the parent shell's standard input was. B standard output and standard input are the two pipes and C as well. D standard input is the pipe, its standard output is basically inherited from the shell. That being said, you don't have to live with the default. You can change the default if you want by using IO redirection. I already talked about these two operators.

are fancier versions of these operators that you can use in a pipeline or you can use elsewhere that will affect exactly how these commands are set up. The fancier versions look sometimes like this. This says redirect standard error to that file rather than standard output. So each process typically has three file descriptors that it cares about.

1 as standard output, 2 as standard error, and it's important to know about all three. This says redirect standard error and this is probably the most common way that you use a digit in front of one of these less than or greater than. But you can use other forms of redirection as well. So for example, you can say 0 less than file. That's equivalent to saying less than file, right? Because ordinarily less than just means redirect standard input. But you could also do something a little screwy like this. I don't recommend this, but the shell will let you do it. It says make standard output have read access to this file, which means anytime the command tries to write something, it's going to get in error because it's not allowed to write to a file that it's reading from. Okay? Let's see what other commands we have along these lines. Well, all right, so let's do one sort of a combination of these two. You can run A, 2 greater than E1, vertical bar B, 2 greater than E2, vertical bar C. All right?

is it runs the command A, its standard output is the pipe, its standard error though is going to a regular file called E1. B similarly, its reading from A's standard output from that pipe, its outputting, its standard output is going to this pipe, but its standard error is going to a file called E2. C's standard error is going to whatever the standard error of the shell was. It gets more complicated.

You can, if you like, change an existing redirection to be somewhere else. This notation says the following: redirect standard error so that it points to whatever standard output currently points to. All right? So, for example, if I change this command to look like this, That means that B's standard error and its standard output will both be directed into this pipe and C will see both. B's standard error and its standard output, those messages will be interleaved as far as C is concerned. It'll see both things. Question? This one here?

This is just going to a regular file called e1. These guys don't even see it. Later on you could do cat e1 or something like that. But these guys don't know about e1. Where is b getting its input from? It's getting b's input is from the pipe, a's standard output goes to the pipe because that's how this pipe syntax works. This only affects a standard error. What's that?

What's going both? It's like A's output is going to E1. Its output are going into this pipe, which B reads. But it's not that it's out, you know, a single output thing is going in two places. It's just its standard output is going one place. Its error messages are going another. And what if you change it to A, like one greater than E1?

This means set up the whole pipeline the way we described but then when you run A change its standard output to be the file X and in fact since that's the default for greater than I can just leave the one. Which means when B reads from the pipe there's not going to be anybody there. B will immediately see an end of file. So you would never want to run a shell script like this. This doesn't make any sense. Yes?

Right. The standard error will be inherited by each of these guys standard error will be whatever the shell standard error was. And that's true for an ordinary command. If you just run the command A with nothing around it, its standard input is the shell standard input. And its standard output and standard error are the shell. Yes? Over here?

See, we'll see both these error messages and its output messages. Well, let's try that, right? So we can do something that looks like this. We finally exited from that million-year program, right? So we can write cat, etc., OS release, and then foo bar x, 2 greater than 1, and then sort. So what's going to happen here? CAT will read the file etc. OS release. And there is a file by that name that tells us all sorts of stuff about the operating system. It'll also try to read the file foobar x, which doesn't exist. It'll output an error message to standard error. But this says, send standard error to wherever standard output is going, which is into that pipe. So sort, when it reads, will see both the error message and the pipe message. Where is the error message? Oh, the error message turned out to be After sorting it was the second line. Okay, question. You cannot overflow the bounded buffer. Because if this guy goes right right right right right right right right right right and this guy is not doing any reading then the instant the right says I want to write more data than is available in here the operating system pauses the program. It's the program can't run.

It's just frozen. It's like you're writing to a very slow device, shall we put on. So you cannot overflow the buffer.

So when you read it, it goes away?

When you read the pipe, yes, it does go away. Yes?

Let's say if you wanted to save the error as well as the input into E1, you still want the output to go to C and that input. Would the difference just be like a space to be...

So you have one program A and it's going to generate errors and ordinary output. And you want another program C to see what? Yeah. Make file descriptor 2 a copy of file descriptor 0. Oh my goodness.

That means I want the error messages to be sent to standard input, which is not going to be what you want.

So you want B's standard output to go to E1 and its standard error to go to the same place that standard output goes. You write this. So the I/O redirections are executed left to right and this takes this into account.

All right? Question?

Can you explain the 2 ampersand 1, like how it's like?

All right. So how it, what it means?

Yeah, how it works.

It means basically whatever standard output currently is, I want you to run B in an environment where standard error is the same thing. It's the same output stream as standard output. So change standard error. Whatever standard error used to be, I don't pay any attention to it.

Make standard error the same as what's currently standard output. Yes? Yeah, a single output stream has to go to a single, can you split it? Well, there is a command called split, but it doesn't do what you want. Yes? Oh, wait, no, no, I have a way of doing it. Wait, wait, wait, go back to that question. All right? So, so let's suppose, let's suppose we want to do something like this, right?

Program A outputs into a pipe and then Program B reads from the pipe but Program C also reads from the same pipe. Right? So that's the kind of split. So sure you run this, right? This says run B in the background. Don't wait for it to finish. Start running C right away. Okay? Well, when that happens, B and C both have the same same input they're both competing from input from the pipe if B is an eager reader and C is not very eager than B will read most of the input but they'll split the input in some sort of random and non-deterministic way yes oh absolutely this is a total race condition I yeah I hardly ever write a program like this because of that sort of race condition but you know you can also do this right this means oh well here's the program D and here's a pipe and it's reading from the pipe and these two guys are both writing into the same pipe. So yeah, you can set up, I won't say you can set up an arbitrary network this way. You cannot set up a cycle, but you can do pretty much any other, any acyclic graph you like with the shell. All right, other questions about this notation? Yes. Why can't you? Try it. Try to create a cycle.

All right. There are actually ways to do it with the cycle, but you can't do it with this notation. It requires special things that I don't want to tell you about. Yes? Yes. A tree? Well, you know.

So I'm doing a nice little binary tree right and then you just keep multiplying right the size of the tree grows exponentially just like a real binary tree yes well yeah except you know to some extent suppose B is running on a fast CPU and C is running on a slow CPU but then suppose they flipped around the operating system decides to run C on a fast CPU and B on a slow CPU You don't know in advance which is going to run. And also, this stuff still works even if you're on a single core machine. There's only one CPU. In that case, the operating system arranges for these guys to sort of timeshare the CPU. And whichever, you know, if B happens to get the CPU now, it'll race faster than C, but it all depends on the operating system scheduler. Yes? Oh, sure. Yeah, yeah. Yeah, you could do that.

And in fact, some people actually do stuff like that. You can get away with that if you play your cards right. Okay, other comments. All right, let's see what else have we got. Well, to some extent, what I've been doing here is I've been going through expansion roles in the shell. And by that, I mean the shell reads a command, and then it expands very variables sort of figuring out how to do things, right? So we've already seen variable expansion. That's where dollar sign x gets expanded. But there's other kinds of expansions as well. There's tilde expansion. This occurs when you see a word that starts with a tilde and then either has a slash like this or a username. Maybe possibly followed by a slash. This basically substitutes the value of the home directory of the current user or the home directory of this particular user. This tilde is equivalent to saying $home. These two things are the same thing. This is something new though. You can't say this with ordinary variables because in effect you're looking up sort of a user's name in some lookup table somewhere. And then the next kind is command substitution. We've already talked about that. That uses this syntax or this syntax. I don't like this syntax so I've avoided it in this lecture but some people like it. Really this one's better because it nests nicely here. Nesting is kind of tricky.

We also have arithmetic expansion, which I've already talked about. You say something like this. The next one though is field splitting. So after all these other expansions, yes question?

You can put it there, you don't need it, it's optional, it's annoying. All right, okay. Field splitting occurs after all these other expansions. In fact, I should say that they're done in this order. Field splitting occurs when you take sort of all the expansions that you've currently done, you split words at sort of white space boundaries.

So if I do something like this, and then I type echo dollar sign x, first it does variable expansion, it gets abc out of it, it does all these other things, nothing happens. Then it does field splitting, it notices that the contents of x, right, we have this single word abc, but there's spaces here, these shouldn't count.

So it splits these into three words instead of one. This is a tricky area because like I mentioned with dollar sign, at sign, whether you want field splitting or not depends on the application. The next thing we do is path name expansion. This is where we take patterns like star dot C or A minus Z star dot x, that sort of thing, and figure out what file names they stand for. The shell looks for file names that will match these patterns. This pattern, a path name expansion is sometimes called globbing, and substitutes the files for the patterns. There's an exception though. Suppose you have no file name that matches the pattern. In that case, path name expansion does does nothing, right? So here we go. There's a pattern, star comma xxxxx. There's no file name with that, so you know, path name expansion does nothing if there are no paths that match. After that, we do redirection, which I've already talked about. So what looked like was a pretty simple thing, just run a shell command. How hard can it be? Turns into this fairly complicated sort of birthday cake or wedding cake. There's a whole bunch of things that go on. And next time, we'll talk a little bit more about globbing and its big cousin regular expressions.

