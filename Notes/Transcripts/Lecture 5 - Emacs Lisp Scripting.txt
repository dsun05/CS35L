So today I'd like to talk about scripting languages. But that's not really the right thing. Right? And so I'll put that in quotes. Because when you talk about programming languages, we have a whole course on that.

and all that sort of thing. And these are commonly divided into three major areas where you have to understand all three in order to figure out what you're doing with a scripting language. One is syntax, which when we teach you C++, we spend a lot of time teaching about the curly braces and the semicolons and all that sort of thing. But to be honest, this is considered to be a solved problem. Syntax is pretty easy.

It's just a bunch of details. There's some theory behind it. We love the theory, but from a practical point of view, a more important area is semantics. Syntax is about form. Semantics is about meaning. It is once you understand where all the semicolons and parentheses go, what does that program actually mean? What does it do? Right? Obviously, that's why you wrote it. So in that sense, it's more important.

Obviously semantics are harder to nail down. They're harder to figure out. We do more hand waving in CS 31 when we talk about this than when we talk about this. This course, however, to some extent is not mostly about either. It's about the third major category of scripting languages, which I'll call pragmatics. It's neither form nor meaning.

all the other stuff. How do you get things to work? How do you configure it to work? What makes things go fast versus slow? What makes sense when you have to sort of get things working in the presence of other modules that aren't working? Right? So this is sort of everything else. It's about efficiency. It's about security and trust.

and a whole bunch of other things. Okay? And so to some extent, when I'm talking in today's lecture about scripting languages, we're going to focus on two of them. One is Emacs Lisp. The other is going to be Python. I want you to keep these three things in mind, right? In some sense, you know, I've got to talk about syntax in order to put anything up on the screen or to write anything. So syntax is something you've got to know, but it's the All right, semantics, you also have to know and I'll spend a good time talking about it, but again, it's the easy part. Please try to think about the other things. Why should you run a program this way rather than the other way? Why should you pick Python versus JavaScript? That sort of thing. So try to sort of think through the surface layers here because we really want to talk about the deeper layers. All right, so with that in mind, what are some For example, scripting languages. We've already spent a good deal of time talking about one of the oldest scripting languages that's still there and stable and it's the way it was back in the 1970s when it was invented. The shell, it hits a nice sweet spot in terms of being a scripting language for configuring other programs. Configuring and running programs. That's what it's really designed to do and since we still need to configure and run programs there's still a nice home for the shell. Another scripting language less obvious which is one I'm going to start talking about today is Lisp. And in some sense Lisp is there sort of by courtesy or sort of a controversial pick for this sort of thing because it didn't start out as a scripting language.

It started out as a language much like C++ or other sort of low level languages like this except it was focused on AI. Except we're talking AI circa 1962, right? Very primitive AI by today's standards and the focus of LISP was to write, make it easy to write programs that could to sort of escape the burden of programming, have the computers program themselves. Well, we're still working on that. If you've ever tried to use, I don't know, Copilot or that sort of thing to write programs, you'll see that they screw up a lot. But that was the dream. And in some sense, that dream makes Lisp suitable as a scripting language for something like Emacs.

Because the idea is you can script emacs by writing a script that's fancier than what you can normally do in the shell, but that script will write another script, which may write a third script. In the end you finally get the script that you want. So that's one way in which Lisp is different. It's sort of we want to be able to do self modifying code.

We want to write programs that can generate other programs. There's another sense in which it's a different scripting language in that we're not looking at any Lisp. We're looking at a particular flavor called Emacs Lisp. This is a Lisp with a lot of primitives built into it to support the things you need to do in a text editor or an integrated development environment. And the phrase I'd like you to remember about this sort of thing is that it's an extension language. That is, it's not intended to be a general purpose scripting language that you can use everywhere, although some people use it that way. That's not the original intent. The intent is that you start off with a pretty reasonable text editor and then you can extend it your own way to make it behave the way you like.

and lots of software systems are built this way. My paycheck is processed by an extension language designed by SAP, a company most of you have never heard of, but it's like the founders of billionaire like a lot of these companies, right? The idea is that it comes with a standard payroll system, but UCLA has a very complicated payroll. There's all these job titles and all these funny rules about people working in summers or not summers and all this sort of thing, so they have to program the payroll system in an extension language designed by SAP that's really good at doing payrolls.

Emacs Lisp is not that good at doing payrolls. You could do it if you like. You just have to write a lot of code. The idea is if you want to do something IDE like or editor like, there's a primitive in Emacs Lisp that will probably do something pretty close to what you want to do. And when it's not, which is common, you can fix it by writing some code. So this is a different attitude to a software development approach than what you were taught in CS31. In CS31 you were taught C++, you can write anything. Alright, well it fits in some sort of a niche, it's low level stuff, but whatever. You're writing code that can do whatever you like. Here, no, not really. We're designing this language so that we can write code for a text editor or software development or that sort of thing. Now, we have sort of other languages that sort of feel like this. I'll mention two or three. One is Java. For many years, the world's most popular programming language. Still very popular, mostly in back-end systems where you need high performance, you need reliability, and you need, you know, it's sort of big iron stuff, right?

Here, this sort of scripting language, in some sense, it's not really scripting, right? Because with Java, the attitude is very much, we want the code to be reliable, we're going to check it a lot before it runs. With most of these other scripting languages, reliability is, you know, obviously you want it, but flexibility and ease of use is more and However, Java contributed some important ideas that are used in many other scripting languages now. And these ideas are implementation ideas. In particular, it popularized the notion of taking your original source code, condensing it down to what are called bytecodes, which are, as the name bytes suggests, short codes that if you concatenate them together represent your original source code program in a machine independent way. And then once you have those byte codes you can ship them around to whatever machine you like and you can have an interpreter that is a program that can read in byte codes, it knows what they mean, it can execute the program, It can think of its program counter as pointing somewhere into those bytecodes. The next bytecode tells it what to do next. It's an interpreter that can run Java plus the idea of having a just-in-time compiler. The idea here is that if you see that you're executing some bytecodes over and over and over again, well, interpretation is pretty slow compared to C++.

will compile those bytecodes into machine code and then run that part of your program faster. This idea is now fairly commonly used in other systems. Emacs does it now, as well as JavaScript. This is a scripting language and a lot of times JavaScript uses this implementation nowadays. That is internally it stores bytecodes and then it turns those into machine code and all that sort of thing. You can think of JavaScript in a different way. It's an extension language for browsers. Just as Emacs Lisp is an extension language for Emacs, JavaScript is an extension language for browsers. Your browser doesn't quite work the way you want it to, so you program it with JavaScript to behave the way you want.

This is not the only way to use JavaScript. As we'll see later in this course, you can use JavaScript when there's no browser within 10 miles of here. But it's the most common way that it's used and that's sort of an important way of thinking about it. One other scripting language that we'll talk about at some length in this course, last but not least, is Python.

This is, by lots of measures right now, the world's most popular programming language. By some measures, it is now captured 25% of all mind share in the development community, which is a very large figure by historical standards. Right? And so this is like the big gorilla of scripting languages. My guess is three fourths of you already know about Python. Am I right?

My definition is if you haven't written 10,000 lines of code by yourself, you're not a Python expert yet. But you know, part of the goal of this class will be to get you more on your way in that direction. Right? So we'll see more about this later. But it's safe to say that Python is intended to be a general purpose scripting language in which you to hook together other people's code not the way that the shell does by running some processes by actually linking their code into your single Python process. And in that way you get some efficiencies that the shell can't give you. So in some sense it's perhaps a better way in many applications of configuring and running programs. And for that reason it is taken over a good chunk of of the artificial intelligence community. All right, so what do all these things have in common? First off, we want them to be easy to use. The focus very much here is on getting up to speed, getting newcomers into your software ecosystem as quickly as possible.

people to have to take a 10-week university course in your programming system just in order to write Hello World, the way you guys did in CS31. We want something better than that. And the idea is, you know, the more people that we use to write programs, the better off our entire programming ecosystem will be. At least that's the theory. However, it's safe to say that we We have some issues involved and the next issue I'll mention is plus and minus which is reliability issues. Scripting languages in some sense tend to be more reliable than the low level stuff that you were brought up with in CS31. If you mess up with a null pointer or a bad subscript in C++ your program, if you're lucky, will crash.

It will go give away your passwords to your worst enemy. It will trash your flash drive, completely erase everything on your flash drive. That's what can happen in a C++ program if you simply have a subscript error. Anything goes. That, in contrast, cannot happen in the shell or in Emacs Lisp or in Java or in JavaScript or Python.

more reliable than C++ because when your program goes bad they don't do any sort of random thing they want to. Instead they throw an exception or at worst they print out an error message and exit. They reliably tell you about the problem when it happens rather than maybe doing some sort of random stuff first and then you discover later that you've lost some of your data.

And that's one of the main reasons the AI types like Python. Right? They don't like programs that, you know, give them the blue screen of death. Python doesn't do that. However, there's a downside. And that downside comes from this easy to use business. If we make it really easy for you to write code such that pretty much anything you write down, as long as it sort of looks sensible, will that means there's a very good chance that the program will do the wrong thing. It's very easy in Python to write code that's completely bogus and Python will happily execute it. Whereas C++ will give you this annoying error message that might take you like three minutes to figure out what they're talking about. It's really horrible. It's off-putting to newcomers. But it increases reliability. That's why it's there.

So we have pluses and minuses about reliability when it comes to scripting. The third major area that I like to point to your attention when it comes to scripting is scalability. And by this I mean how easy is it to write really big programs? Complicated applications with a lot of code and a lot of pieces and a lot of moving parts.

Scripting languages have had real problems in this area. It's easy to write a five line program. Totally easy. It's pretty easy to write a hundred line program. Once you get to a thousand or ten thousand or a million or ten million and yes there are programs like that, I work on them all the time, scripting languages tend to run into issues. Part of those issues come from their ease of use.

two different parts of your scripting system that look like they're gonna work. And when you sort of put them in your system, the system happily runs them. But then in some rare circumstances, they screw up. That tends to be less common in more sort of picky languages like Java. Java code tends to scale better. And for that reason, you know, a lot of the Python action actually occurs in the AI world.

where the developers write relatively small pieces of Python code that's just being used to set up a bunch of low level C++ code. That's one way to attack the scalability issue. Try not to scale in Python itself because it doesn't scale very well. All right, so that's plenty of background on scripting languages. Before we plunge into one of them, any questions about these points?

Did I miss some important feature? Yes.

So if you're trying to create a language for a specific purpose, what's the process of doing that?

So for example, how was JavaScript invented? So this was the early sort of fertile days of the early 1990s. There was a browser called Mosaic, Mosaic developed at the University of Illinois, the first successful web browser, written in your favorite programming language, C++, and Mosaic at the time crashed a lot because hey, that's what C++ does. That was one problem. Second problem with Mosaic is the code was what it was. If you didn't like the way Mosaic worked, you had to download the source code. Luckily, it was available as free software You could change it, but then your copy of Mosaic would work different from everybody else. The reason JavaScript exists is people got tired of that. They didn't want to have to tell their users, "If you want to visit my physics website, you got to take the source code to the Mosaic, apply these patches to it, rebuild it on your system and run that modified version." Try to give instructions like that to Joe Random Physicist.

And back in the 90s they were totally clueless. So the idea was build an extension language for browsers so that we don't have to tell physicists all these funky details about how to modify their own browser. And that was the niche that made JavaScript take off originally. A lot of these scripting languages are kind of the same way. SH, the shell, started off as a scripting language for Unix because people wanted to configure Unix programs.

And then it sort of grew beyond that. Not sure if I answered your question, but I tried. Other comments about these big pictures? Yes? Rust is totally not a scripting language, right? Rust is for people who look at all of these languages and say, "Oh, I don't want that." Rust is for people who want to, they want to fix the blue screen of death problem, right?

to crash. They want the reliability. And they really want this. They want all the pluses without the minuses, right? And they also want scalability in a way that Python doesn't really give you. Other comments about this big picture? The comments are more fun than the lecture. Yes?

So to the extent whether a language is functional or the languages that we're talking about here are almost all sort of traditional languages, right? That's an independent access and you can sort of have functional scripting languages and in some sense there is a part of the shell that we've already talked about that really the way it's used is kind of functional. That is if I write this in the shell That is, I'm writing a pipeline, right? And maybe there's some arguments, right? That sort of thing. Then this is, you can really think of this as being a function that looks like this. Right? That is, you're applying the function A to standard input. You're taking the result of that that function passing that as input to B, you're taking B's output and passing that as input to C along with this minus N string. So in some sense the pipeline part of the shell, as long as the programs in the pipeline are only reading from standard input and writing the standard output or standard error, they're not doing anything else, that's a functional language. So in some sense we're seeing a little bit of that here but it's fair to say that the shell isn't limited to just doing this.

You mentioned that sometimes it's a problem to write Python to make the C++ happen underneath it.

Yes.

How does that work with JavaScript for a website? Imagine you start off small, but over time it gets bigger and bigger. Do you need Python for that?

People have hooked together Python with JavaScript. I've never done it. It sounds a little scary to me.

But, you know, the JavaScript folks have the same kind of solution that the Python folks do. That is, you can use JavaScript to run native code. And that's actually fairly common. So you can use, you know, JavaScript and Python in sort of the same kind of glue together other stuff mode. Question? Because the compiler checks your code better. That's really it.

It does a lot of type checking and other forms of checking. For example, in Python, if you, I don't know, throw an exception and there's nobody to catch it, that's valid Python code. In Java, if you try to pull that stunt, the Java compiler will look at you and say, you're trying to throw an exception and nobody will catch it. I won't let you do that. Go find a catcher, rewrite your program. So it does a much better job at looking for stupid mistakes in your code where the sort of the Python, you know, JavaScript, and most scripting languages, the attitude is, hey, if you make a stupid mistake, that's on you. I'm not going to do anything about it. Question? A program like which? Oh, performance? Yes. All right. We'll do that. Generally speaking, All the scripting languages perform worse than all the traditional languages. Right? The goal, that's not always true, but to a first approximation that's true. That is, you're willing to give up performance in order to get this other stuff. Simple example. One of the reasons C++ is fast is it doesn't do subscript checking. You write a sub i in your code, if i is out of range, tough luck on you. If you write a sub i in a Python program, the Python interpreter checks that subscript value at runtime and if it's out of range throws an exception. That slows Python down. And Python users are happy because they want something that's easy to use and reliable at least at the low level and they're willing to give up performance to get it. Yes? SQL or other languages in which you don't write programs You don't write code to tell the computer what to do. You just tell the computer what you want. You just specify the properties of the answers that you'd like. And you leave that up to the system in order to figure out. There are certain application areas, particularly database systems, which is where SQL lives, where that kind of approach actually works pretty well. Okay? And, you know, we have a whole course on that sort of thing.

CS 140 something or other 143 is it 142 anybody here wants to take the database course all right five people raise their hands I can tell it's not the most popular one in the world but yes there are sort of languages in that space I would not call those scripting languages I would call those you know query languages or data languages that sort of thing they have a different feel entirely other comments about the big picture. This is stuff you don't see written down in the textbooks. That's why we're here, right? All right, well, let's talk about Emacs, right? Here's an Emacs session that I've tried to make somewhat visible. Maybe if we do this, you can see it a little better. Would that help? No. All right. How about this?

All right, so here we are in Emacs and as I mentioned like two weeks ago or something like that, if you look inside Emacs, there's a bunch of low level stuff that are libraries, right? Like the C library and you know, I don't know, GTK library and all that sort of thing, graphics and that sort of thing. This stuff is all written by somebody else. It's not It's not really part of Emacs proper. It's mostly written in C and C++ and Emacs is sort of running atop of it. Atop of this, Emacs has a Lisp interpreter. I'll write it this way, Lisp interpreter written in plain C. Really low level code and the idea is that we want to be able to execute Lisp code as sort of nicely as we can. So if I type say, control XB and go into the scratch buffer, control XB and go into the scratch buffer, and if I type some Lisp code here, such as let's multiply 34 and 25, right? Then what's happening here is that I'm just putting characters into the buffer. No, this list code has not been executed yet. As far as the buffer is concerned, it's just a bunch of characters. Okay? And then if I type, so I type this, got into the scratch buffer, and then I type plus and some numbers, I've forgotten, 34 and 27, and then I type control X, control E.

That says please evaluate that thing. And what it does is at the bottom of the screen just where you can't see it, it says the answer is 850 and also prints it out in octal or hexadecimal. Alternatively, I can type control J and it will just print it out in decimal. Control J might be a better way of doing it so let's do that.

Recent Emacs Lisp expression that I've typed and that'll be a string. Take that string, compile it into bytecodes, let's say, and then go interpret those bytecodes. So we're seeing Emacs compile and run code right away without the bother of going through a compiler or anything like that because the interpreter and any bytecode compiler and all that sort of thing is built into Emacs.

Now, what we have here is a simple programming language called Lisp, which as you can tell, has a very different syntax from what you're used to. There are kind of two goals to this syntax. First, be as simple as possible. In fact, I would call it annoyingly simple.

that times has higher priority than plus. You have to tell it every time. It's so simple that this is the syntax that it uses for function calls. You put the function after the open paren rather than before because that way it doesn't have to worry about separating arguments with commas or anything like that. So in some sense you can think of this as being equivalent to say take the plus function and apply it to 34 and 27 except we just use this isn't the simplest thing we can do. We can also just evaluate 24, control J. What this did is it told Emacs, take that expression, the string 2 followed by 4, turn it into code and run the code. Well, that's pretty simple code, right? That's just the code 24, right? So it says, okay, the value of that expression is 24.

Another expression, ABC. Right? And I'll type control J. And I get an error. One of the most important things you should learn in learning any new sort of scripting technology is what to do about errors. What they look like on your screen and how to debug them and how to figure out what things are. The textbooks don't like to talk about errors because we're all perfect, right? And none of us like to making errors, particularly professors. Have you ever seen a professor say I made a mistake in a lecture? Just never happens, right? But we have to deal with that in the real world because we make mistakes all the time, right? So what mistake did I make? I tried to evaluate a variable called ABC. I told the interpreter, please construct an expression that yields the value of ABC.

that will evaluate that expression and I dropped into the debugger. The debugger said we have an error. The error is void variable which is emacs list for this variable doesn't exist. Right? And so what would you like to do about it? We are now in the debugger. Notice where the cursor is. It's pointing at the thing that failed. And it's also giving you a backtrace of all the functions that got called Right? A called B called C called D and all that sort of thing. So, command execute called call interactively, which called fun call interactively, which is all these guys. And eventually we called eval, eval called progen and progen said, I don't know what ABC is, what's your problem? There is a whole debugging mode available to us at this point. If you want to learn how to use it, you can type control H M and it will tell you all about the debugger mode. There's a whole chapter in the GNU Emacs manual that talks about the debugging mode. If your code always works, you don't need to read that chapter. All right? So the simplest thing that you must learn the first time you ever use the debugger is the same thing you have to learn whenever you get into Emacs in the first place, which is how do I get out of this?

The way you can exit the debugger is you can type control close square bracket. And when you do that, you drop out of the debugger. So let's do this. We type ABC control J and then we type control close square bracket. That means get out of the debugger mode. Now, when you're in the debugger, you could do a lot of stuff.

You can run further debugging commands. You can go and start editing some other file while that debugger is still waiting for you to do something. As you do those other things, you might make another mistake. In fact, might is too weak. You will make more mistakes. So it's very common when you're in the debugger to get yet another error. So let's do that.

We'll type control J A B C, right? We're in the debugger now. Now let's go over here and type DEF and we're in the debugger again, right? So what's going to happen here is you can be in the debugger several times and the way you get out of it is you might have to do this several times because the debugger sessions will nest. For some reason it didn't nest here. I'm not quite sure why it should have.

All right, let's try going into the debugger window and then say let's go further right. I'm not making it nest right. All right, anyhow, my nesting debugging session didn't work. But trust me, it can nest and when that happens you'll find you'll have several different nested versions of the debugger window with slightly different names.

to backtrace three, that sort of thing. And the way you get out of all of them is you just keep typing control close square bracket. If you type it too many times, like this, it'll say no recursive edit is in progress. That means we haven't sort of recursively debugged ourselves and so we're back at the top level. All right, so what other things can we do in this little language? Well, Since the name of the language is LISP, and LISP, the acronym, is short for list processing. What I should probably mention to you before we get too deep into it is how you do list processing in this language. By lists, I mean the following data structure. Here's a list.

It's a linked list in which the backbone of the linked list is a series of pairs. Always two things in every item in that list. The first thing is what the value is. And the second thing in each of these backbone components is the next guy in the list. Right? So here's value one, value two, three, four, here's value five.

And over here we have an end of list marker. In C or C++, the end of list marker is going to be the null pointer, which at the machine level is going to be all bits zero. Emacs uses a special value to mark the end of the list. This thing is the value nil, nil. So if we go here and type nil, and type control J. It'll say, oh yeah, NIL, I know what that is. It's hardwired into the language. Nil is a special value that means the end of the list. But just as C says null pointers are treated as false, right? If you have a pointer P in C++ and you say, if P, then do something. If P is the null pointer, it won't do it, right?

The same thing happens here. In emax list, this special value nil kind of has two meanings. End of list, which is sort of like the null pointer, and it also means false. It means something didn't work. So, for example, we can do something that looks like this. Equals 2, 3, or equals 3, 4. Control J. The answer is nil.

Well, because A, 3 doesn't equal 4. If, on the other hand, we have something that would yield a Boolean, equals 3, 3, the answer is T. T is a special value in Lisp that means true. And if you wanted to evaluate T, you type T, control J, to this system, it'll just say T, because, you know, T is something itself.

All right, so we have these lists. This is their basic structure. How do you build a list? You build it by building up the pairs. And the simplest way to build a list is going to be in reverse order. You start with this guy and then you build it later. So the standard way that you can create a single item in a list, just one node in that list's backbone, is with the standard function cons.

When you call cons of a, b, where a and b can be whatever you want, what the system does is it constructs a backbone entry of the list, puts b here, puts a there, and says there you go, that's it.

So cons is a pretty cheap function.

All the system has to do is allocate two words of memory, give you the address of the result.

So let's try calling cons.

And I'll call cons this way, cons three of cons four nil. So what I'm doing here is when I call cons four nil, it builds something that looks like this. That's nil, right? When I call cons three of the result, it looks like this. And that's what I get. That's a two-item list, three, four. The syntax, that LISP uses to write down this list as a piece of data is this. You write down a list by saying open paren, all the items in the list, close paren. No commas or semicolons or anything like that. So when we type this and type control J, that's what you get. Now, this is where things, if you're sort of You have to be a little careful here because we have two things going on here. Before the control J is the program, the list program. After the control J, that last line of output is the piece of data. And they kind of look superficially similar. It's parentheses with stuff in parentheses.

of thing about Lisp that makes it popular in AI. Programs kind of look like data and it makes it easy for you to write programs that will generate other programs. So let's see how to do that. There's one other data type I should mention that I'll need to do in order to get there. There's the data type symbol. Sometimes they're called atoms. A symbol in and emax lisp is an object. It's a piece of data and pretty much all we care about it is that it has a name and we'll write down the name and that'll be that symbols of value and all that sort of thing. And every symbol is distinct from every other object. So if we want a symbol we can write something looks like this. Apostrophe ABC is an expression that evaluates to the symbol ABC. And if we type control J at this point, there we go, there's an ABC. So if we want to write a data structure that looks like this, that's the data that we want. The way we can write it is something that looks like this. Cons of ABC, cons of DEF nil.

And that gives us a piece of data that looks like ABCDEF. And if we wanted to do something even fancier, we could say something that looks like this. Cons of 3. Cons of cons. Cons of 4. Cons of nil.

What's that going to eat? That'll look, oh, that's not quite what I wanted. Let's do something a little trickier. Let's do it this way. Cons of cons, cons of three. Now we're off to the races. What did I do wrong? This should not be an E, right? There we go.

So what I'm trying to do here is I'm trying to write a program that will generate this program as data. I haven't quite got there because I've forgotten an extra set of parentheses. So all right, we'll go down here and we need cons of three, CONS of all this.

And then stick a nil in here somewhere.

Oh. The problem was I typed control J at the wrong spot.

Let's try it again. There we go. All right. All right. So what I've done here is I've written a program that generates another program. Right? But it doesn't run that other program. It just generates a program and prints it out on your screen as a piece of data. All right. See how that works? Any comments about this sort of thing?

Can you do this in C++? Of course you can. You can write a C++ program that has a bunch of print statements in it that can print out another C++ program. Piece of cake, right? So in some sense, this isn't new. But in some sense, it is new because it's very easy to take this piece of data and go evaluate it. There is a built-in function called eval.

And so what I can do is I can run eval of this thing. And that will actually generate that piece of data as a program. Then go and run the program. Eval says I've got a piece of data. When you say eval x that's a piece of data. x is a piece of data. Please compile that into machine code or whatever and then go run it.

Yes? Is control J what? A control J is a command in the scratch buffer, right? Emacs is mode full so it depends on which buffer you're in. And it says, please look at the most recent expression that I've typed just in front of point and then, you know, parse that and execute it. And it means all that stuff together. So it's a fairly complicated command.

Other comments about this? Yes? Oh yeah, cons nil nil, right? So that generates something that looks like this, right? It's a pair that just has two nils in it. And one way you can write that is this, right? It's a list containing just nil. Or I suppose another way you could write it would be It's just that this I think is the way that the that this guy will do it. Cons nil nil. Yeah just says oh you have a singleton list and its only member is the empty list. Question. A vow on something bogus. Good.

idea. In fact, let's do it this way. First off, let's just try it running it directly. And what that'll do is that'll give you an error. Right? When you just said three, four, I want to evaluate that means I want to call the function three and give it the argument four. But three isn't a function. When you call something, you can only call functions. And so it says invalid function. Right? And if we do the same thing with eval, right? So we say eval.

CONS of 3, CONS of 4, nil.

Then we get the same error, right?

Because we're essentially doing the same thing.

All right, why don't we take a break, and we can start up again at the hour.

Okay.

All right, so we've seen some code and we've seen some data and I've sort of skipped over one of the standard ways to sort of switch back and forth between the two, which is this funny apostrophe. If you write, quote, in front of any expression in Emacs, this single quote, right? That means please don't evaluate this as code. Please just treat this thing as data. So if I write something that looks like this, that means don't try to call the function named ABC. Just give me the list, the three item list, ABCDEF, and that will be you know the thing that I want so I can put something that looks like this. And it will just give me that piece of data without evaluating it. And you know this apostrophe sort of means the same thing that a double quoted string means in C. A double quoted string in C means you just have a bunch of bytes here or characters. Treat that as data instead of as a program. But here The relationship between program and data is sort of closer to how you would write a compiler or something like that. And so we can take any sort of piece of data in Lisp and just write it in our program by prefixing it with an apostrophe. There's one other bit of notation I should mention, which is suppose you do something that looks like this.

By convention, if you have a list in which the last thing in the list is not the empty list, it's something else. So you have a list that looks like this. That's not nil. This is called an improper list because it's not really a list. And EMAC signals that to you by writing it this way.

dot space in front of that last thing. This is the textual representation of this. All right? I mean, in some sense, you could write any list this way, right? d e dot nil. All right? That's equivalent to saying d e because it really means something that looks like this.

These two notations mean the same thing. No one will ever write this. But if you do, that's what you're writing. Okay? And so, you know, we can do that also with quoting, right? You can say something that looks like this. Quote 3, 4, 5, right? And that gives us, ooh, I messed up. Got to put spaces around that period. Otherwise, It looks like a floating point number. So let's try it this way and we'll get the improper list 3, 4 and then the tail of the list is not the empty list it's the number 5. Alright, so let's take a look at all of our data types in EMAC.

You can define your own types, but it's sort of useful to know what the built-in types are anyway. The first is numbers. And these include two kinds of numbers, integers and floating points. The floats are what you would call double in C or C++, so they're 64-bit floating points.

The integers in Emacs are arbitrary precision. So they're not limited to 64-bit integers or anything like that. They'll grow to be as big as you like. You can do something that looks like this. And it should work. Oh, you have to write it this way, of course. And sure enough, you get a big integer.

That's not a floating point number. It's not approximate. It's the exact integer. Here, Emacs is giving up efficiency for reliability. A big problem with programs in C or C plus or Java or that sort of thing is integer overflow. Integer overflow bugs are a common source of attacks in low level programs these days. And for that reason, many scripting languages, including Emacs Lisp and Python and that sort of thing now have integers that don't sort of overflow. That way you avoid those sorts of attacks. There is an efficiency downside of this of course. To represent a big integer like that it's going to take several words of memory. So internally that's represented as a big array of bits but the system will keep track that it's a number and you know be able to multiply and divide it the way you would do any other integer.

Arithmeticatic. Alright, the next sort of thing is you can have strings. And strings in Emacs have a syntax that you're probably used to, right? You can put funny characters if you like. Ooh, what character is that? And we now have a string.

Yes, question.

What happens if you try to divide two integers and you don't divide equally?

It truncates.

So you can say something like this. Divide this by 13 and you'll still get an integer.

If you want floating point division, just make one of the values floating point and then it'll do floating point and the answer will be approximate.

All right, notice that strings can contain new lines. You can write the new line with backslash n, but when Emacs prints out a string, it just outputs the new line as is. All right, question? Is there a way you can make the floating point numbers? No, they're always double. If you want to do sort of high-performance scientific computing in which some of your floating point numbers are only eight bits wide, the way the machine learning guys like to do, EMACS LISP is not your language. Other comments on simple stuff, strings, numbers, and all that sort of thing. I mean, there's all sorts of built-in stuff you can do. Format, string, ABC, %D, EFG, %G, that sort of thing. Yeah, like that. 345, minus 0.5, something, right? So you can, whoops.

the wrong function. Is it string format? Let's try this. APR is short for apropos. And we'll try format string. Oh, just format, of course. We'll get there. So you have functions that behave like print of. Here we interpret it as string according to a format. So the sorts of things that you're used to in C++ or Python or C also exist in Emacs for strings. We've also talked about symbols. You can have as many symbols as you like. Just give them names, whatever you like. The important symbols that I've already mentioned are nil and t. Some of the others are important as well, but these two really stand out in terms of what they mean for data. We have pairs or sometimes called conses. These are the basic sort of objects used to build lists, right? If you like, you don't need to create an object, a pair with just two items. You can create vectors as well, right? So a vector Oh, is it make vector? When you have a function here, you can just type control HF and it will tell you a control HF return what function that you're sort of thinking about and what it means. So we can type make vector of 30 and I don't know, ABC, why not? And this creates a vector of 30 ABCs.

The entry in the vector is an ABC and later on we can change the vectors contents to be something else. So we have vectors if you like. These aren't used all that often to be honest because lists are more convenient than vectors. They take more memory, they're worse in many ways, but they're convenient, they're easy to build up. Then there's everything else.

include things like the following: hash tables, character tables. A character table is a hash table except the indexes are always characters so they can be implemented more efficiently than ordinary hash tables. A marker is a pointer into a buffer and as you edit the buffer the marker moves along.

So it stays sort of if it was between the words x and y the marker keeps pointing into the words x and y instead of just sitting there as you know x and y be shifted left or shifted right right. So this is a pointer to a buffer location. That's a very important sort of thing in Emacs. Let's try to create a marker here.

Well, for example, if I just type point, that's a standard function in Emacs. If you call point, it takes no arguments, so this is a call to the function point. Point will return something that's not a marker. It's just the number 1136 which says when we called point, point was at the 1136th character of this buffer. But you can also create a marker and it's probably make marker. Let's try that. And what this does is it creates a marker that points into our buffer that if we grabbed a hold of that marker and kept it around, we could then later go back to where we were in that buffer even if part of the contents of the buffer changed in the meantime. So as an aside, suppose you have an emacs value and you'd like to save it in a variable. Here's how you write an assignment statement in Emacs. Whatever value you like here, you will set the value of the variable ABC to be that value. So here we can say set QM to be make marker. Now we've created another marker, right?

and M is now that other marker. This marker is not in any buffer. If we wanted to make it a marker into the current buffer we'd have to pass another argument to make marker. Let's see what other objects do we have. We have buffers themselves. A buffer is an object in Emacs and you can get the current buffer by calling the function current buffer and that gives you the object that basically it points at the current buffer. Emacs displays the values of these special objects with this funny notation. Sharp sign, less than, a bunch of stuff, greater than. That doesn't mean you can type in this syntax to Emacs. This is purely sort of a, you can read these objects on the screen but you can't sort of write them. But as long as you sort of save it somewhere, right?

"setq_b you can have a function called say switch to buffer to use it. We'll get there. All right so here's a buffer switch to buffer buffer or name we can say switch to buffer buff right and if we were in some other buffer that would change Emax's attention to point back to the current buffer. Here we were already in the same buffer so switch to buffer didn't do anything. Question? Right so a symbol is an object with a name and there's nothing important about that object other than it has that name. There is no other symbol with the same name and the object is distinct from all other objects. So you can think of symbols as naming a number of points in the universe, right? Each one of the points is distinct. No two of the points are the same. If they have different names, they're different points. If they have the same name, they're the same point. That's all there is to symbols. There's nothing more than that. Now, that being said, you can use symbols, pairs, strings, and numbers.

to build up a data structure and then say this data structure represents my program.

So when I write, well, I wrote something that looks like this, right?

SetQBufCurrentBuffer.

I could have written something that looks like this, right?

Here's the symbol setQ.

Here's the symbol buff.

And I can say, all right, let's do a cons of setQ and then cons of buff. And then here I will say I want to build that current buffer. So, all right, cons of cons of current buffer nil. And what did I do wrong?

Oh, I forgot another nil here. We need a nil here. And basically I can build a data structure that represents that assignment. When I did that, buff is just a symbol. This last line of output says I have a piece of data and here's what the piece of data looks like. Set Q, buff, Current Buffer. Current Buffer. Where Current Buffer is an atom. Right? So I've constructed that piece of data, but that piece of data represents a program. So when you think of a piece of data as representing a program, a symbol often represents a variable name. Doesn't have to, but in this case, you know, we have this data The data structure here has three symbols. This one represents a function name, variable name, variable name, I'm sorry, function name. These are actually symbols as well, right? Because they're nils. And these just say I'm the end of the list. Right? So a symbol is just an object. It has no special properties other than its name. But you can build up more complicated data structures that use those named objects to represent programs or anything else you like.

Question. What's the difference between doing the con stuff and just running the command straight up? Oh, well, because here all I've done is I've built the data structure. Normally, I wouldn't do it this way, by the way. I would just say this, right? I'd take the piece of data that I want and I'd say, oh, can you please quote that and give me that piece of data? So normally I'd do that. But if I want to actually run the program as a and I actually execute the code. Other comments about this? In the back, yes. Louder please. In some sense it's no different, right? That is, what we have here is in Emacs there's something that will take this text Compile it and run it. Okay, but the difference is that in this particular notation, the distance between the textual representation of a program and sort of a data structure to represent that program and the program itself, that distance has shrunk. It's easier with this notation to write a compiler because when you type that piece of data in your program, it's already parsed for you automatically, right?

Whereas if you were doing this with C++ you gotta sort of figure out oh here is the++ what do I do with that all that sort of thing here in Lisp it's just all built in the thing that parses data also parses programs yes oh that's a good point let's see if we can do something different all right so here's when you might want to use cons so Suppose you have a global variable called n, which is a thousand. Suppose you wanted to do something like this, cons of, I don't know, set q cons y n. Oops. We'll get there.

CONSEN, CONSEN, N, N, N, right? All right. So what I've done here is I've used CONS in which most of the things are constants, but one other thing is a variable, right? Whereas if I tried to do this with quote and said set Q, you know, Y, N, right? I will just get a data in which n is still a symbol, right? It's not the value 1000. What I wanted was set Q of y1000 and I didn't get it. So cons is more flexible and more powerful. With quote, you kind of only get data. Cons lets you sort of interleave some data with some expressions that you evaluate. Question? So when you write apostrophe in front of any expression, and less. It can be anything you like. That's equivalent to saying don't treat this expression as code. Just treat it as data and give me that data. So this means don't evaluate E. Just give the data. Leave it as data.

A, B, C, X, Y, Z, and type control J, it'll say, oh, there's no variable by that name because I tried to evaluate that as a program. But if I type apostrophe, the same thing, and type control J, it'll say, oh, yeah, it's just a piece of data. I'm not evaluating it. It doesn't have to be a valid variable name. It's just a symbol. Question?

What does set Q of A, B is equivalent to saying set of quote A, B? Right? And that's why it's called set Q, right? Set basically says the first argument, has to be an atom or a symbol I should say that names a variable. The second argument is the value that you want to assign to that variable. Right? So that's what you mean by set. But ordinarily I don't use set very often and most people don't. I use set Q because I normally, you know, know the name of the variable that I want and I just want to set it. Okay. Other comments about what we've seen so far. Question.

The scope of apostrophe? How far does it extend? It extends through the next expression, right? So if you say something like this, right, that means we're quoting the very next expression, which is that AB two-item list, but we're not quoting the N. So since N is 1,000, N gets evaluated, and so we get this The pair whose first item in the pair is the two item list AB and the second item in the pair is the number 1000. Question? In this last case how does it know that the expression stops with the? Basically it just parses the next expression and an expression is either going to be something really simple like a single number or a string or something like that. But more commonly it's going to be a list in which case you'll see the apostrophe in front of an opening paren and then the matching close paren ends whatever your quotas. Question. So when I'm writing So what? If I type something that looks like this, can I type control J here? No, like here you are writing a stack here expression in a link to... This one here? No, no, like you don't want to go. This one, okay. Yeah. So could I write control J for a piece of data that looks like this? Yes. Well, yeah, in fact, I did something like that already, right? So I did right up here. Oh, well, no, yes, Yes, I guess I could. So I'll go right to here. I'll type control J and then that did get evaluated. Other comments? Yes. Apostrophe N says take the thing after the apostrophe and just don't evaluate it. It's a symbol. So just give me that symbol. If you ordinarily write N, you're writing down a symbol and you're telling it, please take this symbol as code and go So parse it, figure out which variable we're talking about, give me the value of that variable. All right, question? Is n and n in parentheses the same thing? Oh no, and that's a good point, right? In C or in JavaScript or in Python or in most programming languages, these two mean the same thing. You put in extra parentheses and okay, they're extra parentheses.

but you know maybe your code's clear this way or something it doesn't really matter. In Lisp every pair of parentheses means something. So you can't use the rule when in doubt put in more parentheses. No, no, no, no, no, no. If you put in more parentheses than you want the code will do something different from what you want. This says give me the value of the variable n. This says please call the function named n with no arguments. Function call is left paren.

So here's a function called with no arguments. So you can't just throw in extra parentheses when you're in doubt here. Every paren counts. All right. So let's see what other things can you have. Well, buffers, you can have things like frames and windows. I've already talked about these. Frame and window. Right.

that any sort of reasonable text editor would have, you have sort of an object for that. They also have something called an X widget. And they have terminals because Emacs can connect to more than one terminal at a time and all that sort of thing. Let's see what else. We have fonts. That'll be an object. You don't need to know about all these objects and use all these objects. To some extent I'm giving you a feeling for the kinds of things that you would want to have in any sort of You also have process. This is when Emacs is running some other command underneath it. So in effect when Emacs is acting like a shell or when Emacs starts up the shell that's going to be a process that's running under Emacs and there'll be an object represented that. But then there's one other kind of object that I wanted to mention a little bit more.

And that type of object is, well, I'll write it up here, the function. In Emacs, a function is just some other object. And you can write down an expression that yields a function with something like this.

times of plus x, y, y, something like that. So this is a function. We can, you know, then take that function and call it with arguments. 59 or 57, 900, whatever, right? And what we've done here is first we've built an object.

with this thing called a lambda expression. And then we turned around and said, oh, that's a function. Let's call that function with the two arguments 57 and 800. So what's happened here is x is bound to 57, y is bound to 800, and we evaluate that arithmetic expression in a little context where, you know, the function body is being evaluated, and then you return the value that the function would have returned.

This sort of thing is done all the time in Emacs. You don't have to give function names. You can just write lambda expressions. The idea of having nameless functions was first invented in Lisp and it's now spread to other languages. So C++ now has them, Python has them and that sort of thing. But they were here first. Of course, if you want to, you can give function names.

So you can write a function. In fact, instead of me writing a function, let's go look at one. So suppose I want to find out, I don't know, let's see, which idea would we like here? Let's try control X for B, which is switch to buffer and other windows. So we can switch to the control X for B.

Suppose we're interested in this operation in Emacs. We can find out about it by typing control h k, control x, 4 b. Control h k says, give me help about the following set of keystrokes. And this will say, please tell me about what these keystrokes do.

And what it does is it runs the command switch to buffer other window.

Which is what in Emacs is called a command window.

Every command in Emacs, that is everything that a set of keystrokes or mouse movements or whatever does is written as a function, right? So commands are implemented as functions.

Not every function is a command, like cons, that's not a command, that's just a simple function. But every command is implemented by a function. If you want to find out about that function, you can just go to this help screen that we looked at, mouse over to, you know, window.el, which is where the source code is, hit return, and you will be looking at the source code to the ELISP part of EMACS. That is, we're looking at the definition of the function that implements this command. So if we type control X1 here to focus on that window, we'll see first off by convention when you define a function, if the first thing in the function is a string, that's going to be the The first line of the function says defan, left paren defan, right? And then the name of the function and then the arguments in parentheses. That ampersand optional that's sort of highlighted in green says everything after the ampersand optional keyword is optional. You can pass that argument or not pass the argument. If the caller just passes one argument to this function, function, the optional values are nil. You can pass the extra argument and then you can specify the extra things that you want. The way you can tell that a function can be used as a command is if the first thing after the documentation looks like this, that is, it says interactive of something.

It could be as simple as this. More typically it's something like this. This tells the ELISP compiler that this function is intended to be used by the user by typing keystrokes. And those keystrokes can affect how the function behaves depending on what the arguments to interactive are. Right? So in particular this interactive specifies right after the word interactive that Oh, if someone types this command, please prompt with this prompt and then go read a buffer to switch to, right? And what interactive will do, will make sure that the user has done all that before this code starts up. Once the function starts executing, it executes these two lines of code, right? And then particular, that's a new notation I have I'll do that now. If you say something like this, this means evaluate E, bind its value to the local variable X, then evaluate F in a context where X has this value, right? So if I were writing it in C, it would look something like this. Object X equals E, return So this notation roughly means this. Evaluate e, call it x, and every time you see an x in here, that's the value that you got up here. So what we do up here is we set the variable popupwindows to t, and then we call pop to buffer with our argument and the value true and the argument no No. This is sort of the common sort of indenting convention. And Emacs, if you write list code and, you know, it'll sort of indent things for you automatically. But it's like C in the sense that any white space will do if you have to have white space. Question.

Pop up windows. Oh, yes. This form of let is a little bit, all right, so actually this isn't quite right. A better translation would be something like this. All right, that is we have a global variable called x. We temporarily saved its old value. We then evaluate this expression.

object V equals F and then we set X to be the old X and then we return V. So let's is a little bit can be a little bit more complicated. Sometimes this is just a you know a local variable right but in this case we are temporarily suppressing the value of a global variable and once we're done then that value will pop back to what it used to be.

Other questions about this code? Yes? When you say like evaluate e, like using a, like a.. E can be any expression, right? And, and Emacs expressions typically are surrounded by parentheses, right? So it's a function call of some sort. Question in front? Yeah, so like when you're saying like buffer function, is it data types or are they like just other.. These, these are all particular data types for various options.

that are built into Emacs, yes. Question? Sorry, why would the inside parentheses be full function next to the algorithm? Oh, why do we have two sets of parentheses here? Because in general, you can do, it's going to be a list. Right, so you can say let X be E and let Y be F and then go evaluate G in a context where X and Y have these two values.

And so, you know, this can be a list of names and values. If you only want to do one, well, then the list has just length one. And so you have two parens around it. And every paren matters. So if you forget, and you type it this way, then what you're doing here is probably not what you want, right?

No, when you do this. Let's go back to our scratch buffer. What that means is. So list is a built-in function. You can call it with whatever arguments that you like. It gives you a list of length n where those values, you know, are the arguments that you specify.

and this gives us a list of three nils because each one of these guys has turned out to be an identifier whose value is nil because that's the default value for identifiers in lists. So if we leave off the parentheses we get perhaps something that we didn't want. Yes? Louder please. Why didn't we get an eval of the x, y, y?

Why don't we need the key one deval for the.

Oh, I see what you're saying, yes. So in some sense, how should I say it? We have sort of ordinary function calls, which have this syntax, right? With as many things as you like, right? And you can kind of put whatever you like in here, right?

But there are what are called special forms. They superficially look like function calls, but they're not function calls. And the way you know it's a special form is that this first item here is a keyword. One of the keywords is lambda. If you write something like this, this says, oh, please don't evaluate this code as is.

This means just give me the function without evaluating the body, right? Another special form is this, right? Well, no, it's going to be something like this. Quote ABC. This special form says don't evaluate this, just give me the value as a piece of data. And these two things mean the same thing, right?

The special form that we've seen is defun. Defun means please define a named function. The first thing here is going to be the name of the function. And you saw an example of that on the screen. So there are some special forms. You have to know what the keywords are to see what those special forms are. When you see a special form like lambda, you have to remember the stuff that comes after here is not treated like a function calls arguments. Instead, you have to know what the rest of this special form will do. A Lambda special form basically says, "Don't do anything right now. Just give me the function that all this code stands for and I'll call the function later." Right? So this special form runs really fast. All it does is it gives you internally the address of a bit of machine code. This special form runs pretty fast too. It just gives you a piece of data that's already there.

So most special forms by themselves are pretty fast when you just execute them, but then when you look at what they do later, they might, you know, take up some time. Question? If I write just this, at the top level, That's a function call. But if it appears in other contexts, it can mean something else. If I write this, then all of a sudden it's not a function call. It's just, x is just a symbol in a list of three symbols. If I write this, right, it's not a function call.

It's not a piece of data. It's merely the arguments in a function, right? So you, you know, if you say, well, how can you tell what this means? The answer is going to be, it depends on the context. Question. Yes.

Yes.

So, for example, you can do something that looks like this.

Let S be XYZ in, I don't know, cons of S3.

So what we've done here is we've said, please evaluate this expression.

That gives you a three-item list with three symbols as its members.

call that three item list S and then go evaluate this code.

Okay, other questions? Yes?

Oh yeah, this the scope of this S just extends into the body of the let, right?

It doesn't go outside the let and it doesn't extend into its initial value either. Yes? Oh, because if you have some variables and inside, so the first thing in let is going to be a list of bindings. A binding can either just be a symbol, in which case that symbol is bound to nil, or it being, left paren, symbol name, initial value, right paren, in which case the value is bound to the value of that expression. This particular use only used the former. We could do both, right? So we could say something like this. Let x and let y be 12 and let z be, I don't know, times of 317, right? And then we can say here, list. Z, X, Y. And so you get Z is 51, X is nil because we didn't specify a value for it, and Y is 12. All right. Other comments? All right. Well, let's do, let's see. Oh, I forgot to do a couple other functions that are important.

Here's a standard function.

And another standard function.

X has to be a pair.

The car of X is the first item in the pair.

And the cuder of X is the second item.

So if I do something like this, that's going to yield A.

Because the first item in this list is A.

If I call Kudder of ABC, well, a list of three items is represented as a pair, where the first item in the pair is A, the second item in the pair is the list BC. So this evaluates to BC. The name Karr and Kudder came from the machines on which Lisp was first implemented. The way I remember them is, true story, I was driving a along Sunset Boulevard behind someone in a brown Mercedes. I can still remember. It's sort of the brown Mercedes that a dentist might drive. I love dentists. But anyhow, on the back of this car was license plate. All right, so here's the car. Here's the rear tires. Here's the license plate. Here's the rear window. And the license plate said CDR.

which was probably the driver's initials. And what that meant was the tail of the car was the cuder. If you want the head of the list, that's the car. If you want the tail of the list, you get the cuder. That's how I remember it. But you can remember it any way you like. Okay? Other comments about these functions? All right, we've probably done enough Lisp. I wanted to do Python. We'll have to wait till next time for that.

