So, if I were disciplined in academic the way a professor should be, I would be covering three topics one at a time.

We have scripting and in particular we have the shell. We have integrated development environments or IDEs for short and in our case we're using Emacs. And we have file systems which in our case we'll be using a Linux file system or a Linux based file system. And I would go through one topic get it all completely and then do the next topic and completely, but I'm not going to do that. Instead, I'm going to sort of dump you into all three things at once. To some extent, this is the typical experience you'll get when plunging into a new software system. If you end up going to work for Amazon or somebody like that, they'll throw you into a project. They'll say, here's five new software technologies you haven't seen before. Learn them all at once. And you can come to me for help. So to some extent, I'm trying to replicate that experience here. It's not simply that I'm too lazy to organize things. I'm trying to be kind of realistic about it. There's another thing going on here, which is that these technologies were not developed one at a time. It's not like we went and did file systems first and then we said, okay, now that we've got that done, let's go develop scripting and so forth and so on. No, no, no, no, no.

These things got developed roughly at the same time. And advances in the shell caused us to make advances in file systems and vice versa. So to some extent the way we're covering it in the lecture today reflects how the systems were developed as well as how they get learned. At least that's the theory. So if we're going to do three things at once we could start with any one of them.

What would you like to start with? Any votes? I'll do stuff in some random order, but if we have maybe, would it be too much to ask people to raise hands here and say which you would rather see covered first? Shell? Emacs? File systems? Oh my goodness.

What am I going to do? Well, I'm going to sort of flip a coin. Actually, not exactly flip a coin. I'm going to do the stuff that I've been hacking on the most recent. And so the most recent thing I've been working on is Emacs. So we'll take a look at that. Sorry, the two-thirds of you that wanted me to talk about something else. Sorry about that. But we'll get to these other things eventually.

And my background here is I started off as a Vim guy way back when I was your age. And I got sucked into Emacs because I needed to build some real software. I was making money. I wasn't an academic. I was an industry. We needed to build a software development environment for a new programming system, whatever it was, logic programming databases, details.

don't matter. We need to do something fast. And we could have told people, oh, just run VI, because that was the Vim ancestor available at the time. But the problem there is that's just a text editor. It wasn't very programmable. You could program it somewhat, but not really. Whereas Emacs had a programming language built into it that let us build an IDE suitable for our logic programming system and all that sort of thing. And it only took us like a month to get it working. It was so much a better choice that I kind of got sucked into Emacs ever since. And currently I have, I think, 7,000 commits into Emacs, which tells you I've spent too much time working on this system. So I'm nakedly explaining to you my bias here. Right? Sorry, you know, I kind of really like this system and I have for a long time.

But it's not simply that. It's that it's programmable and it works, plays well with others and you can easily hack it to sort of do what you want. We're not going to see a lot of that in this lecture. In this lecture, I'm mostly going to focus on how it gets used out of the box without you programming it and it's going to be a little off-putting at first because they are entering a different software and you don't know how people talk or what they say and so you're going to have to sort of get used to the program. So the idea here is to get you over that hump and get you into saying oh well this is kind of weird but now I know what I'm doing and that sort of thing. So if I were teaching this sort of in the experiential way I would start up Emacs and we'd start doing stuff but I'm an academic So I'm going to do a little bit of the theory first here. Not a lot, just enough to get us going. All right. So here we go. In some sense, Emacs grew out of the job of being a text editor. Right. And sort of our fundamental problem here is we're building an applications that need to do several things. And I'm focusing on text editing first.

but this is going to be true of applications in general. First off, we want them to survive. In particular, in the simplest model, we want them to survive power outages. This can be your laptop running out of battery and it dies or it can be your desktop being plugged into the wall, the power goes out, it can be a server, servers We want our applications to keep sort of not working. You can't work when the power goes out. But you don't want to lose all the work that you've done. Right? And so that's one thing that we want to happen. The second thing is we want them to do things quickly.

We want our applications to run really fast when we type something or mouse over something. We want it to happen right away. We want it to go sort of as fast as we can. Now notice these two sort of things compete. It's easy to do one. It's easy to do the other. It can be hard to do both things at the same time.

The third thing that we want, and this one's less obvious to outsiders, but since we're all computer scientists in this room, I can share this little secret. We want our applications to be understandable. We want to be able to look inside our apps, figure out what they're doing, because a lot of times they don't do what we want.

and we want to be able to make it easy for us to change them, to do what we want with a minimum of effort. Right? And as I kind of hinted already, but I'll say it one more time, these three things are all somewhat competitive. Right? It's relatively easy to do any one of these three. Trying to do two of the three makes it harder. Trying to do all three at once is going to be kind of a steep climb at least for many applications. So I want to first talk about this one. The technical term for this is persistence. We want our applications to be persistent and ideally you'd be writing some C code here. It's probably going to be longer. Number of students.

So you're writing your C++ code and you modify this variable. Ideally it would be something like this. We would just tell the compiler that this variable, which counts the number of students in our course and all this thing, we want that variable to survive power outages. So let's invent a new keyword. I'll call it persistent. So the parts of your program that you want to sort of keep, The value of that variable survives power outages. When you start up the program, it has the value that it had just before the program crashed or exited last time and all that sort of thing. If we could have that keyword in C++, we'd go a good way to solving this problem, right? Because we could just put persistent in front of the variables that we need. Can you see a problem with this approach? It's been tried, by the way.

Right. We have performance issues, right? If we really had a keyword like this, then every time you did something like this, number of students plus plus, right? The program is going to have to say, oh, well, that's persistent. Oh, well, I better save this on a flash drive or on disk drive or save it on Google Drive somewhere. And that's going to take milliseconds.

to do. Right? And maybe if you only do that once every 10 seconds, no big deal. But you know how people write code. They put this inside a tight while loop or something. You're adding, you know, loading up students all the time. And every time you load up the student, you don't want to just count one, add one to the count. You want to add some details about the student. Like the student ID, the student name, all those sort of things. You're going to store those in persistent variables too. And that means every time you change any one of those variables, kaboom. It's going to take milliseconds. It should take nanoseconds. Right? What's the difference between milli and nano? Quick. Your engineers. Right. It's six orders of magnitude. Right? You guys know all this stuff, right? All right. Excellent. All right. So we want to attack this problem, but we want We want it to go fast. And for that reason, we're not going to do that. It's going to be too slow. We have this problem when we're running Emacs. I'll illustrate. So I'm going to log in. Well, I'm not going to log into CSNet. I'm going to be lazy and just run Emacs on this laptop. And I'm going to start typing. Hello there. How's it going? Now notice, while I do this, things are going pretty fast.

So what's happening here is that Emacs draws the distinction between a buffer and a file. A file is persistent and in Emacs it'll store information in files and since we're running on Linux it'll be a Linux file. If you save the stuff into a file it's going to stick around. Whereas a buffer is not. You can just think of it as sort of a character sequence in memory. The two concepts are distinct. Sometimes there's a close relationship between a buffer and a file and sometimes there's not. In this particular case, when Emacs starts up, by default, there's not much of a relationship. Oh, I see we've missed out part of this.

Let's go down a little bit so you can see the little bottom here.

Oh, excellent.

Alright, see, so up here we see the name of the buffer that we're looking at.

This buffer is the Scratch buffer.

That's the buffer that you start up Emacs in and it's intended to not be in a file.

That's why it's called Scratch, right?

If I were to exit Emacs now or if my laptop were to lose battery, I would lose all my work in the Scratch buffer.

But that's okay. We know that and we're going to adjust our behavior depending on that. And to some extent, it's okay. Like if I'm very concerned about privacy and I don't want people seeing what I did, then putting it in a scratch buffer means it's not going to be saved into a file and so when I turn the power off to the laptop, I know the information is gone.

Laptop using hardware means I don't want to talk about. All right. So that's one technique we want to do is we want to distinguish between buffers and files. But we also sort of, we want to sort of hook these together. So we start off in the scratch buffer. But I want to sort of go look at what's in a file and then maybe go I go change the file so in order to do that I visit the file when you visit a file what emacs does is it creates a buffer whose contents exactly match what's in the file right so you've copied files contents into a buffer and to help you keep track of what's going on that buffer's name is going to be the same as the base name of the file. That is the part of the file that comes after the last slash. Right? So it's named after the file. To tell Emacs to do that, you issue the visit file command. Right? Well, I can say control X, control F, or the find file command, I should say. Control X, control F, and then file name.

So let's visit a file named hello.text, right?

And here we are.

This file didn't exist already, so it starts off being an empty buffer.

If the file already existed, I'd be looking at the contents of the file.

Now, as I type, right, adding text to hello.text, What's happening here is I'm modifying the buffer, but I'm not modifying the file. And that's for performance reasons, which I hope are pretty clear by now, right? We are not actually changing the file because if every time we typed a character, we changed the file, that would be too slow. I'm a fast typist. I don't want to see that sort of thing being slowed by echo because my flash drive is temporarily busy doing something else. All right.

Now, we have a problem. The contents of the buffer don't match what's in the file. In some sense you can think of the buffer as being a cache and the file as being the permanent state and our cache does not exactly match. Suppose at this point Emacs were to crash or I'd lose power to the laptop. I'd lose all my work I won't. There's something else going on. And to see that, what I'm going to do is I'm going to go into the shell here. Well, actually, let's try this. Control X 4D. I think that's what I want to do. Control X 4D. And what this does is it says, dir ed in another window.

So there's a couple of new concepts here that we have to go through. First off, I've talked about buffers and I talked about files, but there's a third thing I should talk about, which is windows. When EMAC starts off, you start off in one window and you can see that big rectangle, that's a window into your buffer. You can see not necessarily everything that's in the buffer, but enough to fill up about 40 lines here. But you can have multiple windows.

and decide to run some command here which I'm about to do and we'll look at this in another window. Right? And what we are now looking at is something else in another window. It's from a windowing system point of view this terminology is a little weird. Right? Because you think of that big rectangle as being a window. But Emacs uses a different terminology for window. So you can think of this as being part of a frame and frame is Emax ease for what most people would call window, right? So it's a window if you're talking in Mac OS or Linux or that sort of thing. The Emax folks have stubbornly used different terminology because they said we were there first and indeed they were. This stuff was all developed in the 1970s before modern windowing systems existed.

So we now have two windows visible. One is the window for hello.text and the other one is the window for our directory editor. So I've talked about windows, I should talk about DURin. That's short for directory editing. Emacs is a programmable editor, which means not only can you edit text files or C files or sort of ordinary stuff like that. You can edit directories. What is a directory? A directory is a file whose entire goal in life is to let you find other files. So a simple model of a directory is it's just a list of files. And here you are editing this directory. Internally the directory is some low level binary data structure. We don't know what it looks like.

But Emacs converts that internal data structure into a textual representation, which you can see here, and you can edit this text as you like, and that will make the corresponding changes in the underlying binary data structure that represents the directory. So this directory editing window operates somewhat differently than the text editing window, because you You can't make arbitrary changes to this text. It always has to be sort of lined up like that. And also, you're not editing a text file. You're editing a directory. So it works in a different way. What's going on here is another Emacs concept called modes. And one way to think about that, well, the phrase here is Emacs is a modeful editor.

What that means is the way it reacts to you doing something depends on its internal state, which is called a mode, and different buffers can have different modes. Here we see two buffers in two windows on the screen. The top buffer is called hello.text. The bottom buffer is called egert. That's pretty boring, but that's what it's called.

to this other buffer and I can do that with control X O. That means switch to other buffer. So I'll go over here, I'll type control X O. If I go into this buffer and I just type a D, well it's a text file. You type D into a text buffer, that means please insert the character D. But if I were to type control XO again and go over to here and I type D, it does not insert the character D where I typed it. Instead, it puts a big capital D at the start of the line, which in DUR-ED mode tells you, you plan to delete this file. You haven't done it yet, but that's your plan. You want to delete it. So the same character D means something It's completely different in DURAN mode than it does in text mode. Now, if I want to actually delete the file, so here we are, we're talking about DURAN mode. So D means mark for deletion. And then if I go over here and type X, it'll say X means please execute all the things you plan to do.

And since deleting a file is commonly considered to be a big deal operation, you gotta be very pretty careful if you're gonna delete a file. Emacs carefully says here, "Do you really wanna delete that file?" Yes or no. And because it's so careful, I can't even type Y. I have to type Y-E-S enter and then it's finally made the edits that I wanted. So to some extent what's going on here is it's an emacs is a tool for building editors of various kinds of things that you want in your system whether it's a text file which is sort of the way it started or a directory or a whole bunch of other things that we can talk about later okay any questions I'm talking too much all this is obvious you've done it all yes Yes? So just to confirm, if we want to access a file in buffer mode and edit it, it's not going to make changes to the original file? As long as all you do is type text into the buffer, you will be modifying the buffer. You are not changing the original file. Correct. So are there ways to make that? Oh, yes. I suppose I should tell you how to actually save your work, right? I mean, all right. So let's do that. Control X, Control S means save.

Save, buffer. So buffers that are associated with the file, that means please take the contents of the buffer and write it out to the file. I haven't done that here, so our file, which is called hello.text, is, oh my goodness, there it is, except it's not. I have some more explaining to do. Here I'm going to switch out of TeachingEase and switch into file system mode. I said we were going to talk about three things. So what do we have here? First off, notice there is no file hello.txt. When you create a file with Emacs, with control X, control F, and start editing the file, there's no file there yet. And so there is no file hello.txt. But there are these two funny squirrely looking file names. What's going on there?

Well, I'm going to do a couple things to try to find out. First off, I'm going to type meta x shell. So now I'm doing the shell part of our lecture. I'm doing three things at once, right? What's happened here is I've told Emacs, please start up a shell, right? So you have sort of the kernel, the hardware. When I logged in, I got a shell. I told the shell, I told emacs please run a subshell. So here we are in the subshell. Okay. And in this subshell I can run yet another command. I'm going to run the command ls. And no actually I already did the equivalent that I'm going to run the command cat. Cat is one of my favorite commands because it is so simple. It doesn't do It has nothing to do with feline creatures. The name comes as a shorthand for concatenate. And the basic idea of cat is that it reads a whole bunch of data and it outputs all that data to its standard output. So if I run just the command cat, I could do that. It's pretty boring because by default cat reads from standard input, which is your terminal.

It outputs the standard output, which is also your terminal. And so all it's doing here is it's echoing everything that you type. So we can go and say hello, goodbye, and so forth and so on. What I need to do now is tell Cat we've reached end of file and the standard way of doing that is to type control D. So we need another blackboard for this.

Talking to the terminal.

Ordinary characters stand for themselves.

Control D means end of line.

For technical reasons, the control D has to be at the start of the line.

If you type control D in the middle of the line, it means please send those characters off to the program right away. Don't wait for me to type return. I'm just ready for it to go. Control D at the start of the line means the same thing except then you're sending zero characters which programs interpret to mean end of file. All right, where were we? Ah, well, normally though, I don't run cat this way. I do something like this.

CAT arguments, it treats each argument as a file name and it reads from those files in the order that you typed and then outputs the contents of all those files to standard output. So if I say CAT OS release, it will read the copy of the etc OS release and you can tell that on my laptop I'm running Pop OS 22.04 LTS and a few other details about my machine. If I were to say something like this cat, etc. OS release, I don't know, etc. password. It would at first output the same thing that it did before and then output the contents of the password file. Let's take a look at that. So we see a whole bunch of data now, right? So first it output the OS release stuff and then starting from this line right here, that's the contents of the password file on my laptop. Luckily, the passwords are not really in that file so you can't break into my laptop even though you see this on the screen. All right, let's see what else can you do. You can type control C. All right, this means interrupt. And you can type a bunch of other characters, I don't know, So, well, you know, backspace works the way you expect. There's a few other control characters, but this is enough to get us started with the terminal thing. But the reason I wanted to do this is I wanted to look at these files. So I will do something that looks like that, right? And what we have here is we can see this file with a funny name starting with a sharp sign and quoted. So I'm going to just say, oh, let's take a look at this.

Look at that file, right? Like this. Oh, I suppose I should tell you some of the characters I was typing up there. If you're inside Emacs, here's the Emacs screen, you have sort of the arrow keys work the way you would expect, right? They let you move around. You can do a copy of a region using the following technology.

Here's more Emacs characters. So control at, which I normally don't type that way, I type it as control space, except this is sort of hard to print out and people get confused. I type control space, but if you type control at, that means put the mark here.

And then meta W means copy from between here in the mark. And control Y means yank which is emax ease for paste. You can do all this if you're running emax on a graphical terminal. You can use the mouse and all that sort of thing in the usual ways.

users typically don't do that because moving your fingers off the keyboard slows you down. So they get good at, you know, using characters like this so that you can go and then copy it across and you're off to the races. I apologize for not being able to demonstrate that here because I'm not used to this keyboard. This is some dinky little laptop keyboard. I'm used to this fancy keyboard that's sculpted and all that sort of thing. So it takes me a while to type on a normal keyboard.

All right, so notice that in this #Hello.text # we get a copy of what was in our window, right? So in our buffer I should say. So not a complete copy, it's a little bit out of date, right? Notice the buffer ends in DCA but our file here ended in just a D before we got the prompt for the next shell command output. So it's not exactly what's in the buffer, it's a somewhat obsolete copy of the buffer. But the idea here is that if Emacs were to crash right now, you could see pretty close to all of your work by looking at this file with a funny name that tells you what your plans were for when you eventually did a save. Now, if at this point I go and I'll I've got control X control X control X control X I've now written the file and if I do an LS minus L hello dot text again I'll see that this temporary file with a funny sharp signs in it that sort of thing has gone away we now have the file that we want it's sitting there with exactly 35 bytes we're fine but if I start go going to edit this file and then wait for a bit, we're going to see our friends again. It hasn't decided to wait but eventually it's going to show up with another sort of sharp sign thing. So Emacs is trying to address this problem that we want to save our work but we want to go fast and it's doing that by caching your file in two places.

The first is in this file name where it begins with sharp signs and it's doing that every now and then. And the second one is it's caching the files contents as a buffer in memory and it's doing that. That's very rapid. That's always kept up to date. Any questions on what we've talked about so far? Yes? Sorry?

It's an Emacs convention. It's not built into the file system, right? As far as the file system goes, you can put pretty much any character into a file name that you want. But the Emacs convention is file names starting with sharp signs are the files that it uses in order to sort of keep track of the state that you're in. Other comments or questions about this?

What exactly, like what sort of file is the one with the sharp side?

It's just a text file, right? Its contents were, you know, sort of most of what was in the buffer and all that sort of thing. So in terms of like the file system, the only thing unusual about it is its name. Other than that, it's just a regular file like any other regular file. Yes.

Because we want user control over when Emacs actually updates the file. We want that to be firmly under the user's control. We don't want Emacs to outsmart its users in figuring out when to do a save and when not to. We want, to some extent, what's going on here is, As you probably know, I'm kind of an open source guy. We want to understand everything. We want to be able to see exactly how stuff works. It's essentially the opposite of generative AI where nobody knows how that stuff works, even the authors, right? We want to actually know how it works. And this is part of that philosophy. It's not going to do a save until you tell it to do a save. Question? Why doesn't it make which?

So why doesn't it have the problem of losing your work while you save the file? That would be too slow, right. But the point here is that it only actually persists the data from the buffer into the file when you go and type control X, control S. And you don't do that all that often.

If you do it once a minute, it'll go plenty fast for you. The problem is we don't want it to be doing a save once every microsecond or something. That's going to be too slow. Right? So we have to sort of pick our battles, decide when we want to do a save. And the Emacs philosophy is firmly let the user decide. Until the user says save, I'm not going to save into the primary copy. Yes?

Control X, Control X, Control S saves the contents of the buffer into the actual file. So yeah, it does do the save that most users would recognize as being a save. Yes? Yes. Oh yes, it's visible. And maybe by now it's actually done something. Let's see. Control X, Control O, LS minus ALTR.

Oh, I forgot to tell you about this other guy. But anyhow, you can see here that since I've typed, since I've done a save, we have a copy of about 48 bytes worth. This column here tells you the file size. So it's a 48 byte file and it contains, you know, pretty close to the current version of the buffer. Question? Just like how Microsoft Web does it, why not just save your buffer every once in a while as like a backup so you don't even move your buffer?

In a sense that's what it's doing. This sharp hello dot text sharp is exactly what you described. Oh no no no no. If I were to shut off the laptop now, all of the stuff that you see towards the bottom of the screen, that's going to be saved. Yeah, it's because you're storing it in the file system. Yes? Yeah, I didn't get to that. So let's get to that now. What is that funny thing going on here? Where did I talk about it? Well, I'll just point up here.

So there is, this one is the weirdest file that we've seen.

Okay?

One way that it's weird is if you look at the leftmost column in the output of ls, the ls command lists the contents of a directory.

It says, "Oh, that file is an l file." There's a lowercase l in front of it.

Right?

Most of these files are either minus signs, which means it's just a regular file, which is what we've been dealing with before. Or they're Ds. D means it's a subdirectory. Okay? But this guy, this.hello.text isn't a D or a minus sign, it's an L. That's a special kind of file called a symbolic link. The contents of a symbolic link is still a text string, so in some sense it's like a regular file. But it's treated a lot differently. First off, Ls minus L, when it lists out a symbolic link, immediately lists its contents with a little arrow in between. So the contents of this symbolic link dot sharp hello dot text is the string egert at ray dot 22588 colon 174371481. And the second thing about symbolic links is not only does Ls minus L treat them differently, pretty much every other program The purpose of a symbolic link, its intent, is to store the name of a file that you should look at instead of looking at.sharp hello.text. However, Emacs is abusing, let me show you a more typical one. So we can do something like this, ls minus l slash bin.

is a symbolic link and the contents of the symbolic link is USR/bin.

And so the idea is that whenever you see a symbolic link, the file system is telling you this is not the file you are looking for.

You are looking for some other file and here's the name of the file that you should be looking at instead of /bin.

So if we sort of take the contents of the symbolic link and paste it into the base name of the file that we're looking at, we'll see really what we want. So when I say /bin or userbin sh, it's really just two different names for the same file. In this case, the file is another symbolic link.

So you can think of a symbolic link as sort of being like a pointer, except in C++ a pointer is really just an integer in disguise, right? That's all it really is. At the machine level it's an integer.

But here, the pointer is implemented as a text string, and to follow the pointer, you splice that text string into the file that you already have, and then use the resulting string instead. That's the basic idea of a symbolic link. That's what they're designed for. But Emacs is using the symbolic link for a different purpose.

Notice that we have something that says hello.text, right? And so I suppose that means we should be looking for a file named egert@re.22588:1743714081. But there's no file by that name. What Emacs is doing here is it's created a dangling a dangling symbolic link. It's a symbolic link to a file that isn't there. And it's doing it on purpose. This is something that if you did in CS31 they would take you out and give you a low grade for. You're not allowed to use dangling pointers. Those are dangerous. Those are trouble. And they are trouble in C++. But they're not trouble here because suppose I actually try to use this file name. I'll apply it to cat. So So cat star sharp hello dot text. What cat will try to do is look at the contents of this file and because it's a dangling symbolic link, it's a symbolic link that doesn't actually point to a file, cat will get an error message, get an error from the underlying system saying hey there's no file by that name. Because there isn't, it's a symbolic link that points to something that doesn't exist so it doesn't exist.

is doing this because it's using the symbolic link for something else. I'm going to type control X1 here so that we can see. I should put that up here. Control X1, which means focus on this window. I forgot the full name of the command. It means basically take this window and fill the whole frame with that window.

It's a dangling symbolic link and the contents of the link tells you who is currently editing this file. Right? So it's kind of using the contents of the symbolic link as metadata. The metadata in this case is Egert, that's me, @ray, Ray is the name of this machine, and then 22588 is the process ID of Emacs so that we'll know exactly which Emacs is currently editing this file. And I should mention over here, when you log in, you get a process ID. This is a process ID 397.4.6. Well, let's use this number. This is a 22588. Each process, that is, each program that's running gets a unique process ID.

And the contents of this symbolic link tells you the process ID of the Emacs that is actually currently editing the file. Right? And well, let's do a little aside. To some extent, there's commonly a distinction between software development where you're writing code, you're trying to build the next great application, Operations. Operations. Operations are the people who actually make everything work. So for example CSNET has a staff of people that you never run into but they just make sure all those servers are up all the time or at least 99 point whatever percent of the time. They do backups when some student starts running programs that choose up all the CPU time and nobody else can log in they go in and boot the student off all that good stuff right. You make stuff actually work. What I'm going to do is I'm going to pretend to be a DevOps person here and I'm going to type one of the commands, I'm sorry, an operation staff, I'm going to type one of the commands that an operation staff might want to run, which is the PS command. That's short for process status. And this says on this particular sub-terminal we have two programs running, bash and PS. But I don't want that. I want to know all the programs. So I'm going to run the command PS minus EF. The E is short for "give me everything on this system" and the F means print out a long list of information for each process this is running. So I do a PS minus EF, I get a lot of processes that are going on here. If I go back, oh, we should do more Emacs commands here.

Control-S means do a search. And Control-R, you can probably guess, means do a reverse search. The searches are interactive, so as you type characters, it starts searching for you. It's a fairly standard thing. So here I'm doing a backwards search for Emacs, and notice, here is the line for Emacs. It's the one that's partially highlighted, and that's process ID number 22588. What a coincidence!

That was the process ID for our funny file name. Did I do a save in the meantime? No, I didn't. We'll get there. There it is. Process 22588. That part of the contents of the symbolic link tells you which process is currently editing. That way, somebody else who wonders, "Who's editing?" If you're running several different EMACs on the same machine, which you can, you'll know which one is actually editing it. The last part of this symbolic link is that funny string number 1743714081. I love numbers like this. What is that number? If you've had lots of practice as operation staff, you would look at that number and you would immediately know what it's about.

All right? So I'll give you 10 seconds to figure it out while I type in another command that will give you a bink hint. Correct! Excellent! From now on, I expect you to recognize all numbers of this form. Oops, we'll get there. We need to put a...

The date command by default prints out the current time of day but if you say I'd like to print out this date that tells you when the session started that is editing that file. Why is that helpful? Suppose Emacs were to crash, completely crash because it lost power or something. What would be left behind?

We'd see the hello.txt files and we'd also see this symbolic link. The symbolic link would say, "Hey, I'm editing this file." When you reboot, when you start up Emacs again and all that sort of thing, this symbolic link is still there. So other people will think, "Hey, Eggert's currently editing that file." All right? How can we easily detect that this symbolic link is stale and no longer corresponding to anything? Well, we can look at the timestamp of it and see if that predates the last time the system was booted. So that's why this information is kept inside the symbolic link, to help people figure out what happens when something goes wrong. And a good chunk of software development is figuring out how to make your systems reliable when bad things happen. All right, so any questions about all of these hello files? We can do a little summary here.

Hello, hi. And there are the three files, the main file, the backup file, and there's a symbolic link which keeps track of whether somebody else is editing. Question? It's programmable, there's a configuration variable for it and all that sort of thing, but yeah. For now, let's assume every 10 seconds or something. Correct, yes?

So if I rename the main file? Yes. Emacs is doing it all for you, right. It's not a, the file system doesn't know anything about this and it's a convention. Some other systems will know about the convention and will respect it, but it's purely voluntary. CAT, for example, is a simple program that doesn't know about the convention. Yes.

What happens to the symbolic link when you're trying to edit more than one text process? Then let's do that. So I'll start up another Emacs here. New window. I think it's another Emacs. And I'm going to edit hello.text. And notice it says, oh, this guy has some auto-saving.

data because it saw that file with a sharp sign. And now if I go to start editing it, it'll say at the bottom, hey wait a second, Eggert's editing this file. Are you, you know, and here's the process ID. Are you sure you want to edit it? And here you have some options because what Emacs is trying to do here is prevent collisions where two people are trying to edit the same file and they step on each other's toes. And at this point you can type question mark and it will give you all the things you can do You can steal the lock, you can ignore the lock, you can give up all the obvious things that you might want to do when you're about to collide with somebody, you can do it. Question? What's that? Well, in some sense, these locks are exclusive but not fully exclusive, right? That is, I can look at the file and as long as I'm just reading it, you're not going to be stepping on the other guy's toes. But so you'd like the ability to not let anyone else read the file while you're working on it, right? And you could program Emacs to do that but that's not the default behavior. Okay, other comments on all of these funny files. Yes? Yes. What is the commonality? Why do they all start with control x?

So, they're ones that'll sort of work anywhere. Like, control X, to some extent, means this is a less commonly used command, because now you gotta type, hold down the control key, press X, go type some other key, right? You're gonna get carpal tunnel syndrome doing that, right? So, they're less commonly used commands. But another part of it is that the control X commands tend to be global commands that you could use in any mode. Not all the time, but a lot of them are that way. So, they're ones that'll sort of work anywhere.

So two things sort of simultaneously. Other comments? Yes? In this case, what happens if you press P and just ignore the lock? Oh, I've forgotten what P does. I hate doing this stuff. Steal, changes, proceed. Oh, well, then basically you're saying, I'm willing to step on the other, on Eggert's toes, right? Whoever types control S last wins.

All right? Actually, if you do that, the second person to type control S, Emacs will notice that something fishy is going on and will say, "Do you really want to save now? Looks like somebody else did a save." And then you can say, "Sure, I want to do that." So it's very much a voluntary system because the assumption in Emacs is that you're a competent software developer. You know what you're doing. It's the same assumption that C++ makes, right?

never teach C++ to first time programmers, right? That's like throwing them not into the deep end of the pool, it's like throwing them in the ocean. That's how you're going to learn how to swim, right? It's like a disaster, right? And Emacs is the same way. You should never teach, you know, software construction by throwing people into Emacs first thing. It's a disaster. Yes? I was also wondering, so if you proceed, does it create a separate buffer just for you? When I do what? Oh, each instance of Emacs has a completely independent set of buffers, right? Because the buffers are sitting in RAM. And each process has its own RAM. We don't have any shared memory or anything like that. Okay, let's take a break and we'll start up again at maybe six past the hour. All right, let's start up again. A couple things came up during the questions and I should really clarify this or fix or whatever. This number of seconds thing, that is the number of seconds since 1970, but I told you the wrong thing about what timestamp it is. As you can see, the timestamp is 2:00 PM, which is not the time that I started up Emacs. I started up Emacs at 4:00 PM something. This is the time that I booted my laptop. So that number in the symbolic link is the boot time of the operating system, not the time that Emacs started up. That way, if you reboot, you can easily tell that this symbolic link is stale because its timestamp predates the boot time of your current operating system. So that's one thing. And the second thing is someone just mentioned control G. I can't remember if I've told you about control G, but it's a very important control character in Emacs. It's almost as important as control X, control C, which gets you out. Control G is the interrupt character. And if you ever get in trouble in Emacs, one of the first things you should do to get out of trouble is to type control G. For example, suppose you type control X. Let's get down to here. Type control X. And you say, oh, I didn't mean to type control X something. I just wanted to type an ordinary character. Well, if you type the ordinary character now, it will be control X that character and it might jump you over to who knows where. Instead, you want to say, I want to get out of this. So at this point, we can type control G.

and it will get us back up to the top level. All right. So what I'd like to do next, since I seem to have gotten into this LS business, is tell you more about file systems. So we are going to now switch into file system mode and talk about the persistent state part of a Linux operating system.

that survives power outages and crashes and reboots and all that good stuff. At the base, or in its simplest form, what we have are files. But there are particular kind of files called regular files. Regular files have contents, and the contents of a regular file is a finite sequence of bytes.

And that's all they are as far as the file system is concerned. Finite sequence of bytes. The exact contents of the file is up to the application that creates it, but pretty much that's the main point of a file is to contain that sequence of bytes. However, associated with a regular file is some And to a first approximation, this is what the ls minus l command does. If you tell ls to list out information about a file, by default it just gives you the name, but if you say minus l, which I use like more than half the time, it also lists out the meta information for the file.

here, when I used LS minus L and we got all this stuff, everything to the left of the file name is meta information. If we take a look at that meta information, it's listed in columnar format and the columns are going to be as follows. First off, the file type. And if we take a look at, say, hello.com, that's just going to be a minus sign. This will be minus sign or D or L. There's some other file types as well. There are not very many file types, so we only need a few letters here and one character is enough to tell us what type of file it is. A file's type does not change. Once a file is created, it's got a type and it's going to stay that type forever until it gets removed. The next column or actually nine columns, right? This is just one column. Nine columns is going to be what's the file's permissions. The permissions can be thought of as a bit mask of nine bits, just ones and zeros, one, one, except, oh, should I tell you about the extra bits?

The hidden bits, the bits you're not supposed to know, everybody's saying no. That means I'm going to do it, right? It's really 12 bits, but most people only know about the 9 bits, right? So I'm going to tell you about the 9 bits first and then we'll add the extra 3 bits later, right? So normally you see 9 columns corresponding to each one of these bits, right? So you see something like this.

in three groups and even though they're written this way symbolically, internally it's just a bunch of ones and zeros. And you're just supposed to sort of know that, you know, well if I were to write this in octal, right? This is 7, 5, 4, right? So this octal number, which corresponds to this pattern, is represented symbolically this way.

But internally, it's just nine bits. Each group of three bits controls the permissions to access the file for a certain group of people. This first group is the user or the owner of the file. Each file has an owner. The owner is the person you can blame if the file's too big or if there's something wrong with the file.

It's the owner's fault. In this case, the owner is Eggert. So that's going to be column, well we can say column three. And this tells you that the owner Eggert has read, write and execute permissions to the file. Read and write are pretty obvious. Execute is a little less obvious.

that you can run the file as a program if it's a regular file. If you don't have execute permissions you cannot run the file as a program. You may be able to read and write it but you can't use it as a program. The second group of 3-bits talks about the group permissions. Users belong to groups. In Linux a user can belong to several different groups. You can find out what groups you are in by running the shell command ID. And it tells you here that I am user Eggert with the user ID of 1000. And my group ID is Eggert which is also 1000. And I'm in these groups, 1000 which is Eggert, 4ADM, 27 sudo, and 123 LP admin, right? So I can administer all the line printers attached to this laptop. So, this This says that if someone is in the group of the file, which in our case is group Egert, and is not the owner, then they can read and execute the file but they cannot write to it. And then this last group of three bits talks about other. The other column is for everybody who is not the user and is not in the group This is the permissions that they have. So this says if you're in the other group you can read the file but you can't do the other stuff associated with the file. Question? Why do we need three bits for user and owner? Because sometimes I want to create a file that I cannot write. Or can't even read. That's kind of weird but occasionally I'll want that. I want to have a file I have write only access to because I want to log stuff to it, but I don't want to read from it until maybe later, something like that. Notice that not all permissions combinations make a lot of sense. You can change the permission on a file, by the way, by using command chmod, which is short for change mode and another name for permissions is mode. I don't like to use that name because it gets confused with emacs modes, but that's why it's called chmod.

like this. Right? I just changed this to 173 octal. So if we do an ls minus l of hello dot text, we can see that I can run hello dot text as a command, but I can't read or write the file. Somebody who's in my group, but it's not me, can do whatever they like to the file. And some, everybody else can write to the file and execute the file but they can't read it. So if at this point I try to do something like this, it'll say permission denied. I don't have read permission to the file so it won't let me read it. I don't like that. I want to get back up my file. So I'll do a chmod 644 hello.txt so that it is something more reasonable.

If you write down the permissions in octal, it should be the case that each group of three is a superset of the next group of three. Otherwise, you're doing something a little odd. All right? I mentioned that there are actually 12 bits, not just nine. There's three other bits that we normally don't like to talk about here. And so they're normally hidden.

of a file with one of those bits turned on. It's the file /temp. By the way, the -d option of ls says, if you are listing out a directory, don't tell me what's in the directory, just tell me about the directory itself. Notice that /temp has a string that doesn't look quite right. rwx, rwx, rwt. That t is a little weird.

There's an extra bit over here called the sticky bit that you can use on directories. And it basically says this directory is such that if someone wants to delete a file or rename a file that's in this directory, they have to own the file. It's not sufficient to just have read and write and search permissions on the directory. You have to actually also have permissions on the file. So it's a special type of directory that It's more paranoid than it would otherwise be. And the textual representation of that, it says take that last x and turn it into a t. But what's really going on is there's an extra bit here. I'm going to try to find another, yes, command. Go ahead. What prevents you from like just changing the c, doing chmod stuff? Oh, yes. Well, let's try that. chmod.

say 777 slash temp, right? So what that would do is it turn off the sticky bit. It says, no, you're only allowed to change permissions on a file that you own. And that's true no matter what the permission bits are on the file, right? So we can't mess around with slash temp because slash temp is owned by root. Root is the superuser. The superuser can do anything, but we are mere mortals, so we can't mess with the permissions.

on slash 10. All right, let's look for another one.

Oh, by the way, the star here is what's called a globbing pattern. It means, give me all files whose names start with SU. And notice that we have another funny one here, and LS is trying to helpfully tell us something weird is going on by putting different colors here. There's an S there.

See that S? RWS. That is this bit. This is the sent UID bit. Again, it's a sort of a system privileges or security thing. What this means is that this command is executable. The SU command is executable. But when it runs, it doesn't run with your permissions. It runs with the permissions of the file's owner.

So when I run the SU command, I'm running as root. I'm the super user when I run that command. I'm not my usual self. Okay? And that's, of course, a very special ability to have, and we mark it that way by turning on the set UID bit. There's one other bit here, the set GID bit, which is similar except you're running in the group of the files group rather than as your own group, that sort of thing.

So there's really 12 bits and LS tries to sort of squeeze them into a 9-bit textual representation. Most of the time you don't have to worry about those top 3 bits but I told you about them here. Alright, any questions about the, oh by the way what happens if we try to run SU? Let's do that. It asks me for the root password. Right, that is it's running as root but it knows that If it just let every person run as root, you could do whatever you wanted. You could screw up the system. So you have to know the root password to take advantage of SU. I should warn you that you should not be trying to run SU or SUDO or any of those commands on CSNET. If you do, the op staff gets a little paranoid and they think you're trying to break into the system and they start sending me emails and it turns into a whole sort of, I just say, they're just students, They're trying out what I said in lecture, but it cuts no ice with them. So please just run these commands on your own machine, not on CSNA. All right. Notice I just did it on my laptop here. It's okay if you do it on your laptop. Just don't run it on CSNA. Any comments on these commands? Yes. Can I repeat which? The three special bits are the set UID bit. That means this program runs as its owner, the owner of the file.

the setgid bit which means this program runs in the group of whatever the files group is and the sticky bit which on directories means files in this directory have to be files that you own for you to sort of remove them or you know rewrite them or that sort of thing. Yes? What letter does the, like if the setgid bit is turned on what letter does it produce? I don't know. Let's see. That's perhaps the least common thing. So where are we? Oh, we'll touch foo. CH mod. All right. So that would be 2777 foo, right? There we go. Oh, it turns on the S bit in the group area, right? So I guess that sort of makes sense. Other questions about all these bits and all these files? All right.

So how big can we make a file? There's a truncate command that says something like this. Well that's a little too big. I tried to make a one petabyte file. Let's try a terabyte. There we go. So I just created a file of a terabyte on this machine.

That's a lot of data. What would happen if we tried this? So it's outputting a bunch of control at signs which if you'll recall is the null byte and if I kept, if I hadn't typed control C fairly quickly, emacs, an emacs buffer with two terabytes worth of characters because it takes two characters.

and eventually emacs would have run out of RAM so we don't want to do that and that sort of thing. So what I'm trying to tell you here in an indirect way is that regular files contain data but that data doesn't necessarily actually have to correspond to physical data on your flash drive or your disk drive. What the truncate command does is it creates a file of the size that you specify The contents of the file are all zeros, all null bytes, but they're not really there. The file system has simply remembered how big the file is supposed to be and if you try to access the file, it says, "Oh, well, there's nothing there. Well, I'll just use zeros." Zeros are sort of the default. This kind of thing is becoming more and more common in modern file systems. That is, what you see in your buffer or the data The data that you save to the file is not necessarily what's stored on the drive. It could be some little marker that says there's a bunch of zeros here. It could be encrypted. It could be compressed using Z standard or GZIP compression and that sort of thing. So we have to be careful here when we think about what a file system really is. It could be a bunch of low level bytes that don't at all look like what you see when you run But the mapping between the physical data and the mental contents of the file is something that the operating system should do for you. Anyhow, all right, so that's regular files. They're finite sequences of bytes. They have metadata. The metadata includes the mode, the type. Where were we? LS minus L foo, right?

That's pretty big, right? Except it's not really there, all right? So we have the output, this is the mode, the user, the group, the size and bytes, and then a timestamp. By default, LS gives you the timestamp of the last modification.

There are other timestamps in the file. I won't go into them now, but you can look at the ls man page and sort of figure it out and all that sort of thing. And then the file name, right, of course, right? So that's regular files. Directories are like regular files in the sense that they have the same metadata. If we go look at the current directory, ls minus ld dot, . is the Linux way of saying the current directory and it is type D but it has permissions, it has user, owner, size and bytes, timestamp, same thing as before, same kind of metadata. Question up there. The first piece of metadata where? Oh, up here? This is the word type, the file type, it's the leftmost column, the D or the minus.

How do you have a question?

The difference between the CC and the DG? I'm sorry, I couldn't hear the DG. What's the difference between the CC and the DG? Oh, yes. When you're typing at a terminal, control C is an interrupt, right? That was right here. When you're typing at Emacs, control G is an interrupt. In hindsight, maybe they should have used the same character for both, but they didn't. Sorry about that. Okay, other comments.

If you're looking closely at LS minus L output, I missed a column. There's a 31 here. If you go up to there, there's a 1. What's that number? There's something else going on and it has to do with the fact that we have a tree-structured file system.

If I were to draw a picture of the file system, there is a root of our tree structured file system. And I'm going to draw ellipses for directories and sort of boxes for regular files. You can think of each directory as a map from file names to files.

So if I do something like this, ls/, ls by default just prints out the names of all the files in a directory. This / directory has 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 22 file names. So you can think of the root file system on my laptop as having 22 sub things.

At this high level most of those sub things are going to be directories. But they could be files. So actually bin we know is a symbolic link. I'll draw that as a triangle. Symbolic link. We know the contents of the symbolic link is USR bin. There's another sort of subdirectory here called USR. We'll put it right here.

So if you are at the root directory and you say I like the USR file, you go down to this directory. And then there's some stuff under here. One of these guys is called bin. So this is the directory user bin and so forth and so on. My home directory is sitting under home egert. When I log in, this is where I'm at. I'm at the and that sort of thing. Eventually though, you sort of run out of directories. You're using the directories to organize your data, but you better have some data somewhere, right? So if we go and look under user bin, there is a regular file called sh. This contains the executable code for the shell, user bin sh. There's another regular file in here called emacs and so forth and so on.

These might actually be symbolic links, but bear with me. Pretend they're regular files. And so what you're going to see in any real world system is a tree structured file system in which the internal nodes are typically pretty bushy. People like to draw nice binary trees and all that sort of thing. These trees are not binary trees. They're bushy. So if I were to draw this to scale, there would be a whole bunch of leaves. Not all the leaves will be at the same level, right? You can have, you know, here's home, egart, bin, right? And then over here I have my own copy of Emacs, right? And so you can have some leaves that are further away from the root than the others and that sort of thing. But the point here is that these names here, I'm trying to draw the names the right way. The names of the files do not belong to the files.

Names live in directories. Files, strictly speaking, don't have names in and of themselves. The name is the path that you use to get to the file, but the file itself is nameless. And the way that we can see that most directly is with another shell command that I haven't told you about yet called ln.

create a link and in some sense it's like using pointers in C++ but this command uses pointers in a much more direct way than symbolic links right so if I were to say something like this this means create a new name B for an existing file that's already called A if our current directory looks like this points to this file that says hello. Then when you run this command, you'll get another name B that points to that same file. There's only one file, but now it has two names. And these names don't have to be in the same directory. If you have a tree-structured file system like this, it's possible for this sort of emacs to just be another pointer to this guy.

two different names for the same file and the two names are in different directories. So let's see if we can do something like that. I'm going to go to my home directory. The cd command says please go home and we are going to run makedir if I can get my keyboard working. I'm creating a subdirectory. I guess it's already there. I can do an ls minus l.

You can see all the stuff that's sitting under CS35L. These are all directories which are pretty boring. Taxes. Who's doing their taxes here? All right. We can say touch foo and we can say ln foo bar. And notice now what we have is two different names foo and bar for the same file.

This second column here, that number, is what's called the link count. Ordinarily, regular files have a link count of one. But notice that foo and bar have a link count of two. If at this point I would modify foo, echo, ouch, foo, right? Notice that, wrong one.

ECHOOUCH to FOO.

Notice that we have now modified BAR as well. Let's try it again. ECHOOUCHIES.

Now they've both grown to 8 bytes. So if I say CAT BAR, it says ouchies.

there's really only one file there between foo and bar and if you modify the file well doesn't matter what name you use it's the same file either way yes oh yes so that's a very good point if we remove say foo right what rm does is it removes a name in a directory But if that file is still accessible by some other name, it's still there. So the operating system keeps track for each file how many links are pointing to that file and it doesn't reclaim the storage for the file until the link count drops to zero. The link count, which in some systems is called the reference count, lets the operating system easily tell when it's okay to reclaim the file storage. Alright. Any questions on how that works? So normally a regulars file link count is one, but it'll go up to be greater than one if you type LN. Yes? In back. Can I give different names to different witches? No, there's only one file and the meta information for that file belongs to the file. It does not belong to the name. Good point.

Yes?

Does doing the LN stuff mess up the Emacs height?

When Emacs edits a file whose link count is greater than one, it goes into a defensive crouch.

Right?

And it says, "Oh, this file has two names. I better be very careful about it." It will create, you know, those funny file names for that file.

But it will say, you know, whenever I write this file, I could be in trouble because there's some other name for the file that I don't know about. So the way I have Emacs configured, which I'm not sure if it's default, is in that situation, when I write to the file, it first removes it and creates a fresh file with a new copy, thus breaking the hard link so it doesn't affect the other hard link. Not everybody likes that, so that's a configurable option in Emacs.

Okay. So how can we sort of tell what's going on here? There's a couple of things we can do. First off, let's link bar to baz and link baz to bay. Why not? So now we have a link count of three.

Suppose I wanted to know, alright, here's three files with the same sort of size and the same timestamps and their link counts three. That looks pretty suspicious. But how do I know that they're actually the same three files? Maybe the first one is a file with a link count of three that just happens to have the same size and timestamps as the other guys, but it's really a different file. The way you can tell that is with a There's another option to LS called the -i option. And the -i option, i is short for inode number for internal node number, that sort of thing. Every file in a Linux file system has a unique number associated with file that identifies that file. So here we can look at this column, the i column, and see, oh, these guys with the link count of three, they really are the same file because they have the same number.

In some sense, you can think of the inode number as being like an address in a C++ program, except this address points at a file, not at a location in RAM or that sort of thing. It actually points to a file in the file system. However, it's a little bit different because if I know a file's inode number, and that's all I know, I cannot access the file.

the file is via its name. So you still have to have a name for the file. The inode number itself is just sort of information you might find useful if you want to, but you can't use it to do anything else. All right. Comment? No. Well, what you can do is something like this. You can say run no command and send the output Now notice the size is dropped to zero. So if I do cat baz, there's nothing there. So you can destroy the contents of the file making it a size zero file, but if you want to actually make sure that all variants are removed, or all sort of names are removed, you have to actually go find the names and remove them. Yes?

The link count will tell you how many there are. Yes? Instead of making another link, is there another command to just duplicate instead of? Oh, yes. Oh, well, but that's so prosaic. You just want to make a copy? CP as boof, right? All right, so now we see that we've made a copy of this It's got a link count of one. It's a different file. It has a different inode number. So we know that if we modify one, we won't modify the other. Question? Does anything happen if I did LN A to B when LN B back to A? LN does not want you to, you know, overwrite a file that already exists. But there is an option called LN minus F which says I know what I'm doing I don't care if the file already exists and then if we do LS all over again we will see that it's still the same file as it was before. Other comments. There's one other thing though that I should mention. Notice oh I guess it's run off the end of the screen we'll do it again LS minus LD dot right so here's the working directory look at its link count It's 13. What in the world is going on there? Suppose we try to do something like this, ln of d x y z. I'm trying to create a hard link of a directory to itself and it says you're not allowed to create hard links to directories. So there's something odd going on here. And that has to do with the special convention that Linux uses to name the current directory and the parent directory. This special convention is as follows. Dot stands for the current directory. And dot dot stands for the parent directory. So what that means is if you look at any directory in the file system, it may have some subdirectories and that sort of thing.

and that entry points to the directory itself. Another entry is called.dot and that entry always points to the parent directory. Every directory is like that. So this guy is similar. It's got a.entry. We'll get there. And it's got a.dot directory. So here's. here's.dot and here's our subdirectory directory.

that sort of thing. Every directory works that way. So the link count for a fresh directory, right? If we do something that looks like this, make dir fresh, ls minus ld of fresh, right? The link count is two. Why? We created a new directory here called fresh. Here it is. It's got an entry called dot that points to itself. And it's got an entry called dot dot dot that points to the parent. It's got a link count of two. One for the dot and one for the fresh from the parent. So if that's the case, how can a directory have a link count of 31 was it? Some big number. Oh, 13. How can a directory have a link count of 13? A little bit of arithmetic should tell you how that 13 happened.

So a directory starts off with a link count of two. Every time you create a subdirectory, the directory's link count goes up by one. Notice that now if we do an ls minus ld of dot, the link count is 14. Why is it 14 and not 13? Because it's got a new subdirectory. Subdirectories dot dot entry points at us. So a link count of a directory is going to equal two plus the number of subdirectories that it has. Yes? Does the root directory also have a. Oh yes! Good catch! Let's take a look. ls - a li slash. It does and it's an exception. The parent of the root directory is also the root directory and you know that means its link count is still two at least right? All right so the root directory is special. You can't go up from the root. If you try you stay stuck at the root. All right other questions about link counts, directories, subdirectories, symbolic links? Good we'll have more to talk about it next time but please come to discussion otherwise the homework will turn into mysterious stuff.

