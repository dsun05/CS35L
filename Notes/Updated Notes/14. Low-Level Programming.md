# Lecture 14: Low-Level Programming

## 1. Introduction and Context
- Focus: Low-level software development, primarily in C and C++.
- These languages are considered "low-level" compared to Python, JavaScript, etc.
- Most modern software is not written in C/C++, but these languages remain crucial for performance-critical and system-level work.
- Tools for low-level development (debugging, performance, security) are the most mature due to decades of evolution.
- Many techniques discussed here are not yet available in higher-level languages, but may propagate over time.

## 2. Attitude Toward Debugging
- **Avoid using a debugger as a first resort.**
  - Using a debugger often means you've already failed to prevent a bug.
  - Debugging is human-intensive and inefficient compared to preventive techniques.
- **Alternative:** Use compiler features and static/dynamic analysis to catch bugs early.
- This attitude is especially helpful at the low level, but is good practice at any level.

## 3. Compilers as Debugging and Security Tools

### 3.1 GCC and Clang
- **GCC** and **Clang** are the two major free compilers for C/C++.
- They are largely compatible, but some options differ in spelling or behavior.
- Most techniques discussed apply to both, but examples use GCC syntax.

### 3.2 Security-Related Compiler Options

#### 3.2.1 `_FORTIFY_SOURCE`
- **Usage:** `-D_FORTIFY_SOURCE=2 -O2`
- **Purpose:** Replaces standard functions (e.g., `memcpy`) with safer, bounds-checked versions.
- **How it works:**
  - Compiler injects extra runtime checks for buffer overflows and similar bugs.
  - Example: `memcpy(dest, src, size)` will check that `dest` and `src` are valid and within bounds if possible.
- **Limitations:**
  - If the compiler cannot determine object sizes, it falls back to the standard (unchecked) version.
  - Not a guarantee of safety—just a partial defense.

#### 3.2.2 `-fstack-protector`
- **Purpose:** Defends against stack buffer overflows by inserting a "canary" value in the stack frame.
- **How it works:**
  - Canary is a random value placed before the return address.
  - On function return, the canary is checked. If it has changed, the program aborts.
  - Analogy: Like a canary in a coal mine—detects danger early.

**ASCII Diagram: Stack Frame with Canary**
```
|----------------------|  <-- High Address
|   Local Variables    |
|----------------------|
|      Canary Value    |  <--- Inserted by compiler
|----------------------|
|   Return Address     |
|----------------------|  <-- Low Address
```
*The canary sits between local variables and the return address. If a buffer overflow overwrites the canary, the program aborts.*

#### 3.2.3 Control Flow Enforcement Technology (CET) / Shadow Stack
- **Usage:** `-fcf-protection`
- **Purpose:** Hardware-enforced control flow integrity using a shadow stack.
- **How it works:**
  - The shadow stack stores only return addresses, is inaccessible to user code, and is protected by the OS.
  - On function call: return address is pushed to both the normal and shadow stack.
  - On return: both are popped and compared. If they differ, the program traps/crashes.

**ASCII Diagram: Expanded Shadow Stack vs. Normal Stack**
```
Normal Stack (accessible):
|----------------------|  <-- High Address
|   Local Variables    |
|----------------------|
|   Return Address     |  <--- Target for attacks
|----------------------|  <-- Low Address

Shadow Stack (protected):
|----------------------|  <-- High Address
|   Return Address     |  <--- Only return addresses, protected
|----------------------|  <-- Low Address
```
*The shadow stack is protected and only manipulated by special instructions. On return, both stacks are checked for agreement.*

- **Benefits:**
  - Prevents return address tampering (e.g., from buffer overflows).
  - Hardware-enforced, so efficient and secure.
- **Limitations:**
  - Only available on newer Intel/AMD CPUs.
  - Not enabled by default in most distributions.

## 4. Performance Improvement via Compiler Features

### 4.1 Optimization Levels
| Flag   | Description                                 |
|--------|---------------------------------------------|
| -O0    | No optimization (default)                   |
| -O1    | Basic optimizations                         |
| -O2    | Moderate, safe optimizations (most common)  |
| -O3    | Aggressive optimizations; may be buggy      |
| -Os    | Optimize for size instead of speed          |
| -Og    | Optimize for debugging (intended, but often still confusing) |

- **Caveats:**
  - Higher levels (especially `-O3`, `-Ofast`) may introduce compiler bugs or make debugging harder.
  - Optimizations may reorder instructions, making debugging confusing.
  - `-Og` is intended for debuggability, but may still cause confusion.

### 4.2 Build Scripts and Makefiles
- Build systems (e.g., Makefiles) control how programs are compiled and linked.
- Makefiles specify dependencies and recipes for building each part of a program.
- C/C++ build systems are more mature and sophisticated than those for higher-level languages.

**ASCII Flow: Build Process with Makefile**
```
[Source Files]
     |
     v
 [Makefile]
     |
     v
[Compiler (gcc/clang)]
     |
     v
[Object Files (.o)]
     |
     v
   [Linker]
     |
     v
[Executable]
```
*The Makefile orchestrates the build process, specifying how to compile and link source files into an executable.*

### 4.3 Link Time Optimization (LTO)
- **Usage:** `-flto`
- **How it works:**
  - Object files include extra information (intermediate representation of the source code).
  - At link time, the compiler can optimize across all modules, enabling inlining and other whole-program optimizations.
- **Advantages:**
  - Can produce smaller, faster code.
- **Disadvantages:**
  - Slower link times.
  - Higher risk of compiler bugs, especially for large programs.

### 4.4 Profile-Guided Optimization (PGO)
- **Usage:** `-fprofile-generate` and `-fprofile-use`
- **How it works:**
  1. Compile with `-fprofile-generate`.
  2. Run the program to collect profiling data.
  3. Recompile with `-fprofile-use` to optimize based on real usage.
- **Caveats:**
  - Test runs may not match production behavior, so optimizations may not always be ideal.

### 4.5 Optimization Hints

#### 4.5.1 `__builtin_unreachable()`
- **Purpose:** Tells the compiler that a code path cannot be reached.
- **Example:**
  ```c
  if (a < 0) __builtin_unreachable();
  x = a / 1024; // Compiler can optimize to x = a >> 10;
  ```
- **Difference from `abort()`:**
  - `abort()` always crashes; `__builtin_unreachable()` allows the compiler to optimize more aggressively.
  - In debug mode, you can use `abort()`; in release mode, switch to `__builtin_unreachable()` for performance.
- **Caution:** Only use when you are certain the code is unreachable; otherwise, you risk undefined behavior.

#### 4.5.2 Function Attributes: `cold` and `hot`
- **Usage:** `__attribute__((cold))` or `__attribute__((hot))`
- **Purpose:**
  - `cold`: Function is rarely called (e.g., error handling).
  - `hot`: Function is frequently called (e.g., main loop).
- **Effect:**
  - Compiler may place cold code away from hot code to improve cache usage.
  - Can improve performance by keeping hot code in the instruction cache.
- **Example:**
  ```c
  __attribute__((cold)) void error_log();
  ```

#### 4.5.3 Profiling and Coverage
- **Compiler can use profiling data to automatically determine hot/cold code.**
- **Caveat:** Profiling assumes test runs match production runs, which may not always be true.

## 5. Static and Dynamic Code Checking

### 5.1 Static Checking
- **Static checking:** Compiler checks code at compile time, before running the program.
- **Example:**
  ```c
  #include <assert.h>
  static_assert(INT_MAX < UINT_MAX, "Int must be smaller than UInt");
  ```
- **Benefits:**
  - Catches bugs before the program runs.
  - No runtime overhead.
- **Limitations:**
  - Only works for properties that can be checked at compile time.

#### 5.1.1 Compiler Warnings
- **Enable with:** `-Wall` (and other `-W` flags)
- **Common warnings:**

| Flag                   | Description                                              |
|------------------------|----------------------------------------------------------|
| `-Wall`                | Enable commonly helpful warnings                         |
| `-Wparentheses`        | Warn about ambiguous or confusing expressions            |
| `-Waddress`            | Warn about suspicious pointer comparisons                |
| `-Wstrict-aliasing`    | Warn about type-punning across incompatible pointers     |
| `-Wmaybe-uninitialized`| Warn if a variable might be used without initialization  |
| `-Wtype-limits`        | Warn about always-true/false comparisons due to types    |

- **Examples:**
  - `if (a + b << c)` // May be ambiguous; parentheses may be needed.
  - `if (p == "abc")` // Comparing pointer to string literal's address.
  - `int v; if (n < 0) v = 3; if (n < -10) return v;` // v may be uninitialized.

#### 5.1.2 Controversial Warnings
- Some warnings (e.g., `-Wstrict-aliasing`, `-Wtype-limits`) are controversial:
  - May produce false positives or be inappropriate for certain codebases (e.g., Linux kernel).
  - Developers may disable them for portability or practicality.

#### 5.1.3 Interprocedural Analysis: `-fanalyzer`
- **Purpose:** Performs static analysis across function boundaries.
- **Pros:** Can find bugs that single-function analysis misses.
- **Cons:** Slow, may produce many false positives, not always practical for large codebases.

### 5.2 Function Attributes for Checking and Optimization

| Attribute      | Description                                              |
|----------------|----------------------------------------------------------|
| `noreturn`     | Function does not return (e.g., `exit()`)               |
| `const`/`unsequenced` | No side-effects; return depends only on arguments |
| `pure`/`reproducible` | No side-effects; may read global state            |
| `hot`/`cold`   | Indicate call frequency for optimization                |

- **Benefits:**
  - Help compiler optimize and check code correctness.
  - Example: `noreturn` allows compiler to warn about unreachable code after `exit()`.

### 5.3 Dynamic Checking
- **Dynamic checking:** Compiler inserts runtime checks to catch errors as the program runs.
- **Trade-offs:**
  - Slows down execution.
  - Only catches bugs if the problematic code path is executed during testing.

### 5.4 Safe Integer Arithmetic (C23)
- **Header:** `<stdckdint.h>`
- **Functions:** `ckd_add`, `ckd_sub`, etc.
- **Usage:**
  ```c
  #include <stdckdint.h>
  int r;
  if (ckd_add(&r, a, b)) {
    // Overflow occurred
  }
  ```
- **Purpose:** Reliably detect integer overflow, which is a common attack vector.
- **Available as of C23.**

## 6. Summary Table: Compiler Tools for Reliability and Performance

| Use Case           | Recommended Tool/Option                         |
|--------------------|-------------------------------------------------|
| Undefined Behavior | `-fsanitize`, `-Wall`, `static_assert`          |
| Stack Protection   | `-fstack-protector`, Shadow Stacks (CET)        |
| Buffer Overflow    | `_FORTIFY_SOURCE`, `-fsanitize=address`         |
| Performance        | `-O2`, `-O3`, PGO, `-flto`                      |
| Integer Overflow   | `<stdckdint.h>`                                 |
| Optimization hints | `__builtin_unreachable()`, `__attribute__((cold))` |

## 7. Final Notes
- Low-level programming requires careful attention to security, performance, and correctness.
- Modern compilers provide a wealth of options and features to help developers write safer, faster, and more reliable code.
- Avoid relying solely on debuggers; leverage compiler checks, static/dynamic analysis, and modern language features.
- Stay up to date with new standards (e.g., C23) and hardware features (e.g., CET). 