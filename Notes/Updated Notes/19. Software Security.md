# Lecture 19: Software Security

## 1. Introduction: Why Security Matters

- Security must be considered from the very beginning of software design—not as an afterthought.
- Integrate security into initial specs, requirements, and all stages of development.
- Clients/customers assume developers are building secure systems, even if they don't specify requirements.
- Ignoring security leads to wasted time, insecure architectures, and potentially catastrophic vulnerabilities.
- Security is a major field in practical computing (jobs, internships, real-world impact), second only to AI in scope.
- Even if you don't specialize in security, you must understand the basics to avoid critical mistakes and communicate with specialists.

---

## 2. Step Zero: Security Mindset

Before you write code, develop two models:

### 2.1 Security Model
- What are you defending? ("Crown jewels"/assets)
- Model the application and its valuable data/resources.
- **CIA Triad:**
  - **Confidentiality (Privacy):** Prevent unauthorized data access/leakage.
  - **Integrity:** Prevent unauthorized modification/tampering.
  - **Availability (Service):** Ensure systems are usable and accessible.

**ASCII Diagram:**
```
+-------------------+
|   Application     |
|-------------------|
| Confidential Data |
+-------------------+
      |   |   |
      v   v   v
 C (no leaks)  I (no tampering)  A (always up)
```

### 2.2 Threat Model
- Who might attack the system, and how?
- Prioritize defense strategies based on realistic threats.
- Models are never perfect—improve them continuously.

#### Checklist for Security Modeling
| Category        | Purpose                                 | Example                                 |
|-----------------|-----------------------------------------|-----------------------------------------|
| Assets          | What needs protection                   | Database, config files, credentials     |
| Vulnerabilities | Weaknesses/channels for attack          | Open ports, input flaws, misconfig      |
| Threats         | Potential attackers/scenarios           | Ex-employees, bots, phishing, insiders  |

---

## 3. Key Security Functions

### 3.1 Authentication
- Verifies user identity.
- Examples: Passwords, two-factor authentication (2FA), USB keys, biometrics (retinal scan, fingerprint).
- Multi-factor authentication (MFA):
  - Something you know (password)
  - Something you have (device, app, USB key)
  - Something you are (biometric)

| Method Type         | Description         | Example                |
|---------------------|--------------------|------------------------|
| Something you know  | Knowledge-based    | Password, PIN          |
| Something you have  | Possession-based   | USB key, Duo app, TOTP |
| Something you are   | Biometric          | Fingerprint, retina    |

### 3.2 Authorization
- Dictates what authenticated users can do.
- Example: Instructor can modify grades in their own classes, not others.
- Uses Access Control Lists (ACLs):

| User      | Read | Write | Execute |
|-----------|------|-------|---------|
| Eggert    | Yes  | Yes   | Yes     |
| Milstein  | Yes  | No    | No      |
| Frank     | No   | No    | No      |

### 3.3 Integrity Mechanisms
- Detect and recover from unauthorized changes.
- Examples: Checksums, secure backups.

| Mechanism  | Description                                 |
|------------|---------------------------------------------|
| Checksums  | Detect tampering by comparing stored values |
| Backups    | Restore data after compromise/loss          |

### 3.4 Auditing
- Logs user actions to detect/recover from intrusions.
- Logs must be secure, complete, and regularly reviewed.

### 3.5 Supporting Principles
| Principle   | Description                                        |
|-------------|----------------------------------------------------|
| Correctness | Security must not break core functionality         |
| Efficiency  | Security must not overly degrade performance       |

---

## 4. Threat Modeling and Classification

- Classify threats to prioritize and determine effective defenses.

### 4.1 Network Attacks
| Threat                | Description                                                      |
|-----------------------|------------------------------------------------------------------|
| Phishing              | Tricking users to click links or enter credentials               |
| Drive-by Downloads    | Malware triggered by visiting malicious pages                    |
| Denial-of-Service     | Overloading servers to make them unavailable                     |
| Buffer Overruns       | Overflowing memory buffers to hijack control flow                |
| Cross-Site Scripting  | Malicious JavaScript in user's browser (e.g., bank theft)        |
| Prototype Pollution   | Attacking object prototypes in JavaScript                        |

### 4.2 Device Attacks
| Attack         | Description                                              |
|----------------|----------------------------------------------------------|
| Bad USB        | USB device boots/installs malware, hijacks boot process  |
| Insider Attack | Authorized users misuse privileges                       |

### 4.3 Social Engineering
- Convincing users to reveal info or grant access (e.g., fake repairman, lost ID).
- Hard to defend; requires robust integrity and auditing.

---

## 5. OWASP Top 10 Application Security Risks (2021)

| #  | Vulnerability                        | Description/Examples                                                      |
|----|--------------------------------------|--------------------------------------------------------------------------|
| 1  | Broken Access Control                | URL/JWT/cookie manipulation, insecure direct object references           |
| 2  | Cryptographic Failures               | HTTP over HTTPS, weak crypto, improper certificate validation            |
| 3  | Injection Attacks                    | SQL/NoSQL/command injection via untrusted input                          |
| 4  | Insecure Design                      | No threat modeling, poor design practices                                |
| 5  | Security Misconfiguration            | Default passwords, open ports, unnecessary services                      |
| 6  | Vulnerable/Outdated Components       | Using libraries/OS with known exploits                                   |
| 7  | Identification/Authentication Failures| Weak passwords, no rate limiting, brute force attacks                    |
| 8  | Software/Data Integrity Failures     | Poor update mechanisms, unverified sources, supply chain attacks         |
| 9  | Security Logging/Monitoring Failures | Lack of logging, logs not reviewed, filled logs                          |
| 10 | Server-Side Request Forgery (SSRF)   | Tricking server to access internal/private network addresses             |

---

## 6. Security Testing: Philosophy and Strategies

### 6.1 Testing Philosophy
| Traditional Testing              | Security Testing                        |
|----------------------------------|------------------------------------------|
| Inputs: typical users            | Inputs: malicious attackers              |
| Failures: random                 | Failures: deliberate, targeted           |
| Bugs: accidental                 | Bugs: systematically exploited           |

### 6.2 Strategies
- **Static Analysis:** Analyze code without running it (find buffer overflows, races, etc.).
- **Penetration Testing:** Hire trusted "black hats" to simulate real-world attacks.

### 6.3 Side-Channel and Timing Attacks
- Attackers infer internal state/data by measuring timing (e.g., cache timing, Spectre, Meltdown).
- Apple restricts high-res timers to inhibit these attacks; Linux allows nanosecond timing (riskier).

### 6.4 Subtle Abstraction Violations
- Example: Partial string comparison leaks password byte-by-byte via timing.
- Advanced: Manipulate memory layout, exploit page boundaries, cache access patterns.

**ASCII Diagram: Timing Attack**
```
[User Input] ---> [Password Check]
                |
                +---> [Timing Difference] ---> [Attacker infers secret]
```

---

## 7. Trusting Trust: Ken Thompson's Attack

- Described in the Turing Award lecture "Reflections on Trusting Trust."
- Modify the C compiler to insert a backdoor when compiling login.c:

```c
if (strcmp(name, "ken") == 0) return true;
```

- Then, modify the compiler to insert this backdoor into any future compiler it compiles.
- Result: Even if you inspect the source code for login.c and cc.c, the executables will still regenerate the backdoor.

**ASCII Flow:**
```
[Source: login.c] --(buggy cc)--> [login (backdoor)]
[Source: cc.c]    --(buggy cc)--> [cc (backdoor)]
```

- **Defense:**
  - Define a **Trusted Computing Base (TCB):** Minimal set of components (compiler, OS, hardware) that must be trusted.
  - Software reproducibility and rigorous review help, but trust must start somewhere.

---

## 8. Summary and Takeaways

- Security must be integrated from the start—never "added later."
- Develop both a security model (what to protect) and a threat model (who/what to defend against).
- The CIA Triad (Confidentiality, Integrity, Availability) is foundational.
- Key functions: authentication, authorization, integrity, auditing, correctness, efficiency.
- Threats include network, device, social engineering, and insider attacks.
- OWASP Top 10 highlights common vulnerabilities—know and avoid them.
- Security testing is adversarial: expect intelligent, targeted attacks.
- Advanced attacks (timing, side-channel, supply chain, trusting trust) require deep awareness.
- Always think like a defender—and sometimes like an attacker—to build robust, secure software. 