# Lecture 15: Debugging Without a Debugger & GDB Deep Dive

## 1. Debugging Without a Debugger

### 1.1 Static Checking
- **Static checking** is performed at compile-time using tools like `gcc` and `clang`.
- **Limitations:**
  - Cannot catch all bugs (e.g., runtime-specific issues).
  - Theoretical limits (e.g., Halting Problem) prevent perfect static analysis.

### 1.2 Dynamic Checking
- **Dynamic checking** occurs during program execution.
- Catches bugs missed by static checking, but only for the specific run/test case.
- **Manual dynamic checks:**
  - Add assertions to validate state at runtime.
  - Example: Array bounds checking
    ```c
    if (!(0 <= i && i < n)) error();
    a[i];
    ```
  - Example: Integer overflow (incorrect check)
    ```c
    if (j * k > INT_MAX) error(); // This does NOT work in C/C++
    ```
    - In C/C++, signed integer overflow is undefined behavior. The implementation can do anything, so the check above is unreliable.
  - **Correct overflow check (C23/C++26):**
    ```c
    #include <stdckdint.h>
    if (__builtin_mul_overflow(j, k, &i)) error();
    ```
    - `__builtin_mul_overflow` returns true if overflow occurred.
    - C++26 will have similar utilities.
  - **Downsides:**
    - Tedious and error-prone to add checks everywhere.
    - Easy to make mistakes in the checks themselves.

#### 1.2.1 GCC Sanitizer Flags
- Compiler flags that insert runtime checks for various classes of bugs:

| Flag                    | Purpose                                               | Captures                       |
|-------------------------|-------------------------------------------------------|--------------------------------|
| `-fsanitize=undefined`  | Catch undefined behavior (e.g., overflow)             | Integer overflow, divide by 0  |
| `-fsanitize=address`    | Catch memory/address issues                           | Buffer overflows, bad pointers |
| `-fsanitize=thread`     | Detect race conditions                                | Multi-thread concurrency bugs  |
| `-fsanitize=leak`       | Find memory leaks                                     | Leaked malloc() allocations    |

- **Limitations:**
  - Some flags cannot be used together (e.g., `undefined` vs `address`).
  - Not all undefined behaviors are caught.
  - These flags slow down execution.

#### 1.2.2 Valgrind
- Tool for dynamic analysis at the binary level (no recompilation needed).
- Detects memory errors, leaks, and some undefined behaviors.
- **Advantages:**
  - Can be used on production binaries.
  - No need for special compilation flags.
- **Disadvantages:**
  - Much slower than sanitizer flags (interprets each instruction).
  - Lacks source code context, so may miss semantic errors.

| Tool        | Source Required | Speed Impact   | Coverage               | Usability in Production |
|-------------|----------------|---------------|------------------------|------------------------|
| Sanitizers  | Yes            | Moderate      | Targeted checks        | No                     |
| Valgrind    | No             | High          | Broader, shallower     | Yes                    |

#### 1.2.3 Compiler Flag: `-fwrapv`
- Forces signed integer overflow to wrap around (modulo 2ⁿ).
- Makes code more predictable, but disables some optimizations (e.g., loop unrolling).
- **Not the default** because it can slow down code and prevent optimizations.

##### Example: Loop Unrolling
```c
for (int i = 0; i < n; i++) {
  f(i);
}
```
- If `n` is `INT_MAX`, `i++` might overflow.
- With `-fwrapv`, the compiler cannot assume overflow doesn't happen, so it can't unroll the loop.

## 2. Portability Checking
- Ensures code runs correctly on different platforms (OS, architecture, browser, etc.).
- **Examples:**
  - Cross-browser JavaScript testing.
  - Cross-platform compilation (32-bit vs 64-bit).
  - Testing with different OS/browser/plugin combinations.
- **Techniques:**
  - Build and run on multiple environments.
  - Use compiler flags like `-m32` to generate 32-bit binaries.

| Flag    | Purpose                             |
|---------|-------------------------------------|
| `-m32`  | Force 32-bit compilation on GCC      |
| default | Typically compiles to 64-bit binary |

- **Note:** Portability checking can be expensive due to the combinatorial explosion of possible environments.

## 3. Test Cases
- **Purpose:** Not to prove code works, but to find bugs.
- **Mindset:** "If my test cases didn't find a bug, I failed."
- **Test infrastructure:**
  - Automate test execution (shell scripts, `make check`, CI systems).
  - Run tests in parallel (`make -j N`).
  - Separate quick/cheap tests (run frequently) from heavy/expensive tests (run less often).
- **Tools:**
  - Scripts (e.g., `run_tests.sh`)
  - Makefiles with `check` targets
  - GitHub Actions/CI
- **Test case generation:**
  - LLMs (Large Language Models) are effective for generating test cases (Meta found 40–50% LLM contribution is optimal).
- **Randomness testing:**
  - Impossible to mathematically prove randomness.
  - Can test statistical properties (bit balance, lack of patterns, distribution coverage).
  - Example of a bad random generator that passes naive tests:
    ```c
    return UINT64_MAX / 3; // Alternating bits
    ```

## 4. Defensive Programming
- **Goals:**
  - Prevent bugs before they occur.
  - Minimize the impact of bugs that do occur.
  - Detect bugs early and reliably.
- **Techniques:**
  - Static checking (compiler warnings)
  - Dynamic checking (sanitizers, Valgrind)
  - Test case design for failure
  - Defensive coding (asserts, bounds checks)

## 5. Terminology: Error, Fault, Failure
| Term     | Description                                         |
|----------|-----------------------------------------------------|
| Error    | Developer's mistake (mental/conceptual)             |
| Fault    | Error reflected in the code (latent bug)            |
| Failure  | Fault triggered during execution (observable bug)   |

- **Debugging process:**
  - Start with symptoms (failure), trace back to fault (code), then to error (developer's mistake).

### ASCII Flow: Error → Fault → Failure
```
[Error: Developer's Mistake]
           |
           v
   [Fault: Bug in Code]
           |
           v
[Failure: Runtime Symptom]
```

## 6. Debugging Best Practices
### 6.1 Steps
1. **Reproduce/Stabilize the failure**
   - Make the bug consistent and repeatable.
   - May require disabling features like ASLR (Address Space Layout Randomization).
2. **Locate the fault**
   - Use backwards reasoning from symptoms to code.
   - Use debugger features to narrow down the cause.

### ASCII Diagram: Debugging Workflow
```
[Observe Failure]
      |
      v
[Reproduce & Stabilize]
      |
      v
[Locate Fault]
      |
      v
[Trace Back to Error]
```

### 6.2 Anti-patterns
- Randomly modifying code lines hoping it works (futile, non-scalable).
- Avoid using GDB as a crutch; it's for reasoning, not fixing.

## 7. GDB: Debugger Deep Dive
### 7.1 GDB's Role
- GDB is a "Program Execution Explorer."
- GDB controls the debugged process by communicating with the OS kernel.
- Can start a program, attach to a running process, or modify program state.

### 7.2 Key GDB Commands
| Command         | Purpose                                    |
|-----------------|--------------------------------------------|
| `run` / `r`     | Start the program within GDB               |
| `quit` / `q`    | Exit GDB                                   |
| `attach PID`    | Attach to an already running process       |
| `detach`        | Detach from the debugged process           |

#### Setup Commands
| Command                         | Description                             |
|----------------------------------|-----------------------------------------|
| `set cwd /path`                 | Set working directory for debugged proc |
| `set env VAR value`             | Set environment variable                |
| `set disable-randomization off` | Enable ASLR                             |

- **ASLR (Address Space Layout Randomization):**
  - Randomizes memory layout to prevent exploits.
  - Hurts reproducibility for debugging.
  - GDB disables ASLR by default for reproducibility.

### 7.3 Breakpoints
| Command             | Description                                      |
|---------------------|--------------------------------------------------|
| `break <loc>` / `b` | Set breakpoint at function or line               |
| `info break` / `ib` | List all breakpoints                             |
| `delete <num>` / `d`| Remove specified breakpoint                      |

- **Implementation:**
  - GDB replaces the instruction at the breakpoint with a trap instruction.
  - When the program hits the trap, it stops and GDB regains control.

### 7.4 Control Commands
| Command         | Action                                                      |
|-----------------|------------------------------------------------------------|
| `continue` / `c`| Resume execution after break                               |
| `step` / `s`    | Step into the next line of source code (includes functions)|
| `next` / `n`    | Step over function calls                                   |
| `stepi`         | Step a single machine instruction                          |
| `finish`        | Run until current function returns                         |

- **Note:** Stepping can be confusing with optimized code; use `-O0` and `-g3` for best results.

### 7.5 Advanced Commands
| Command                   | Purpose                                                                    |
|---------------------------|----------------------------------------------------------------------------|
| `reverse-continue` / `rc` | Execute backwards to previous state (requires special setup, slows down)    |
| `watch <expr>`            | Set a watchpoint to break when expression value changes                     |
| `checkpoint` / `restart`  | Save and reload program state (manual reverse execution)                    |
| `print <expr>` / `p`      | Evaluate and print a variable or expression                                 |

- **Reverse execution:**
  - `rc` requires GDB to keep snapshots of program state, which is slow and memory-intensive.
  - `checkpoint`/`restart` is a manual, more efficient alternative.
- **Watchpoints:**
  - Hardware support is limited (e.g., x86-64 supports 4 hardware watchpoints).
  - Software watchpoints are much slower.

### 7.6 Print Command Usage
- Print variables, expressions, or call functions:
  ```gdb
  p a + b
  p my_struct.member
  p my_function()
  p exit(1)  // Dangerous: will cause program to terminate
  ```
- **Caveats:**
  - Can call functions, which may modify program state.
  - Use with caution.

## 8. Summary
This lecture covered dynamic debugging techniques and deep strategies for finding and reasoning about bugs. It began by analyzing static vs dynamic checking, highlighted compiler options and tools like GCC Sanitizers and Valgrind, and delved into best practices for test case development. The lecture emphasized the limitations of test verification, especially for probabilistic behavior like random number generators. Terminology around errors, faults, and failures was clarified to promote precise debugging approaches. Finally, the lecture introduced GDB as a powerful but inefficient last-resort debugger and detailed its usage, including breakpoints, controlling program execution, reverse debugging, watchpoints, and introspection using print commands. The overarching theme emphasized preventing bugs proactively, detecting them robustly, and using debuggers like GDB as tools of last resort for precise reasoning.

---

### ASCII Diagram: GDB, Kernel, and Debugged Process

```
+-------------------+
|      GDB          |
+-------------------+
         |
         v
+-------------------+
|   OS Kernel       |
+-------------------+
         |
         v
+-------------------+
|  Debugged Program |
+-------------------+
```

- GDB controls the debugged program by sending commands through the OS kernel.
- GDB can start, stop, inspect, and modify the program at runtime.

### Table: GDB Command Summary

| Command                | Abbreviation | Description                                 |
|------------------------|--------------|---------------------------------------------|
| run                    | r            | Start program under GDB                     |
| quit                   | q            | Exit GDB                                    |
| break <loc>            | b            | Set breakpoint                              |
| info break             | ib           | List breakpoints                            |
| delete <num>           | d            | Delete breakpoint                           |
| continue               | c            | Continue execution                          |
| step                   | s            | Step into (source line/function)            |
| next                   | n            | Step over function calls                    |
| stepi                  |              | Step one machine instruction                |
| finish                 |              | Run until current function returns          |
| reverse-continue       | rc           | Run backwards to previous breakpoint        |
| watch <expr>           |              | Set watchpoint on expression                |
| checkpoint             |              | Save program state                          |
| restart <n>            |              | Restore program state from checkpoint       |
| print <expr>           | p            | Print variable/expression/call function     |
| attach <PID>           |              | Attach to running process                   |
| detach                 |              | Detach from process                         |

---