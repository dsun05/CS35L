# Advanced Shell and File System Concepts in Unix/Linux

## Table of Contents

1. Introduction
2. File System Structure
   - Directory Hierarchy
   - Inodes and File Identification
   - File Naming and Path Resolution
3. Links
   - Hard Links
   - Symbolic (Soft) Links
   - Absolute vs. Relative Symlinks
   - Pitfalls and Edge Cases with Symlinks
4. The Shell Overview
   - Purpose and Philosophy
   - Basic IO Redirection
5. Shell Command Execution
   - Argument Passing
   - Standard Input, Output, and Error
6. Shell Syntax
   - Tokens and Word Splitting
   - Quoting
   - Reserved Words
   - Conditional Execution
   - Loops
7. Shell Variables
   - User-defined Variables
   - Special Variables
   - Variable Expansion Operators
   - Environment Variables and export
8. Subshells and Background Processing
   - Process Control
   - Parallel Execution
9. Pipes and Inter-Process Communication
   - Pipes: Concepts and Behavior
   - Multi-stage Pipelines
10. File Descriptor Manipulation
    - Redirection Operators
    - Combining Outputs (stdout/stderr)
11. Shell Expansion Rules
    - Expansion Phases
    - Tilde Expansion
    - Command Substitution
    - Arithmetic Expansion
    - Field Splitting
    - Globbing (Pathname Expansion)
12. Summary

---

## 1. Introduction

This lecture continues on the topics of Emacs, the Unix/Linux shell, file systems, and interaction between them. Emphasis is placed on understanding links, file path resolution, how the shell interprets commands, syntax, and redirection, and expanding shell expressions.

---

## 2. File System Structure

### Directory Hierarchy

- Hierarchical tree rooted at `/`.
- Containing multiple directories such as `/bin`, `/usr`, `/home`, which may further nest other directories or files.

### Inodes and File Identification

- Each file or directory is assigned a unique identifier called an inode number.
- Inodes store metadata (ownership, permissions, timestamps), not name.
- Commands to view inode numbers:
    - `ls -i filename`
    - `ls -li` for long format with inode.

Example:

```bash
ls -li /bin/sh
1234567 lrwxrwxrwx 1 root root 4 Jan 1 00:00 /bin/sh -> bash
```

### File Naming and Path Resolution

- Absolute path: begins with `/`.
- Relative path: begins from current working directory.
- The resolution algorithm (namei-like function):
    1. Start from `/` if absolute, otherwise current directory.
    2. Traverse each component, resolving directories.
    3. Resolve symlinks if present.

---

## 3. Links

### Hard Links

- Links to the same inode from different directory entries.
- Equivalent entries pointing to the same file content.
- Limitations:
    - Cannot link directories.
    - Must be on the same filesystem.

Example:

```bash
ln file1 file2
# file2 is another name for file1
```

### Symbolic (Soft) Links

- Separate files containing a path string pointing to the target.
- Can reference files, directories, even non-existing paths.

Example:

```bash
ln -s /usr/bin/python3 mypython
```

### Absolute vs. Relative Symlinks

- Absolute symlink: Path begins with `/`.
- Relative symlink: Path does not begin with `/`.
- Interpretation depends on symlink's location.

### Pitfalls and Edge Cases

- Dangling symlink: Points to a non-existent target.

```bash
ln -s nowhere foo
cat foo  # Error: No such file or directory
```

- Cyclic symlinks: Infinite loops, e.g.:

```bash
ln -s B A
ln -s A B
cat A  # Causes loop
```

- System protects via maximum resolution limit (e.g., 20 symlinks).

- Hard links to symlinks are valid but resolve differently depending on path.

---

## 4. The Shell Overview

- A command-line interpreter for interacting with the operating system.
- Acts as a scripting language.
- Designed for:
  - Launching programs.
  - Managing IO.
  - Scripting and automation.

---

## 5. Shell Command Execution

### Argument Passing

```bash
command arg1 arg2
```

- Argument count and values appear as:

```c
int main(int argc, char** argv)
// argv[0] = command, argv[1] = arg1, ...
```

### Standard Input, Output, and Error

- stdin (0), stdout (1), stderr (2).
- Can be redirected using:

```bash
command < input.txt > output.txt
```

- Piping:

```bash
cat file | grep "pattern"
```

---

## 6. Shell Syntax

### Tokens and Word Splitting

- Words are split by whitespace outside quotes.
- Special characters: `|`, `&`, `;`, `<`, `>`, `#`, `(`, `)`, etc.
  
### Quoting

| Type        | Description |
|-------------|-------------|
| `\char`     | Escapes the next character |
| `'string'`  | Literal string. No expansion occurs |
| `"string"`  | Allows expansion of variables and commands |
  
Handling single quotes inside single-quoted strings:

```bash
'Three o'\''clock'
```

### Reserved Words

| Type          | Example |
|---------------|---------|
| Conditional   | `if`, `then`, `else`, `fi` |
| Loops         | `for`, `in`, `do`, `done`, `while`, `until` |
| Case          | `case`, `esac` |
| Grouping      | `{`, `}` |
| Negation      | `!`      |

### Conditional Execution

```bash
if command; then
    ...
else
    ...
fi
```

Or using operators:

- `command1 && command2` – Runs `command2` only if `command1` succeeds (exit 0).
- `command1 || command2` – Runs `command2` only if `command1` fails (non-zero).

### Loops

- `while` executes as long as a condition is true.

```bash
while condition; do
    ...
done
```

- `for` iterates over words.

```bash
for item in a b c; do
    echo $item
done
```

- `case` switches on patterns.

```bash
case $file in
    *.c) echo "C Source";;
    *.o) echo "Object File";;
    *) echo "Unknown";;
esac
```

---

## 7. Shell Variables

### User-defined Variables

```bash
x="hello"
echo $x
```

### Special Variables

| Variable | Meaning |
|----------|---------|
| `$0`     | Script name |
| `$1`...`$9` | Positional parameters |
| `$*`     | All arguments (treated as one word) |
| `$@`     | All arguments (each word preserved) |
| `$#`     | Number of arguments |
| `$$`     | PID of the shell |
| `$!`     | PID of last background process |
| `$?`     | Exit status of last command |

### Variable Expansion Operators

| Syntax              | Description |
|---------------------|-------------|
| `${VAR:-default}`   | Use default if VAR unset |
| `${VAR:+alt}`       | Use alt if VAR is set |
| `${VAR:=default}`   | Assign default if VAR unset |
| `${VAR:?error}`     | Error if VAR not set |

Examples:

```bash
name=${USER:-guest}
```

### Environment Variables and export

- To set variables for subprocesses:

```bash
export EDITOR=emacs
```

- `set` – Lists all variables including functions.
- `env` – Lists exported variables.

---

## 8. Subshells and Background Processing

- Execute a background job:

```bash
command &
```

- `wait` – Block until the background process finishes.

Example:

```bash
sleep 10 &
SPID=$!
wait $SPID
```

---

## 9. Pipes and Inter-Process Communication

### Pipes

- Connect stdout of one program to stdin of another:

```bash
cmd1 | cmd2 | cmd3
```

- Shell sets up bounded buffers (default 64KB or so).

- Synchronization model: writer blocks when buffer is full; reader blocks when buffer is empty.

- Errors (stderr) are not passed through pipes by default.

---

## 10. File Descriptor Manipulation

Each process has:

- `0`: stdin
- `1`: stdout
- `2`: stderr

### IO Redirection

| Syntax        | Meaning |
|---------------|---------|
| `> file`      | stdout to file |
| `2> file`     | stderr to file |
| `>> file`     | Append to file |
| `< file`      | stdin from file |
| `command >file 2>&1` | Redirect both stdout and stderr to the same file |

### File Descriptor Duplication

Redirect stderr to stdout:

```bash
2>&1
```

Redirect stdout to stderr:

```bash
1>&2
```

Combining:

```bash
command >output.txt 2>&1
```

### Multiple Writers or Readers

- Running concurrent processes that read/write from shared pipe creates race conditions.

Example:

```bash
cmd1 | tee output.txt | cmd2
```

---

## 11. Shell Expansion Rules

Expansion happens in this order:

1. Tilde Expansion (`~` → home directory)
2. Parameter (Variable) Expansion (`$VAR`)
3. Command Substitution (`$(...)`)
4. Arithmetic Expansion (`$((...))`)
5. Field Splitting
6. Filename Expansion (Globbing)
7. Redirections

### Globbing (Pathname Expansion)

Pattern matching against existing files:

| Pattern | Meaning |
|---------|---------|
| `*`     | Zero or more characters |
| `?`     | Single character |
| `[abc]` | One character in set |
| `[a-z]` | Character range |

Example:

```bash
ls *.c      # Lists all .c files
```

If no file matches, shell leaves the pattern unexpanded.

---

## 12. Summary

This lecture explored key aspects of Unix/Linux shells and file systems. It covered the relationship between directories, files, inodes, and links; explained the shell's execution model and file name resolution; detailed how symbolic and hard links function, covering corner cases, absolute vs. relative links, and link loops. The lecture addressed how the shell interprets commands—exploring tokenization, quoting mechanisms, and reserved words. It reviewed shell programming constructs such as conditionals, loops, and variables—including special and environment variables and complex variable substitutions. Practical examples showed how to run commands in parallel or in the background, use process control primitives like wait and kill, and explained shell IO redirection and pipes. Critical shell expansions such as tilde, command substitution, arithmetic, and globbing were fully broken down. This foundational knowledge enables powerful and efficient usage of Unix/Linux systems.