00:00.020-00:00.800
So if we had more

00:00.800-00:04.260
time, I'd

00:04.260-00:06.880
want to be talking about more Python.

00:10.400-00:15.220
And I'd like to also do a little bit more client-server computing.

00:16.740-00:18.420
Turn down the microphone a little bit here.

00:20.520-00:21.840
All right, so client-server.

00:23.480-00:26.540
And in order to talk about that, we really need to talk about networking.

00:30.240-00:33.380
And to some extent, I have to give you an introduction to CS1.

00:33.380-00:34.500
I think you have a problem with my computer.

00:34.740-00:36.160
I turned it off too far.

00:36.320-00:37.220
All right, let's try it again.

00:39.290-00:39.740
Can you hear me?

00:40.130-00:40.680
Yes, okay.

00:41.220-00:42.680
Client server computing, networking.

00:42.980-00:49.880
This is really CS118, which we should cover in, you know, a half an hour or something like that.

00:49.990-00:51.340
And then we can finally do a demo.

00:52.200-00:59.220
Oh, well, you need to talk about, you know, things like, oh, I don't know, HTML and CSS

01:00.200-01:01.100
and JavaScript.

01:02.260-01:03.620
And then we could talk about, no.

01:05.280-01:09.300
That's a lot to talk about in one lecture.

01:10.940-01:13.740
And we have another assignment coming up, right?

01:14.880-01:20.440
Assignment three, the easiest assignment in the class, right?

01:20.600-01:25.340
It's just a kind of a hello world problem, very simple sort of, well, a little harder

01:25.370-01:26.980
than hello world, but not that hard.

01:27.290-01:28.320
And it's written in note.

01:28.780-01:33.820
So I feel like I should do things in a different order than I would do if things were really

01:34.220-01:34.320
organized.

01:35.079-01:41.220
I'm an engineering type, and so I like to know how everything actually works way down

01:41.340-01:42.060
to the machine level.

01:42.340-01:45.880
And we would sort of see that this way, well, skipping over the Python, right?

01:46.480-01:50.040
But I thought we'd try today doing it in the opposite order.

01:50.360-01:57.680
start off with Node and then we'll work our way back and see how it's working and all

01:57.800-01:58.240
that sort of thing.

01:58.600-02:02.380
But I really can't sort of just do Node.

02:02.380-02:11.440
I have to do a little bit of client service because that's the essence of the third assignment

02:12.340-02:17.340
is to have you do something that's a little different from what you've done in CS31 and

02:17.340-02:18.880
what you've done earlier in this course.

02:19.860-02:23.860
Still now, you've always written a program that runs on a computer.

02:24.220-02:25.640
It's classic computing.

02:26.060-02:29.180
It's been done this way ever since the 1950s, right?

02:30.240-02:33.080
Now we're going to do client server, which is still pretty classic.

02:33.980-02:35.540
Now we're talking 1970s.

02:36.340-02:37.980
But there's something new here.

02:38.650-02:39.840
We have two computers.

02:42.220-02:46.680
Or, since we're software people, we shouldn't think about them as computers.

02:47.240-02:48.520
We have two programs.

02:50.780-02:57.460
They're both running simultaneously and they're talking to each other and we want the entire

02:57.920-02:58.580
system to work.

02:59.420-03:03.980
It's not just writing one program, it's getting two programs to work.

03:04.960-03:10.720
As you can probably guess from the name client server, what we can think of is here's a network.

03:13.140-03:15.520
Some people like to draw it as a nice little cloud.

03:16.180-03:20.880
I tend to draw it often that way but I'll draw it as just a sort of a line that you

03:20.880-03:22.080
can hook up anywhere in the network.

03:22.600-03:24.540
Somewhere on the network there's a client.

03:26.100-03:28.460
Somewhere else on the network there's a server.

03:29.780-03:35.780
And the way the application runs is some of it runs in point A and some of it runs in

03:35.940-03:40.400
point B. This is not the only way to do stuff on the network.

03:42.120-03:47.600
by any stretch of the imagination. But it's kind of the simplest. If you're going to have a network,

03:48.200-03:52.780
it's interesting only if you have at least two things on the network. Otherwise, it's just a

03:52.870-03:57.580
single computer. The simplest way you can have two things going is with the client and server.

03:58.630-04:05.840
Now, the typical way this is done is the following. The server has a database,

04:07.980-04:17.120
and this database stores the state of the system. Now it's not a complete description of the state

04:17.120-04:22.560
of the system but let's put it this way it's the important part of the state that you care about in

04:22.560-04:27.640
your application. The client doesn't store any state.

04:28.760-04:28.960
Again

04:28.960-04:31.039
it does store some stuff but it's

04:31.060-04:33.780
It's nothing important as far as the application goes.

04:34.560-04:41.500
So if the state here is, I don't know, the registrar's database of all the courses that

04:41.720-04:46.700
are at UCLA and who's enrolled in which courses and all that sort of thing, that's kept on

04:46.700-04:51.620
a server deep underground in Murphy Hall or someplace like that.

04:52.880-04:54.680
And what's on your laptop doesn't matter.

04:55.080-04:58.160
Your laptop doesn't say whether you're enrolled in this class.

04:58.980-05:02.200
It's that server underneath Murphy Hall that says, right?

05:02.800-05:05.900
So your laptop will be the client, right?

05:06.420-05:10.140
And you will talk to the server and get enrolled in the class or not.

05:11.220-05:17.580
Very typically in a client-server system, there will be multiple clients, right?

05:18.040-05:19.900
Client 1, client 2, client 3.

05:21.420-05:26.380
But what they'll do in a client-server system is they'll talk to the network, but they'll

05:26.460-05:27.460
only talk to the server.

05:28.540-05:29.480
They won't talk to each other.

05:30.780-05:35.980
If client one wants to affect what's on client two's screen,

05:36.160-05:40.120
that is for example, you enroll in the last slot in the class

05:40.820-05:43.000
and now the next person can't enroll

05:43.540-05:44.620
because the class is full.

05:44.800-05:48.320
The way that happens is the clients talk to the server.

05:49.300-05:52.380
The server's in charge of who's actually enrolled, right?

05:52.700-05:54.920
And the client can ask the server to make a change

05:55.000-05:56.500
and if the server likes the client,

05:56.660-05:58.160
the server will say, okay, I'll change the state.

05:59.240-06:02.180
But really, it's the server that's in charge here.

06:02.790-06:04.580
And the clients make requests.

06:06.180-06:09.480
Of course, nothing really interesting will happen

06:10.200-06:12.100
unless there are clients who make requests.

06:12.340-06:13.980
And in some sense, I guess you could say

06:13.990-06:15.460
the clients are also in control,

06:15.640-06:19.560
but really, at the bottom, the server's in charge.

06:19.860-06:22.060
And if the server decides to do nothing,

06:23.320-06:24.140
then nothing will happen.

06:25.640-06:29.700
So that's the kind of application that you're going to be building for your project,

06:30.760-06:34.180
and it's the kind of application that Homework 3 is warming up with.

06:34.350-06:37.280
Any questions on this basic structure?

06:38.980-06:41.200
Can you see anything that might go wrong?

06:43.240-06:48.880
Since you're engineers, the first thing you should say is, what can break?

06:49.480-06:55.520
Because you're in charge of either breaking things or making sure they don't stay broken.

06:55.560-06:55.760
Yes?

06:55.780-06:58.100
Do you have two clients try to edit the same game?

06:58.600-07:00.720
Oh, excellent question, right?

07:01.800-07:06.140
Two people try to enroll at exactly the same time.

07:06.620-07:07.240
What's going to happen?

07:07.740-07:08.800
The server will pick a winner.

07:10.140-07:11.980
One person wins, the other person loses.

07:13.059-07:18.460
Or if the server is not very well programmed, the server will send an error message to both

07:18.640-07:22.680
clients saying, "I can't enroll you because there's some problem at the other end."

07:22.680-07:22.780
Right?

07:23.920-07:28.040
Or even worse, the server says, I'll let you both in.

07:29.180-07:31.080
Actually, that's pretty good from the student's point of view.

07:31.970-07:35.460
But if we have a certain classroom capacity, that's not going to work, right?

07:35.730-07:40.060
So there's new ways to screw up in client-server applications

07:40.640-07:46.840
that weren't really all that possible in single sort of computer applications.

07:47.580-07:49.120
Lots of new ways to go wrong.

07:49.490-07:52.300
And you will get to explore a lot of them in this class.

07:52.500-07:53.640
It's going to be so much fun.

07:54.440-07:59.500
Any other comments on the big picture and what can go wrong?

08:02.260-08:02.640
All right.

08:03.010-08:07.340
So let's take a look at sort of a sample way of doing that.

08:07.640-08:09.260
And, you know, I should warn you.

08:10.240-08:15.800
Let's do a little warning down here before we get too much further.

08:19.560-08:23.500
Here's the classic speedometer that's in my car.

08:23.540-08:25.240
I still have one of these analog things.

08:26.840-08:29.420
And this warning says we're going faster than before.

08:30.940-08:31.180
Okay.

08:32.180-08:36.340
Until now, I've been going through things in a lot of detail.

08:37.080-08:41.740
I'm telling you every little place where all the square brackets go on regular expressions

08:41.860-08:42.700
and all that sort of thing.

08:43.719-08:43.840
Okay.

08:44.039-08:46.720
Now, I figure you know how to learn that stuff.

08:47.960-08:49.740
And so I'm going to start to go faster.

08:49.920-08:54.880
I'm not going to give you every little detail about JavaScript because you already know how to learn this stuff.

08:56.400-08:58.040
Also, I'll make a confession.

08:59.160-09:00.780
I'm not a JavaScript expert.

09:01.980-09:04.700
Not like I am an expert in some of the other stuff in this class.

09:05.400-09:09.020
I haven't written, you know, 10,000 lines of JavaScript code.

09:09.740-09:13.860
So I'm giving you some of this stuff just by reputation or inference.

09:14.020-09:17.580
I mean, I've done a little bit, enough to do the class, but I'm not really the expert.

09:17.920-09:19.480
That's another reason I'm going fast.

09:20.200-09:27.520
because you'll be learning not from me, but from each other, from the TAs, from the LAs,

09:27.520-09:29.240
from the internet and all that sort of stuff.

09:29.420-09:31.520
And then at the end, I'll get to test you on all this.

09:32.040-09:33.120
It's going to be a lot of fun.

09:33.840-09:34.100
All right?

09:35.000-09:37.060
So I hope you don't mind the little confession.

09:37.200-09:42.540
You know, some faculty members never want to tell you that they don't know something.

09:43.560-09:45.900
They'll do a little song and dance and hope you don't notice.

09:46.060-09:48.460
I'm very happy to tell you when I don't know stuff.

09:49.180-09:49.500
All right.

09:49.800-10:00.180
So where were we? So what is Node? It's often called Node.js, and it's often called Node.js

10:00.620-10:06.180
because that's the name of the domain name. You can sort of go off and visit that website

10:06.280-10:14.180
and found all about this technology. So it is a software technology, and to some extent,

10:15.220-10:18.400
At its heart, it's the following.

10:19.520-10:27.460
It's a JavaScript runtime for handling sort of asynchronous events.

10:33.480-10:37.540
It's a lot of other stuff, but this is what it is at its heart.

10:38.360-10:44.359
And essentially what is going on here is it's a different way of writing software

10:44.380-10:51.460
than what you're used to. You're used to writing programs with for loops and

10:51.920-10:57.540
function calls and all that sort of thing and in that style which is the

10:57.780-11:03.200
traditional style you're writing a recipe for what should happen and it always

11:03.460-11:09.340
gets executed in the order that you tell the computer. You're in charge when you

11:09.260-11:12.080
write the program of exactly what will happen next.

11:13.140-11:13.780
Okay?

11:15.220-11:21.760
What Node is about is a different style of program, not taught in CS31, dealing with

11:22.160-11:22.940
asynchronous events.

11:24.080-11:29.760
Asynchronous events means your program's running and it's doing stuff, but it's running in

11:29.960-11:34.380
a larger environment, and in that larger environment, things happen.

11:36.380-11:39.780
those things come up against your program and they pound on the door and say it's time

11:39.800-11:43.320
to stop doing what you're doing and do something else because I've got this important thing

11:43.320-11:43.740
to handle.

11:45.420-11:47.200
Classic example is a web server.

11:48.500-11:51.700
Web server is constantly getting requests from the outside world.

11:52.740-11:54.960
Some of those requests will take a long time to handle.

11:56.300-11:58.940
While it's handling one request, another request will come in.

12:00.180-12:02.340
Now the web server has two requests to deal with.

12:03.140-12:10.560
it finish off the first one before it starts the second one? No! That would be a disaster.

12:11.380-12:16.340
That means when one person asks a tough question, the web server is stuck until that question

12:16.500-12:24.140
is answered. We don't want your sort of node applications to behave like a CS31 program.

12:24.950-12:31.479
We don't want that disaster. Instead, the web server should be able to say, "Oh, I've

12:31.500-12:34.960
I've got this long-running thing going, I'll do this other thing.

12:35.940-12:42.000
Oh, and here's the third thing I'll do, and sort of juggle a lot of things to do based

12:42.200-12:45.340
on requests that come in, sort of out of the blue.

12:46.200-12:50.800
Or sometimes the request won't come out of the blue, it'll be something like the following.

12:53.100-12:55.320
An end user asks something of the web server.

12:56.140-13:01.460
In order to answer the question, the web server has to make a database request to a database

13:01.480-13:02.020
some other server.

13:03.080-13:05.020
And then it has to wait for that answer to come back.

13:05.740-13:09.540
So these asynchronous events can be externally generated

13:10.700-13:13.180
or they can result from other events

13:13.270-13:14.200
that have already happened.

13:15.200-13:17.080
And we want to be able to handle all of that

13:17.190-13:18.860
and that's basically what's going on.

13:20.000-13:23.760
If you try to write this kind of runtime down

13:25.080-13:27.960
in a sort of CS31 style,

13:29.400-13:32.800
you'll see that what this runtime does at the top level

13:32.980-13:34.260
is a very simple loop.

13:35.300-13:36.200
It'll look like this.

13:37.500-13:37.940
While true,

13:41.820-13:42.440
do the following.

13:44.880-13:48.220
Event E equals getNextEvent.

13:53.660-13:56.579
And here, I'm assuming that this is a sort of

13:56.500-14:03.100
built-in function that waits for the next event to occur that comes in from the

14:03.220-14:07.720
outside world or maybe from inside from some earlier thing that you've done. If

14:07.800-14:14.240
there's nothing going on it hangs, right? If the web server is totally idle nothing's

14:14.320-14:19.060
going on there but eventually you get an event, right? And then we handle that

14:19.080-14:32.340
event and loop around and get the next one. But there's a key sort of important

14:32.720-14:37.900
part of this loop, right? And that key important part is whatever this stuff

14:37.980-14:57.620
does. This event handler here, it must finish quickly. And by quickly, okay, I'll do a little

14:57.620-15:02.480
bit of hand waving. It depends on the application on how fast that can be. But the point is,

15:02.720-15:10.800
it should not take milliseconds. That's too long. It certainly should not take seconds. That's

15:10.920-15:19.080
ridiculous. You want this event handler to just take, you know, a few million instructions, nothing

15:19.420-15:28.139
big, right? It has to run fast. In particular, something the event handler cannot do is something

15:28.160-15:38.180
like this. Look inside this event handler, if you see this code, that's probably wrong.

15:39.459-15:45.980
Why? Because when you read from a file or read from a network connection or something

15:46.160-15:51.420
like that, the read will wait until the data's there. That wait is going to take too long.

15:52.360-15:54.440
You know, this could take seconds.

15:55.480-15:55.940
That's ridiculous.

15:57.040-16:00.960
So you're not allowed to do any reads or writes.

16:03.420-16:06.680
Don't do that either, because the write might take a while.

16:07.510-16:10.980
You can't do anything like that in your event handler.

16:12.140-16:14.580
Because if you do, what's gonna happen?

16:15.800-16:20.699
This top level code will be stuck handling one event

16:20.780-16:22.100
while other events arrive.

16:22.970-16:26.420
And those other events will, say, pile up in your input queue

16:26.420-16:29.580
or something like that, and users will start complaining.

16:30.160-16:31.560
This web server is a disaster.

16:31.830-16:34.180
I sent it a request and it doesn't give me an answer

16:34.290-16:36.220
for like half a second.

16:36.580-16:37.420
It's really slow.

16:39.580-16:41.600
All right, see how this works?

16:43.060-16:45.460
Okay, so there's a big constraint

16:46.530-16:47.660
on what you can put in here.

16:47.960-16:49.740
Don't put anything that takes a long time.

16:52.700-17:00.720
Now, suppose you're writing a web server that's in charge of some, I don't know,

17:01.290-17:04.600
machine learning training application, right?

17:05.540-17:12.699
So your web server takes requests from the outside world, uses it to train some big ML

17:12.860-17:15.959
model, and that training session is going to take two hours.

17:18.420-17:24.680
common application these days. Some web training sessions last a lot longer than two hours.

17:25.860-17:30.880
I was just in a talk earlier this afternoon where they estimated the cost of building

17:31.160-17:38.840
one machine learning model was 70 million dollars worth of CPU time. Well, obviously

17:41.340-17:49.240
event can't be something like that, right? If it involves a long computation, the

17:49.380-17:54.620
way you fit it into this model is you break that long computation into smaller

17:54.920-18:00.920
pieces. Each piece is small enough to fit in your time limit and at the end of

18:00.980-18:11.300
its quick action, maybe it'll just train one little part of the model, it says, oh

18:11.320-18:16.920
So instead of writing this program that has this loop that looks like this,

18:24.940-18:27.880
which you can't write over here if n is at all large,

18:29.230-18:31.500
instead you just do something like this.

18:41.900-18:44.520
Or more likely, it'll look something like this, right?

18:45.110-18:49.120
F of n, and this will be n plus 1.

18:50.520-18:52.420
And this is what your event handler will do.

18:52.980-18:57.660
It will just call a single relatively fast function to get its work done,

18:58.250-19:00.460
and it'll say, okay, let's generate the next event.

19:01.920-19:09.640
So, this kind of application means you have to split up your program into digestible pieces,

19:10.440-19:10.540
right?

19:10.760-19:16.860
Where by "justible" I mean each little piece runs fast and then you glue the pieces together

19:17.920-19:18.720
by scheduling events.

19:20.860-19:24.760
And what that means is that at the lowest level you can still write four loops as long

19:24.780-19:26.680
as they're really small and fast, that's fine.

19:27.620-19:32.120
But any big loop or any big recursion, don't do that.

19:33.240-19:35.340
Instead split up your program in a different way.

19:37.659-19:42.120
Okay, any questions about this kind of programming?

19:42.420-19:44.360
It's a different way of building applications.

19:46.119-19:51.160
And you might see the phrase event driven.

19:54.300-19:55.420
Event driven applications.

19:56.680-20:02.200
Event-driven applications are by some measures the most common forms of programs on the planet

20:03.640-20:06.680
because they're extensively used in the Internet of Things.

20:07.520-20:13.300
If you look at the program inside the thermostat in your home or the braking system in your

20:13.440-20:14.740
car, it's probably event-driven.

20:18.340-20:18.980
Comments?

20:20.640-20:20.960
Yes?

20:21.100-20:21.460
Yes.

20:22.800-20:29.640
Is that a value to the event handler to allocate some separate computer resource to deal with

20:29.680-20:30.200
the task?

20:31.080-20:31.520
Oh, yeah.

20:31.630-20:37.380
As long as allocating the resource is something fast, like all you're doing is calling new

20:37.660-20:40.620
or emallocating, you know, just calling a constructor and that will finish quickly.

20:40.980-20:42.520
Sure, you can allocate a resource like that.

20:43.170-20:50.640
But if allocating a resource is going to take a long time, then you better not do it in the

20:50.660-20:56.800
way. Typically what you'll do is you'll take this resource allocation action and

20:57.060-21:01.620
split it up into smaller pieces. Each one can run fast. There may be some delay

21:01.820-21:05.700
between one phase and the next but that's what events are for. Yes?

21:15.159-21:19.800
Yeah, this is like the short-order cook that's you know cooking eggs for one

21:19.820-21:23.520
customer while cooking pancakes for the other while cooking toast for the third

21:23.760-21:27.760
person right and they're constantly sort of they're interrupt driven and you know

21:27.920-21:32.000
also they tend to be kind of busy people they're kind of hard to talk to their

21:32.080-21:36.280
brains sort of get scrambled after a while has anybody here ever worked as a

21:36.440-21:44.580
short order cook different world well it's a different world entirely but

21:44.740-21:48.520
anyhow I'm sure some of you have been event driven in your lives it's a

21:48.380-21:52.240
different way of thinking and to some extent if you've worked in one of these

21:52.500-21:56.600
event-driven sort of environments you'll have a better understanding for this

21:56.840-22:01.560
kind of curve right you always have to be prepared to drop what you're doing and

22:02.140-22:10.160
do something else completely other comments about this model remember what

22:10.160-22:14.340
I suggested in the first round of questions right whenever the professor

22:14.360-22:19.360
shows you something like this, you should think, I'm in the School of Engineering, I should worry

22:19.460-22:36.340
about how it breaks. Right? What can go wrong with this? Any thoughts? Yes. Yes. Right.

22:36.520-22:37.540
Because you're constantly

22:37.540-22:40.220
just generating a very large other,

22:40.720-22:43.880
that simple task becomes much more expensive.

22:44.140-22:48.920
You'll have more overhead this way than you will with the typical CS31 way.

22:49.040-22:49.260
Absolutely.

22:49.600-22:53.660
Because you have the overhead of generating event and, you know, get next event.

22:54.120-22:57.600
These functions are probably going to be pretty fast

22:58.140-22:59.880
because they're the heart of the event handling routine,

23:00.050-23:04.380
but they're still, you know, a lot slower than just execute the next instruction, right?

23:04.760-23:06.780
So there's going to be some performance overhead here.

23:06.960-23:12.280
That's very true compared to sort of doing things in the standard C or Fortran way.

23:12.500-23:12.640
Yes.

23:13.380-23:22.520
So because we're bringing things up into smaller steps, like say one of those steps, like there's an error that occurs, like something happens, and it puts the server
in an imbalanced state.

23:22.740-23:23.880
So you would have to like go

23:23.880-23:25.240
back and...

23:26.460-23:29.040
Right. You have to deal with errors.

23:32.580-23:33.700
Boy, that was scary.

23:34.400-23:42.360
You have to deal with errors in an event handling program, but to be fair, even when you're writing a conventional program, you have to deal with errors there.

23:43.580-23:55.320
So if the way you deal with errors is in sort of a very conventional way, you call a function, it returns a value, it says an error returned, then you figure out what to do
next.

23:55.760-24:00.540
You can just take that code and sort of put it in your event handlers, right?

24:00.720-24:03.700
And if an event fails, it can store that failure somewhere.

24:04.120-24:05.780
So the next event will know that, hey,

24:05.830-24:07.780
the earlier guy failed, all that sort of thing.

24:07.920-24:09.500
So it's doable, right?

24:10.040-24:12.080
But you know, it's still gonna be a pain.

24:12.860-24:15.920
If you're used to dealing with errors

24:16.540-24:21.900
via exception handling, things get hairier here, right?

24:22.000-24:25.040
Because you can't have one event throw an exception

24:25.900-24:27.600
that the next event will catch.

24:28.320-24:29.580
It doesn't work that way at all.

24:30.280-24:32.340
So you're gonna have to sort of deal with errors

24:32.450-24:34.800
in a more conventional way than with a try catch

24:35.180-24:37.040
sort of thing if you're used to doing things that way.

24:38.880-24:42.860
I like people thinking about errors because in practice,

24:43.540-24:46.600
in software construction, at least the kind of code I write,

24:46.940-24:49.160
more than half the time I'm worried about error handling,

24:49.480-24:51.160
when things will go wrong, right?

24:51.660-24:53.040
And maybe it's the engineer in me

24:53.190-24:56.120
or maybe it's just 'cause I like to write

24:56.420-24:57.940
reliable programs, I'm not sure.

24:58.700-25:00.080
Can other things go wrong with this?

25:01.360-25:01.480
Yes?

25:01.700-25:02.740
- Can things happen out of order?

25:03.360-25:05.900
- Oh, yes, right?

25:06.460-25:11.420
You expect the events to arrive in order A, B, C,

25:12.500-25:15.080
but the outside world is in charge of them

25:15.760-25:17.960
and it ships them to you in BCA.

25:18.240-25:19.200
Now, what do you do?

25:20.140-25:22.680
In some sense, that's more opportunities for errors

25:23.160-25:24.340
and you're gonna have to check for that.

25:25.300-25:25.680
Good point.

25:27.180-25:29.300
All right, well, so to some extent,

25:29.920-25:33.000
this is what JavaScript is doing, right?

25:35.280-25:37.840
It seems like in some sense it's a mistake, right?

25:39.100-25:43.640
It's slower, it makes you sort of think about code

25:43.660-25:46.580
in a weird way and all that sort of thing.

25:47.320-25:52.080
Is there any advantage to doing things in this strange way?

25:52.460-25:54.340
And there is one important advantage

25:54.440-25:56.160
that I should tell you about, right?

25:57.060-25:58.420
And that advantage is the following.

25:59.180-26:02.160
There are no locks on resources.

26:05.280-26:06.700
What do I mean by that?

26:08.280-26:11.260
Ordinarily, if you want to write a web server

26:11.300-26:14.800
that can handle lots of requests simultaneously,

26:16.000-26:19.380
a standard way to do it is to write multi-threaded code.

26:20.740-26:24.780
A multi-threaded application is one that you are,

26:25.320-26:28.620
That same application is using multiple cores on your machine.

26:29.440-26:32.060
All the-- each of those cores has its own instruction pointer.

26:32.370-26:35.620
So each of those cores is running some part of your program and all the parts

26:35.620-26:40.040
of your program are collaborating by getting their own work done

26:41.580-26:47.140
and communicating to each other via shared memory that has locks, right?

26:48.280-26:57.280
These locks prevent races in multi-threaded applications.

27:02.760-27:10.160
The reason you need the locks is because if two different threads, maybe corresponding to two different, you know, web requests,

27:10.900-27:17.860
try to enroll somebody in the class at the same time, they have to make sure that they don't step on each other's toes.

27:18.220-27:22.880
and the way they do that is each attempts to lock the resource representing the class.

27:23.620-27:27.860
The one that wins and gets the lock will then be able to enroll that person.

27:28.900-27:34.660
Finally, when they give up the lock, the next sort of thread will then get access to the class,

27:34.920-27:37.640
find out that the class is fully enrolled and give up, right?

27:37.940-27:41.660
So you use locking to prevent race conditions.

27:42.620-27:46.960
Race conditions occur when two different threads access the same thing at the same time.

27:47.860-27:54.220
These races are perhaps the most common error in multithreaded programs.

27:55.440-27:56.960
They're very hard to debug.

27:58.050-28:05.540
You can have the same program sort of run successfully a thousand times in a row because it has race condition bugs.

28:05.610-28:09.540
You just didn't trigger them. And then the thousand and first time, it doesn't work.

28:10.870-28:13.220
All right? We don't have to worry about that here.

28:14.460-28:20.420
The reason we don't have to worry about it is because when this event handler fires,

28:21.160-28:22.540
nobody else is running.

28:23.420-28:25.160
This is a single threaded while loop.

28:26.800-28:34.060
So in some sense, what an event-driven application gives you is sort of something that acts like multi-threading.

28:34.510-28:38.700
You can juggle several different web requests sort of in the air at the same time,

28:39.500-28:44.640
But whenever you're actually doing something, you know none of the other web requests is running.

28:44.690-28:48.140
And so you don't need to grab locks on resources.

28:48.860-28:52.220
Grabbing locks, first off, takes some time.

28:53.110-28:57.660
And second, reduces the amount of parallelism so you don't get the benefit of the multiple cores.

28:57.880-28:59.700
Locks are just a disaster, right?

28:59.810-28:59.980
And

28:59.980-29:01.340
you're avoiding that disaster here.

29:02.700-29:04.900
You should thank your lucky stars you're avoiding it.

29:05.580-29:12.060
And later courses in this department, you'll be doing multi-threaded applications and get to deal with all that problems.

29:12.250-29:16.120
But at least for this assignment, you don't have to worry about it.

29:17.840-29:18.320
All right.

29:21.840-29:25.140
Can anybody see another problem with this approach?

29:27.220-29:30.600
There's got to be a catch besides the ones we've mentioned.

29:32.140-29:40.500
And in fact, I've already hinted at one of the major catches to having an event-driven program, right?

29:41.740-29:46.040
Here's a plus, but it comes with a minus.

29:49.340-29:55.480
There is a big advantage of multithreaded applications over event-driven.

29:57.440-30:00.920
And that's the reason why people write all these multithreaded applications, right?

30:00.960-30:03.280
If you look inside, I don't know, Chrome.

30:03.740-30:05.040
Chrome is heavily multithreaded.

30:06.080-30:06.500
Why?

30:08.020-30:08.400
Yes.

30:09.740-30:11.200
Performance, right?

30:12.110-30:16.120
The advantage of a multithreaded application is you get true parallelism.

30:16.800-30:19.040
You have multiple cores in your laptop.

30:19.280-30:20.320
You've got an eight-core laptop.

30:20.570-30:24.640
If you're lucky, all eight cores are executing actual code that gets useful work done.

30:24.640-30:26.880
It runs eight times as fast, right?

30:27.520-30:31.480
So a downside of this approach is that you don't get any parallelism.

30:35.740-30:38.840
This is how I write parallelism, two parallel lines and then ism, right?

30:39.680-30:45.460
You get sort of a fake parallelism where there's just a single sort of thread of control,

30:45.640-30:48.500
a single CPU, a single core, whatever you want to call it,

30:48.700-30:50.780
and it's jumping around handling lots of requests,

30:51.440-30:54.120
but of course it's limited by how fast it can run.

30:55.720-31:04.920
The reason this sort of thing can work with Node though is that for many applications, CPU is not a problem.

31:06.040-31:12.580
You've got CPU to burn. Your web server's CPUs are mostly just sitting around not doing anything.

31:12.630-31:16.740
They're twiddling their thumbs. Your browser is kind of the same way.

31:17.430-31:22.220
If you take a look at how often all eight cores of your laptop are actually running,

31:23.000-31:26.240
It's a vanishingly small percentage of the time the laptop's operating.

31:27.100-31:32.100
So for many applications, the fact that you don't get true parallelism is no big deal.

31:32.900-31:35.640
And in fact, that's certainly going to be true for assignment three.

31:38.760-31:43.080
Can anything else go wrong with this style of approach?

31:43.740-31:43.900
Yes.

31:44.120-31:44.960
Is it a single point

31:44.960-31:45.280
of failure?

31:46.460-31:46.580
Yes.

31:47.620-31:47.740
Right?

31:48.320-31:57.220
If one of your event handlers crashes, doesn't work, or worse, loops, just goes into a loop.

31:58.420-31:59.980
Everybody's stuck, right?

32:00.270-32:01.760
So that's a downside of this approach.

32:02.200-32:10.440
This approach is suitable if your application is sort of one big happy application written by people who trust each other,

32:10.730-32:13.800
and they're all competent and everything works, right?

32:13.980-32:20.580
But if you assume that some of the software is written by people who have buggy software or worse,

32:21.340-32:24.460
they're adversaries, they're trying to make the system crash,

32:25.340-32:28.340
then this approach obviously is totally bogus, right?

32:28.700-32:32.540
Because any one of these event handlers can bring down the entire system.

32:34.980-32:35.760
Oh, all right.

32:36.200-32:39.000
Other comments about the approach?

32:40.660-32:42.580
All right, let's see if I have any of my own.

32:45.040-32:54.000
Okay. Now, you know, this idea I should mention is it's not just node.

33:01.520-33:06.180
There's sort of lots of other systems that do something like this.

33:06.880-33:13.320
For example, Ruby, a system we won't have time to examine at all in this course, has something called the event machine.

33:17.980-33:25.880
The event machine is a way of building while loops that look like this, and you can deploy them in several different places in your Ruby application.

33:29.020-33:34.080
Python has lots of different approaches that work like this.

33:35.240-33:40.880
One classic approach is the twisted application that runs under Python, the twisted module.

33:41.520-33:49.140
It's popular enough that Python now has its own async.io sort of package built into Python,

33:49.320-33:54.080
and basically async.io lets you do stuff like this.

33:54.720-34:00.200
It's called async.io because you don't ever do reads or writes.

34:00.820-34:03.680
Instead, you just have something that starts a read.

34:04.860-34:07.800
Right? And then when the read request is done, you get an event.

34:08.600-34:12.100
You can start a write. Starting a write immediately finishes.

34:12.379-34:16.280
Doesn't take very long time. And then when the write finishes, you get another event.

34:16.320-34:20.340
And that's basically what async.io is for. And once you have async.io, you can do

34:20.720-34:22.679
sort of event-driven programming in Python.

34:24.260-34:24.419
Question?

34:24.800-34:25.399
Is there a difference

34:25.399-34:27.540
between just doing the read or something?

34:29.240-34:36.679
So ordinarily, if I'm talking like read and write in C++ or C something like that, these are synchronous.

34:38.379-34:41.100
The actual system call will look something like this, right?

34:41.520-34:47.460
Read zero buff a thousand, right?

34:48.200-34:50.000
Where this is an array.

34:54.220-34:57.580
And this says, please read up to a thousand bytes into this buffer.

34:58.220-35:03.500
Once you've read them, then return and tell me how many bytes you actually read successfully.

35:04.480-35:07.260
And if n is negative, that means there was a read error and all that sort of thing.

35:07.380-35:13.380
But the point is, this call to read doesn't return until those bytes are sitting there in the buffer.

35:14.160-35:19.740
And it has to wait until then because immediately after this, we might want to print out one of those bytes.

35:19.820-35:19.960
Right?

35:24.640-35:26.900
So this call to read is synchronous.

35:28.040-35:30.020
It waits till the read is done.

35:31.110-35:33.440
And that's the classic way people do I/O.

35:33.700-35:36.380
When you put in print statements in your C program,

35:36.760-35:38.400
when the print returns, you expect that stuff

35:38.450-35:39.360
to be printed, right?

35:40.020-35:42.240
Similarly with C++, right?

35:42.500-35:45.580
So that's not what we want with async I/O,

35:46.140-35:47.640
and it's not what we want in Node.

35:48.760-35:52.220
We want the ability to say, let's just do I/O,

35:52.760-35:53.660
but we'll just start it.

35:54.480-35:57.240
And when it finishes, we'll get notified by an event.

35:59.760-36:03.280
Other comments about this technology?

36:03.820-36:04.180
All right.

36:04.700-36:08.380
Well, you can build anything with Node,

36:09.160-36:10.660
any kind of application that you like.

36:12.940-36:16.620
You can build whatever you like,

36:16.880-36:18.560
but they built a web server.

36:29.900-36:34.120
You can also build a browser and you can build other stuff.

36:34.180-36:38.400
But basically in this class you will use a web server.

36:38.700-36:42.460
And you know I should mention by the way node is written in JavaScript.

36:49.060-36:54.160
And if you know anything about JavaScript, I will talk more later in this course about

36:54.180-36:56.940
it, but basically JavaScript is designed for browsers, right?

37:02.640-37:06.760
It was originally designed for browsers back, you know, in the late 1990s.

37:06.900-37:08.540
So what's going on here?

37:09.540-37:14.779
What they've done is they've taken this technology designed for browsers and say, "Let's just

37:14.800-37:22.500
run this JavaScript code in a different program, one that doesn't have a display, doesn't have

37:22.500-37:25.940
a mouse, doesn't have a keyboard, doesn't have anything like that. It's just JavaScript

37:26.420-37:33.700
running in its own process on a Linux server somewhere, and JavaScript can do that. It's

37:33.760-37:39.320
just a programming language. And so they wrote Node, a Node web server in Node, you know,

37:39.940-37:52.940
in the browser, right? It's running in some random process. For example, it's possible

37:52.950-37:59.440
to imagine a new version of Emacs. I'll call it JS Emacs. It works just like Emacs except

37:59.700-38:08.799
its extension language is JavaScript, not Lisp. Simple software engineering exercise. I could

38:08.600-38:14.360
assign it as a homework problem for this class. Well, all right, for the next class, right?

38:15.140-38:19.200
Right, well, in a sense, that's what they've done. They built a web server that way, right,

38:19.480-38:23.440
except, you know, you get rid of the display and you get rid of the keyboard and all that sort of

38:23.500-38:27.360
thing, okay? And there's lots of libraries available

38:36.260-38:37.060
for this web server.

38:37.240-38:40.720
There's a whole ecosystem of running node in web servers

38:41.340-38:42.700
and running JavaScript code there.

38:42.730-38:45.420
Now, if you're building a client server application,

38:46.180-38:49.500
what that means is if you have an idea

38:50.640-38:52.960
and you can write it down in JavaScript,

38:53.050-38:54.480
you can implement it in JavaScript,

38:55.500-38:56.360
now you have a choice.

38:57.500-39:03.080
You can either have your JavaScript code run in the browser, if that's an appropriate place for it to run,

39:04.240-39:09.200
or you can have it run in the web server, if it's a better place to put it as the web server.

39:09.900-39:14.840
Or maybe you'll decide, depending on the application, am I going to run the code here or there, right?

39:15.120-39:20.120
It makes your code more portable, makes your ideas more flexible.

39:20.920-39:27.360
You can decide on an application per application basis whether to run some stuff on the client or on the server.

39:27.840-39:33.680
And that's one of the big advantages of Node as opposed to lots of other ways that you can build web servers.

39:35.040-39:36.920
So let's take an example of this.

39:38.060-39:41.600
If I go and there's a Node in here somewhere.

39:41.760-39:42.740
There we go, Node-ish.

39:43.840-39:46.120
I have a directory called nodeish,

39:47.010-39:51.060
and in that directory I have a file called app.js,

39:52.140-39:53.940
and if we look at that file, here's some code.

39:55.140-39:56.580
This is JavaScript code,

39:57.630-40:01.240
and it's designed to run in the node environment.

40:02.560-40:04.900
So since I haven't yet given you

40:05.040-40:06.760
a single line of JavaScript code,

40:06.770-40:08.960
I feel it's only fair to write a little bit

40:09.120-40:10.720
and put it on the screen and explain it.

40:11.080-40:13.720
Remember, I'm not a JavaScript expert, all right?

40:13.820-40:18.500
So if you have any detailed questions about this, I'll probably say, oh yeah, that's an interesting question.

40:19.300-40:24.440
First line says, I'd like to use the HTTP module.

40:25.720-40:28.800
So let's require that and we'll call it HTTP.

40:29.480-40:32.140
Now, I could call that module anything I like.

40:32.140-40:35.140
I could call it X or I could call it foobar.

40:35.590-40:43.340
But it's very typical that you'll take a module that's named X and then give it that same name in your program.

40:44.520-40:55.240
I should mention here that JavaScript, unlike Python and unlike C++, doesn't really believe in classes.

40:56.840-41:06.000
It has some sort of object-oriented attitude, but it doesn't have the same sort of classes that Python does.

41:06.180-41:11.280
So, you know, a module is just another object and I'm calling it HTTP and later on I can,

41:11.400-41:13.720
you know, assign HTTP to something else.

41:14.800-41:21.240
Second line, I'm assigning a local variable called IP, well, a global variable I should

41:21.340-41:25.520
say, and it's the string 127.0.0.1.

41:26.200-41:27.260
That's an IP address.

41:28.480-41:33.720
By convention, that particular IP address is the address of the machine that we're currently

41:33.960-41:34.320
running on.

41:35.400-41:41.820
So this particular web server is going to be very much just a toy web server.

41:41.960-41:44.400
It's not going to run on the internet and serve anybody.

41:45.360-41:51.020
Instead, it's only going to run on my laptop, and any client that wants to talk to this web server

41:51.300-41:52.860
also has to be running on my laptop.

41:53.600-41:57.600
In some sense, we're missing half the point of a client-server application, but that's okay.

41:57.700-41:58.480
It's just a toy.

41:59.920-42:02.640
The third constant is an integer.

42:04.360-42:07.640
it's the number 3000 and we're assigning that

42:07.880-42:10.840
to the variable name port, well, the constant port,

42:10.860-42:11.460
I should say.

42:12.280-42:15.960
Now, JavaScript has strings, as you can see in line two,

42:16.620-42:19.380
and it also has numbers, as you can see in line three.

42:19.780-42:22.660
I should warn you that its attitude towards numbers

42:23.120-42:25.980
differs from most other programming languages.

42:27.280-42:31.339
In Python, there's the integer 3000

42:31.360-42:34.660
And there's the floating point number, 3000.0.

42:35.420-42:37.920
And they're quite different things, right?

42:38.020-42:39.940
They're represented differently internally.

42:40.620-42:42.580
One, if you add to it, you'll get rounding errors

42:42.620-42:43.320
and all that sort of thing.

42:44.440-42:46.920
JavaScript tries to keep things simple by saying,

42:46.960-42:48.600
no, no, no, no, we just have numbers.

42:49.340-42:53.400
And this 3000 is just the same thing as 3000.0.

42:53.520-42:54.820
There's no difference between the two.

42:55.500-42:58.220
It'll print it out as 3000 because it happens to be an integer.

42:58.980-43:01.240
but there's really no difference between integers

43:01.370-43:03.420
and floating point numbers, and I'm telling you this now

43:03.550-43:04.860
because you'll run into it eventually.

43:05.120-43:06.720
It's not really important for this application.

43:08.940-43:10.940
All right, line four.

43:11.940-43:15.700
Well, we finally are using that HTTP constant

43:16.060-43:17.640
that we set up in line one.

43:18.860-43:22.580
That constant has a method, create server,

43:23.100-43:24.660
associated with it, right?

43:25.300-43:27.899
And we're going to call create server

43:27.920-43:36.980
with a single argument and that single argument is an unnamed function. In JavaScript these

43:37.030-43:44.680
things are often called callbacks. So the way you write a function without any name in JavaScript

43:45.560-43:56.280
is you do something that looks like this. This is a function with three arguments a, b, and

43:56.100-44:02.400
see if you call it it will execute all the code inside the curly braces and we

44:02.480-44:08.340
can take this function and give it a name f if we want to but we don't have to

44:09.360-44:13.520
we could immediately just take this function not give it a name and you know

44:13.680-44:16.840
pass it to some other function that's what we're doing here we're just calling

44:18.020-44:24.099
HTTP create server and saying oh here's the callback that I want you to

44:24.120-44:27.800
execute when you get a web request.

44:28.910-44:31.560
And what create server is going to do is,

44:32.090-44:36.140
you know, eventually it's going to set up an event loop like this

44:38.700-44:40.820
inside the server that we're creating.

44:41.850-44:44.540
And somewhere deep inside that event loop it will say, well,

44:44.690-44:49.460
if I get a web request as opposed to all the other kind of events that could happen to me,

44:50.220-44:52.600
The way I'm going to handle it is by calling this callback.

44:54.300-44:57.820
The parameters to the callback are two objects.

44:58.450-45:00.480
The first is the request object,

45:01.740-45:05.100
which create server will arrange to be an object

45:05.130-45:07.200
that tells us all about the request that came in.

45:08.160-45:10.540
The second argument is the response object,

45:11.400-45:13.400
which create server will arrange.

45:13.530-45:15.840
When it calls this callback,

45:15.930-45:17.819
it will arrange for the response object

45:17.840-45:20.160
to be some sort of random vanilla response.

45:21.440-45:22.900
And our goal is going to be,

45:23.480-45:25.280
we fill in the details of that response

45:26.680-45:28.520
so that the server will know

45:28.900-45:30.600
what to ship back to the original client.

45:32.120-45:36.460
All right, so our particular web server is really simple.

45:37.020-45:38.860
No matter what the request is,

45:39.560-45:42.580
if the request is, please make a cup of coffee,

45:42.760-45:45.140
if the request is, please enroll me in this class,

45:45.580-45:47.600
if the request is, tell me what time it is,

45:47.740-45:51.540
We ignore it and we just issue the same response.

45:52.620-45:54.020
Doesn't matter what the request is.

45:54.300-45:55.020
What's our response?

45:55.960-45:58.200
Our response has three components.

45:59.400-46:03.480
The first is, is this a successful response

46:04.200-46:05.260
or a failed response?

46:05.460-46:08.120
If it's a failed response, what kind of failure is it?

46:08.600-46:12.960
By convention, status code 200 means I succeeded.

46:14.460-46:15.900
There's a whole list of status codes.

46:16.140-46:19.660
They're all documented somewhere, but for now, we'll just remember 200 means it worked.

46:21.180-46:24.000
Anybody else know any response codes off the top of their head?

46:24.580-46:26.420
If you're a web developer, you know all these numbers.

46:26.520-46:26.640
Yes.

46:27.420-46:28.860
404 is one of my favorite.

46:29.180-46:30.380
That means it didn't exist.

46:30.860-46:31.000
Yes.

46:32.640-46:33.460
Yes, exactly.

46:33.860-46:37.360
There's all sorts of numbers here, but 200 means it worked, right?

46:39.000-46:39.260
Header.

46:41.260-46:45.800
That header says, take the header that was the vanilla header that was in the original

46:46.120-46:51.640
response and change it so that it has the following line somewhere in the header.

46:52.180-46:53.200
The line will look like this.

46:58.410-47:03.260
Content type, oh, with a capital T, text plain.

47:08.120-47:14.140
When you ask a web server a question, it gives you an answer, but at the start of the answer,

47:14.640-47:17.320
it gives you meta information about the answer.

47:17.960-47:20.240
This is going to be part of that meta information.

47:20.960-47:26.060
Our meta information says the response I'm about to give you is plain text.

47:26.580-47:31.420
It's not anything fancy like HTML or XML or JSON or anything like that.

47:31.900-47:33.100
It's just plain text.

47:34.560-47:37.200
So that's what that set header line does.

47:38.060-47:45.700
The third line, response.end, basically specifies the contents of the response, the end of the

47:46.060-47:46.260
response.

47:46.440-47:48.720
We'll see later why it's called the end.

47:49.660-47:57.940
So what this callback does is it fills in the response with a minimal set of values enough

47:58.080-48:02.660
so that this will actually be a web server that will actually run and then it returns.

48:04.680-48:10.040
At that point, it's up to the web server that create server created to figure out what to

48:10.040-48:10.860
do with the response.

48:10.990-48:15.900
What it will do is convert this information into a bunch of bytes that it will ship back

48:16.120-48:18.520
out to the original client that asked the question.

48:20.800-48:21.140
Question?

48:22.720-48:27.000
Like request and response by convention, would you change the names?

48:27.720-48:32.100
Oh yeah, the name request and response, they're just local variables like A, B, and C over

48:32.220-48:32.320
there.

48:33.160-48:36.440
I could call them Q and R as long as I changed all instances

48:36.580-48:38.020
of response to R it would still work.

48:38.180-48:41.400
It's just local variables to that callback.

48:42.260-48:42.640
Good question.

48:43.320-48:44.380
Other comments, yes?

48:44.880-48:45.520
- Would the status

48:45.520-48:47.740
code be under

48:47.880-48:50.120
so if something was wrong, like if it's not fake?

48:52.720-48:54.800
- It should be some value other than 200

48:54.960-48:55.600
because it didn't work?

48:55.600-48:57.020
- It should be below response.

48:57.540-49:00.419
- Oh, but all we're doing in this callback

49:00.440-49:02.560
is we are storing into an object.

49:04.400-49:06.540
In JavaScript, objects are pretty simple.

49:06.860-49:08.000
You can think of an object

49:08.160-49:10.000
as a collection of name value pairs.

49:10.660-49:13.960
We are setting three components of that object

49:15.260-49:16.600
to particular values.

49:17.160-49:23.040
And in some sense, it can't fail.

49:23.600-49:24.860
Well, until we call end.

49:25.100-49:26.880
End might screw up because you ran out of memory

49:26.880-49:28.600
or something, but those first two guys,

49:28.820-49:30.160
They can't fail at all, right?

49:30.800-49:33.040
And I don't know, if N runs out of memory,

49:33.200-49:34.560
it's probably going to crash the whole server.

49:34.640-49:36.680
So to some extent, it doesn't really matter

49:37.140-49:39.540
whether we call a set status code first

49:39.680-49:40.900
or set it after set header.

49:41.020-49:44.060
We're just storing slots in the response.

49:45.960-49:47.120
All right, question?

49:52.140-49:54.280
Yeah, it's an object-oriented system

49:54.520-49:58.119
just like Python or the object-oriented part

49:58.140-50:04.500
of C++, every object is really represented by a pointer to the actual value. Other comments?

50:06.720-50:14.240
All right, so that callback will set up the response object, but it won't actually do

50:14.500-50:21.220
anything, right? The code that actually does something is buried inside the web server

50:21.260-50:27.239
that HTTP create server created. All we're doing in our callback is kind of fiddling

50:27.260-50:32.040
with how that web server behaves at just the right moment so it'll behave the way we like.

50:33.140-50:39.040
Now this last three lines are where we actually do something with our server.

50:39.180-50:45.300
Notice we had a line called const server equals that sets a constant called server to be this

50:45.580-50:48.480
object and we're going to call the listen method.

50:49.040-50:55.919
What that does is it tells the server, "Hey, it's time to wake up and listen to the outside

50:55.940-51:02.480
world. The place you're going to listen is specified by the first two arguments. The

51:02.700-51:08.200
port is the TCP port, we'll talk more about that later. The IP address is the IP address

51:08.440-51:13.180
you're listening on. You're going to be a web server that's listening to requests coming

51:13.380-51:24.600
in to IP address 127.0.0.1 on port 3000. Okay? And notice that the last argument to the

51:24.460-51:27.020
the listen method is another callback.

51:28.660-51:30.680
When I write something that looks like this,

51:35.040-51:37.740
I'm writing a nameless function that takes no arguments

51:38.630-51:39.860
and when you call that function,

51:40.260-51:42.360
it executes the code in the curly braces, right?

51:42.800-51:48.240
So we are not actually executing this console.log line now,

51:49.080-51:51.340
we're just stuffing that into a callback.

51:52.260-51:57.400
That callback will be executed whenever the server starts up.

51:58.520-51:58.620
Okay?

51:59.800-52:01.120
So two different callbacks.

52:01.560-52:03.600
The second callback is gonna be executed

52:03.780-52:04.480
when the server starts.

52:05.140-52:07.040
The first callback is gonna be executed

52:07.340-52:08.940
every time the server gets a web request.

52:11.320-52:11.640
All right.

52:14.380-52:19.620
Well, let's give it a start, except let's take a break,

52:20.020-52:21.640
And we'll start up at 5 past the hour.

01:00:58.779-01:01:00.440
All right, let's start up again.

01:01:00.830-01:01:02.140
In the break, it was pointed out,

01:01:02.150-01:01:05.120
I forgot to mention the second line from the end

01:01:05.270-01:01:10.580
uses some new kind of technology that we haven't seen before.

01:01:11.320-01:01:15.200
And this string that's in that second line from the last

01:01:15.290-01:01:17.800
is not surrounded by apostrophes.

01:01:18.480-01:01:22.680
It's surrounded by Grav accents, back quotes, right?

01:01:22.900-01:01:24.660
This symbol instead of this symbol.

01:01:25.440-01:01:35.260
And that's a special sort of syntax in JavaScript that says this string is not just the characters that you see,

01:01:36.340-01:01:42.660
but if you see dollar sign, open curly brace, name, close curly brace somewhere in that string,

01:01:43.300-01:01:46.800
please substitute the value of that variable

01:01:48.720-01:01:51.540
for all the stuff in dollar signs.

01:01:51.640-01:01:54.760
So this is equivalent to saying server running

01:01:55.140-01:02:03.820
at HTTP colon slash slash 127.0.0.1 colon 3000 slash.

01:02:05.900-01:02:09.400
It's just that it's documenting itself somewhat nicer

01:02:09.400-01:02:11.900
than if we just wrote out the same constant twice.

01:02:13.120-01:02:24.920
So we should be able to start this up by running something like this, assuming that you have

01:02:25.080-01:02:26.400
Node installed on your computer.

01:02:27.280-01:02:31.800
And what Node has done is it has set up the server, right?

01:02:31.940-01:02:34.200
It's actually just executed this JavaScript code.

01:02:34.310-01:02:39.020
The first thing the JavaScript code did is it executed that line that said, "Hey, I'm

01:02:39.160-01:02:39.260
running.

01:02:40.080-01:02:42.119
And here I am."

01:02:42.140-01:02:52.200
And we can connect to that particular server by just using a browser and specifying that

01:02:52.440-01:02:59.020
particular IP address which local host is just a synonym for and talking to it.

01:02:59.540-01:03:07.740
And in kind of small print here, you've seen the response, right?

01:03:08.140-01:03:13.660
We got a very simple response that said whatever that event handler was told to say.

01:03:14.240-01:03:19.620
If at this point we type control I, we can see information.

01:03:20.740-01:03:28.840
This is meta information about the system and notice it says type colon text slash plain.

01:03:29.960-01:03:35.840
That's because the browser saw that line in the header of the response and said oh, oh,

01:03:36.040-01:03:38.480
I know this is plain text rather than being HTML.

01:03:40.740-01:03:43.080
All right, so any questions?

01:03:43.300-01:03:44.960
We now have a client server application.

01:03:45.780-01:03:46.680
It's kind of a dumb one,

01:03:47.840-01:03:49.860
but every time we ask it something,

01:03:50.060-01:03:51.580
it'll always tell us the same answer.

01:03:52.420-01:03:53.280
But as you can imagine,

01:03:53.440-01:03:55.420
you can write something more interesting than this

01:03:56.040-01:03:59.100
if you put something more interesting in the node code.

01:04:00.660-01:04:03.780
All right, any questions about sort of starting this up?

01:04:06.760-01:04:08.000
All right, so I've done the demo.

01:04:08.400-01:04:11.760
Now I can go back and talk about more general principles

01:04:12.340-01:04:14.860
about building these kinds of applications, right?

01:04:15.300-01:04:18.680
So we have sort of the client server basic model,

01:04:26.800-01:04:28.060
which I've already mentioned,

01:04:28.800-01:04:33.260
but I feel like I should also talk about alternatives.

01:04:39.920-01:04:46.980
With client-server, you have one or possibly lots of clients talking by the network to the server.

01:04:48.980-01:04:53.460
The server has the state and in some sense is in charge of the application.

01:04:53.660-01:04:59.220
At least if there's any information that needs to be shared amongst various clients, the server has got it.

01:04:59.820-01:05:04.360
The clients can only communicate to each other indirectly via the server.

01:05:05.380-01:05:09.540
But there are alternatives to this, including peer-to-peer.

01:05:13.200-01:05:18.720
In a peer-to-peer application, you have a whole bunch of peers connected to the network.

01:05:22.060-01:05:27.940
Each peer has its own state, its own idea about the state of the system.

01:05:30.740-01:05:36.720
And in some sense this is nicer because if a peer wants to know something like who's

01:05:36.900-01:05:41.540
enrolled, it can just ask its own copy of the state.

01:05:41.860-01:05:43.460
Say, who's enrolled in this class?

01:05:43.620-01:05:45.400
And the copy will contain that information.

01:05:46.680-01:05:52.920
But as you can imagine, this kind of system is going to be more complicated because now

01:05:52.920-01:05:58.360
Now you have to deal with the possibility that this peer has enrolled somebody in the class.

01:05:58.700-01:06:00.580
These peers don't know about it yet.

01:06:01.860-01:06:06.260
And this peer has to arrange to propagate the information in its copy of the state into

01:06:06.260-01:06:07.020
the other copies.

01:06:08.500-01:06:12.260
Generally speaking, peer-to-peer systems are even more complicated than that.

01:06:13.620-01:06:16.800
Some peers will have more of the state than others.

01:06:18.040-01:06:25.700
no single peer has a copy of the entire state of the system. They have to collectively agree upon,

01:06:26.460-01:06:31.780
you know, who's going to be in charge of which part of the state and so forth and so on. So this

01:06:31.780-01:06:38.400
is going to be a more complicated approach. However, it has some advantages over client-server.

01:06:39.460-01:06:47.440
Client-server approaches have scaling problems. Once you have a thousand or a million clients,

01:06:48.360-01:06:49.820
this server is going to get overloaded.

01:06:51.030-01:06:53.100
So they won't scale very well.

01:06:54.960-01:06:57.580
A few hundred clients, as long as the server is well written

01:06:57.770-01:06:59.320
and it's not doing all that much, you're fine.

01:06:59.320-01:07:01.800
But once you talk about zillions of clients, watch out.

01:07:02.340-01:07:04.240
A peer-to-peer system, if done right,

01:07:05.220-01:07:06.360
it's going to be more complicated

01:07:07.280-01:07:10.280
and maybe it's going to be less efficient with small numbers of peers,

01:07:10.520-01:07:12.760
but it should scale better if it's written well.

01:07:14.720-01:07:19.180
Another approach is what I'll call a primary-secondary approach.

01:07:19.390-01:07:20.660
I guess I should write it over here.

01:07:26.640-01:07:29.880
There's no sort of generally accepted term for this.

01:07:30.110-01:07:32.560
To some extent, I'm just making up a term, but that's all right.

01:07:32.700-01:07:33.480
Somebody has to do it.

01:07:34.020-01:07:39.280
Under this approach, there is a primary sort of machine attached to the network

01:07:39.820-01:07:41.780
that's in charge of your computation,

01:07:42.660-01:07:48.700
And you have a bunch of secondary machines, each doing a little bit of the computation.

01:07:54.060-01:07:56.800
So you can think of the secondary machines as being worker bees,

01:07:57.940-01:08:01.620
each one of them in charge of doing a particular part of your machine learning

01:08:01.800-01:08:04.200
or a particular part of your database system or whatever.

01:08:04.920-01:08:09.400
The job of the primary is to schedule the work for the worker bees.

01:08:10.320-01:08:14.220
It knows what each of these secondary machines is doing.

01:08:14.570-01:08:17.500
It keeps track of all the tasks that need to be done.

01:08:17.910-01:08:23.200
When a secondary machine says, okay, I'm done, boss, the primary says, oh, here's another thing for you to do.

01:08:25.080-01:08:33.560
This kind of application or architecture, I should say, is suitable for a lot of big sort of things.

01:08:33.830-01:08:36.600
Machine learning applications are often done this way.

01:08:38.000-01:08:42.000
I've given you three examples of distributed architectures.

01:08:42.420-01:08:44.960
As you can imagine, there's lots more where this came from.

01:08:45.720-01:08:49.620
But the reason I wanted to show you at least two alternatives of client-server

01:08:49.620-01:08:53.140
is I didn't want you to think that everything that's done in Node

01:08:53.680-01:08:56.779
or in similar technologies is always going to be client-server.

01:08:58.920-01:09:04.839
All of these models, client-server, peer-to-peer, primary, secondary,

01:09:05.819-01:09:09.040
have problems, okay?

01:09:11.779-01:09:15.100
And too many problems for us to talk about all of them.

01:09:15.880-01:09:18.120
But let's talk about some of the common problems

01:09:22.420-01:09:24.060
in distributed applications.

01:09:29.339-01:09:31.400
And I'm not going to talk about all of them,

01:09:31.620-01:09:35.120
but I'm going to talk about two major categories of problems.

01:09:35.990-01:09:38.819
The first problem is a performance problem.

01:09:43.580-01:09:45.900
We want these applications to run fast.

01:09:47.020-01:09:50.540
And as I kind of suggested, if you scale right,

01:09:50.540-01:09:52.700
you can actually get really good performance out of these

01:09:52.710-01:09:54.460
because you're doing a lot of the work in parallel.

01:09:55.840-01:10:01.060
But if you're doing a relatively simple client-server application,

01:10:01.380-01:10:04.420
or even some of these other applications where there aren't that many machines,

01:10:04.690-01:10:07.040
the parallelism isn't all that great,

01:10:07.670-01:10:13.560
and you start to run into some other problems that you don't run into in CS31.

01:10:15.120-01:10:21.260
These performance problems can be divided sort of into two major categories.

01:10:23.680-01:10:27.940
Throughput problems and latency problems.

01:10:31.280-01:10:36.720
Throughput is how much work can you shove through the system per unit of time?

01:10:37.620-01:10:39.680
You've got, say, a client-server system.

01:10:40.370-01:10:46.540
How many requests per second total can it take from clients before it starts to get overloaded?

01:10:46.760-01:10:53.980
The more requests per second it can handle, the happier the person who bought the server will be

01:10:54.000-01:11:00.620
because the server is, you know, they spent, you know, $10,000 on the server, and it can handle 100,000 users.

01:11:01.240-01:11:04.900
If you can raise that number to 110,000 users, they'll be happier, right?

01:11:05.200-01:11:08.500
110,000 requests per second, that's actually doing pretty well, right?

01:11:09.060-01:11:16.880
So here, what we're trying to do is sort of do as many things in sort of quasi-parallel as possible.

01:11:17.880-01:11:24.360
do sort of actions in sort of parallel.

01:11:27.660-01:11:31.400
Or another option that you can do that's very common,

01:11:32.100-01:11:33.800
particularly in node-based applications,

01:11:34.560-01:11:35.860
is you can do them out of order.

01:11:40.760-01:11:41.920
When might that happen?

01:11:43.160-01:11:46.780
Suppose you get three web requests, A, B, and C.

01:11:48.580-01:11:54.640
And it turns out that web requests A and C both talk about CS35L.

01:11:55.980-01:11:59.820
And web request B talks about a different course, Dance 100, say.

01:12:00.920-01:12:07.300
What the server may end up doing is it will handle A and then it will handle C

01:12:08.060-01:12:12.660
because it has all that information about CS35L in RAM, easily available.

01:12:13.640-01:12:18.020
So it will do the requests out of order in order to improve performance.

01:12:19.170-01:12:20.340
Very common technique.

01:12:21.190-01:12:27.760
And it sort of often falls out sort of naturally in an event-based web server.

01:12:28.720-01:12:33.220
Because once things are sort of cached in RAM, those events happen faster.

01:12:33.310-01:12:35.140
And so you handle the events as they come in.

01:12:35.140-01:12:39.560
You will tend to handle events out of order from the way they came in from the outside world.

01:12:41.540-01:12:46.040
If you're using a multi-threaded web server, you can also do stuff in parallel.

01:12:46.970-01:12:51.220
And even then, sometimes things will come back in a different order than they were originally done.

01:12:53.120-01:12:58.860
So this is going to be a common sort of performance trick that you use to make things go faster.

01:13:00.840-01:13:03.160
Second sort of issue is latency.

01:13:04.599-01:13:10.680
Throughput is the number of actions per second that your server can do or your client can do.

01:13:11.460-01:13:18.860
Latency is how long the client waits between the time it does a request and the time it does a response.

01:13:19.959-01:13:27.760
So here the idea is you want something to pop up on the screen, on the user's screen as quickly as possible.

01:13:28.500-01:13:37.160
This is a different performance measurement from throughput, but it's very important obviously to individual users.

01:13:38.300-01:13:52.340
A common trick to improve your latency is to cache on the client or sometimes on the server.

01:13:53.980-01:13:55.740
But for now, let's focus on the former.

01:13:57.600-01:13:59.200
And the idea here is pretty simple.

01:14:00.180-01:14:11.660
If the client wants to ask a question of the server, but it already asked that question or a similar question a few minutes ago, just reuse the answer that you already got.

01:14:13.820-01:14:17.000
Just keep a cache of answers to recent questions.

01:14:17.970-01:14:22.640
Keep that cache in RAM, say, on the client, or maybe on a flash drive on the client somewhere.

01:14:23.540-01:14:29.880
Consult the cache instead of waiting for the request to get all the way to the server.

01:14:30.090-01:14:31.500
It might be in Tokyo.

01:14:32.800-01:14:39.220
It's going to take, gosh, I don't know, 250 milliseconds to get the thing there and back.

01:14:39.350-01:14:40.940
Speed of light, whatever, right?

01:14:41.220-01:14:41.900
That's forever.

01:14:42.400-01:14:43.560
That's a quarter of a second.

01:14:43.910-01:14:44.980
Who wants to wait that long?

01:14:45.050-01:14:45.420
I don't.

01:14:45.510-01:14:46.480
You don't either, right?

01:14:46.650-01:14:52.140
So cache the answer on your browser and don't talk to that web server in Tokyo.

01:14:54.160-01:15:02.900
These are two very common performance sort of tricks and I hope that you are putting the

01:15:03.340-01:15:10.020
engineering hats on your head and saying what can go wrong with these performance tricks.

01:15:10.820-01:15:20.440
And that brings up a second class of common problems in dealing with these sorts of applications

01:15:20.460-01:15:22.540
and those are going to be correctness problems.

01:15:28.020-01:15:31.960
These are performance issues, and these are correctness issues.

01:15:33.260-01:15:36.120
These correctness issues are, in some sense,

01:15:36.640-01:15:39.740
corollaries of the common performance hacks

01:15:39.980-01:15:42.960
that everybody uses to get their client-server apps to go fast.

01:15:45.000-01:15:55.840
So, for example, if you do stuff sort of out of order, that might confuse the users, right?

01:15:57.320-01:16:02.280
This sort of out of order execution, the users might say, hey, wait a second.

01:16:03.000-01:16:09.880
You know, I sent in my request to enroll before that other guy down the hall sent in their request.

01:16:10.680-01:16:13.900
How come they got in, but I didn't?

01:16:14.700-01:16:23.980
right? Order often matters. Or I sent in a deposit of a thousand bucks into my checking account,

01:16:24.820-01:16:32.540
and then I did a withdrawal of 500. How come you did those actions out of order and charged me 30

01:16:32.800-01:16:42.520
bucks for a fee, right? For an overdraft fee, right? So order often matters, and how do we sort of

01:16:42.300-01:16:51.320
address that issue when we have sort of played this trick but maybe played it too far or too hard,

01:16:52.180-01:16:58.080
right? The standard technique for doing this, I won't talk about it that much in this class,

01:16:58.240-01:17:04.060
but you'll get a lot of this later in other courses in this department, is called serialization.

01:17:09.560-01:17:12.560
And the basic idea of serialization is as follows.

01:17:14.060-01:17:17.940
The server got a whole bunch of actions to do, right?

01:17:19.280-01:17:24.220
Action one, action two, action three, action four.

01:17:25.000-01:17:28.780
And it executed them in, say, this order.

01:17:29.700-01:17:33.160
And in some sense, by sort of overlapping this, I'm saying,

01:17:33.360-01:17:34.780
Well, it did some stuff in parallel.

01:17:37.520-01:17:41.960
But the way the server can explain what it did

01:17:42.980-01:17:45.640
to any user who cares about the result

01:17:45.740-01:17:47.380
is it can say, well, you know,

01:17:48.160-01:17:50.580
this has exactly the same effect

01:17:50.900-01:17:52.660
as if I did the actions in this order.

01:17:52.940-01:17:58.600
A1, A4, A2, or maybe even A3, A2.

01:17:58.680-01:17:59.380
It doesn't really matter.

01:18:01.860-01:18:04.700
Do this first, this second, this third, and this fourth.

01:18:05.120-01:18:11.580
If I had done the actions in this order, then my resulting state would look like this.

01:18:13.460-01:18:16.040
And let's call that state ST.

01:18:16.700-01:18:19.700
And that's exactly the same state that I actually computed here,

01:18:19.860-01:18:23.720
even though I did the actions out of order or in parallel or whatever.

01:18:24.700-01:18:28.920
As long as a server can justify its resulting state

01:18:29.720-01:18:34.740
and all the behaviors that people observe as if it did things in a serial order, then that's good enough.

01:18:39.540-01:18:42.000
Any questions about the idea of serialization?

01:18:42.020-01:18:50.440
In some sense, serialization is a little strange concept because it's a way of justifying your behavior.

01:18:50.940-01:18:56.680
It's almost like you broke the rules, but you later explained to the judge,

01:18:56.960-01:18:58.600
Here's what could have happened.

01:18:59.960-01:19:02.540
And if the judge can't observe anything wrong,

01:19:02.800-01:19:05.320
the judge will say, okay, you're off the hook, right?

01:19:05.480-01:19:09.240
It's cheating in some sense, but not really in another,

01:19:09.400-01:19:12.180
as long as the serial order said,

01:19:12.360-01:19:15.540
well, you withdrew some money and then you deposited it.

01:19:15.540-01:19:17.320
And so we gave you a lateness penalty,

01:19:17.500-01:19:18.280
then that's good enough.

01:19:21.420-01:19:24.739
All right, so that's the correctness issue

01:19:24.760-01:19:26.980
or the common way of addressing the correctness issue.

01:19:27.000-01:19:27.620
There are other ways.

01:19:28.960-01:19:30.580
What about this problem with latency?

01:19:34.760-01:19:37.700
With latency, the common way you address that

01:19:37.840-01:19:38.520
is with caching.

01:19:40.700-01:19:42.140
And the problem with caching,

01:19:42.240-01:19:43.540
as I'm sure you can imagine,

01:19:44.220-01:19:46.600
is those caches will often be wrong.

01:19:49.320-01:19:51.640
So how do we address that?

01:19:56.239-01:20:02.980
One option is to make sure that whenever you consult a cache on the client,

01:20:03.660-01:20:05.720
that you make sure it's actually correct.

01:20:13.100-01:20:14.640
And by correct, I mean up to date.

01:20:18.620-01:20:19.360
That's one option.

01:20:20.640-01:20:22.640
So the idea here is something like the following.

01:20:24.220-01:20:28.340
Every state on the server, say, has a unique ID,

01:20:29.260-01:20:32.080
some big long string that uniquely identifies the state.

01:20:32.860-01:20:36.940
We store that unique ID on the client along with a cache.

01:20:37.560-01:20:40.480
Every time we consult the cache, we ask the server,

01:20:40.740-01:20:44.420
hey, is the unique ID of the state changed?

01:20:45.160-01:20:47.580
If so, we say, oh, our cache is wrong,

01:20:47.870-01:20:49.900
now we've got to go update it and all that sort of thing.

01:20:50.540-01:20:54.020
But oftentimes the answer will say, oh, nothing's changed since last time.

01:20:54.900-01:21:01.960
If we take that approach, we will save a lot of work because we can cache a whole bunch of stuff on the client.

01:21:02.880-01:21:07.280
Oftentimes it's up to date, so we just need a quick little message to the server to say, are we up to date yet?

01:21:07.380-01:21:08.620
The server says, yes, okay, fine.

01:21:08.760-01:21:13.020
We can now use this big cache instead of copying a whole bunch of data from the server.

01:21:14.380-01:21:15.540
So that's one option.

01:21:16.340-01:21:17.980
You make sure your cache is up to date.

01:21:18.760-01:21:23.700
And whenever you have to worry about that, you go check that it still is up to date and do that as quickly as you can.

01:21:25.340-01:21:25.480
Right?

01:21:27.320-01:21:31.400
Another issue, well, to some extent, you can say sort of this is cache validation.

01:21:37.020-01:21:40.340
How do you make sure that the cache is always going to be up to date?

01:21:42.660-01:21:47.920
Another possibility is to change your computation.

01:21:48.220-01:21:58.400
change the program that's running on the client so that it still works well enough even if the cache is a little bit out of date.

01:21:59.730-01:22:01.020
So that's another approach.

01:22:03.400-01:22:09.400
Work even with stale caches.

01:22:14.300-01:22:16.920
Some applications can indeed do that.

01:22:17.780-01:22:20.880
A classic example is a video game application.

01:22:21.750-01:22:25.360
You're playing some video game, there's another player in the game,

01:22:25.850-01:22:29.920
you have a cache of what the game's shared state looks like.

01:22:30.270-01:22:35.320
Your cache is going to be a little bit obsolete by, you know, three milliseconds.

01:22:35.980-01:22:40.460
But you're not a super duper player, you can deal with a cache that's out of date.

01:22:40.920-01:22:44.080
How many people here have a reaction time better than three milliseconds, right?

01:22:44.700-01:22:45.520
Nobody, right?

01:22:46.100-01:22:48.040
So it's okay.

01:22:48.160-01:22:49.700
Oh, somebody raises their hand.

01:22:50.220-01:22:51.380
There's always somebody, right?

01:22:52.180-01:22:57.520
So in some applications, it's okay to have caches that are somewhat stale.

01:22:58.520-01:23:01.380
Another example is a weather application.

01:23:02.260-01:23:05.920
It's telling you what the weather will be like for the rest of the afternoon.

01:23:06.360-01:23:08.700
So it's 10 minutes out of date.

01:23:09.740-01:23:13.840
Unless you're in western Kansas or something, 10 minutes out of date is fine, right?

01:23:15.940-01:23:18.940
So this is going to be a correctness issue.

01:23:19.350-01:23:23.280
You have to decide for your application whether your caches can be stale or not.

01:23:23.440-01:23:24.580
That's a big deal, right?

01:23:25.400-01:23:29.740
If they can't be stale, you have to decide how your cache validation is going to work

01:23:30.280-01:23:34.720
because this cache validation implies, of course, latency.

01:23:36.530-01:23:40.020
And latency is kind of the reason you avoided the cache in the first place.

01:23:44.640-01:23:50.140
All right, so any comments on these two major issues?

01:23:52.760-01:23:52.900
Yes.

01:23:54.060-01:23:54.620
Yeah,

01:23:54.760-01:23:56.760
does the cash validation like also

01:23:56.840-01:23:58.660
the benefits of having cash?

01:23:59.320-01:24:00.940
Yes, it does, right?

01:24:01.980-01:24:05.680
The goal of this approach is you want this to be a lot faster

01:24:06.460-01:24:08.780
than actually just refetching the whole cache, right?

01:24:09.120-01:24:11.180
So if your cache has a gigabyte's worth of data

01:24:11.200-01:24:15.420
and cache validation just has to ship 120 bytes or something,

01:24:15.820-01:24:16.860
then it can still be a win.

01:24:18.200-01:24:18.980
Right, exactly.

01:24:20.480-01:24:23.820
You still have the speed of light delay between you and the server.

01:24:24.620-01:24:26.120
That's a downside of this approach.

01:24:27.420-01:24:29.780
Other comments on these two major problems?

01:24:30.360-01:24:30.520
Yes?

01:24:31.020-01:24:31.800
Can you explain how

01:24:31.800-01:24:32.540
to be realising?

01:24:36.159-01:24:38.440
Well, it's sort of cheating.

01:24:39.940-01:24:48.420
It doesn't really prevent the out of order issue in the sense that requests can be handled out of order with the serialization approach.

01:24:49.300-01:25:11.780
But what it does do is it says, if we pretended that, say, student X's request got routed to outer Mongolia before they actually got to Murphy Hall, and student Y's
request got sent straight to Murphy Hall, then the fact that Y got enrolled and X didn't is okay, right?

01:25:11.940-01:25:13.700
It's sort of our excuse, right?

01:25:14.400-01:25:18.080
What we want to still, I mean, the point of serialization, though,

01:25:18.240-01:25:22.660
is that the resulting computation still has to be valid, right?

01:25:23.200-01:25:26.740
You can't look at the resulting state, for example,

01:25:27.140-01:25:30.520
and find more than 160 students enrolled in this class

01:25:30.740-01:25:33.400
because the limit on this class enrollment is 160, right?

01:25:33.880-01:25:35.780
So you still follow the rules of the application.

01:25:36.480-01:25:40.860
It's just that you might not have followed it in the order that people expected.

01:25:41.240-01:25:41.340
Yes?

01:25:47.560-01:25:48.120
Yes.

01:25:48.120-01:25:48.140
Yes.

01:25:48.420-01:25:48.880
What happens

01:25:48.880-01:25:52.360
if you do the order and then it doesn't work?

01:25:53.940-01:25:54.860
Oh, well, yeah.

01:25:54.920-01:25:58.240
I mean, serialization is not a solution to all the bugs in your application.

01:25:58.600-01:26:01.220
If your application is buggy, it'll still be buggy.

01:26:03.160-01:26:08.380
In some sense, serialization is the way that you prove your application is not buggy.

01:26:08.540-01:26:10.740
You come up with an explanation for what it did,

01:26:11.500-01:26:15.840
and if that explanation matches the behavior that was observed, you're okay.

01:26:16.600-01:26:20.440
If you can't come up with the explanation, then your application was buggy.

01:26:21.050-01:26:24.000
But it's not just saying the magic word serialization

01:26:24.130-01:26:26.200
sort of insulates you from all possible problems.

01:26:26.420-01:26:27.420
That's not how it works at all.

01:26:28.960-01:26:29.500
Okay, question?

01:26:29.860-01:26:30.620
I thought like

01:26:30.620-01:26:32.180
the purpose of just what the user,

01:26:32.440-01:26:34.740
like how can you justify the bank account example?

01:26:35.660-01:26:36.620
Justify which example?

01:26:36.820-01:26:37.940
Like the bank account example.

01:26:38.960-01:26:49.100
Oh, well, you will say that, you know, here's ATM X where you deposited money, and here's ATM Y where you withdrew money.

01:26:49.430-01:26:55.680
You just say, well, ATM Y, you know, had a faster network, even when it didn't really.

01:26:56.880-01:27:01.000
But the user can't tell, so you're off the hook, right?

01:27:01.440-01:27:07.840
So if you have just a single client, say a single ATM, and you deposit and then withdraw,

01:27:08.600-01:27:11.480
then you're not allowed to serialize that out of order, right?

01:27:11.900-01:27:14.580
Serialization has to be from the point of view of the entire application,

01:27:14.960-01:27:21.260
but from an individual client, it can still expect its actions to be done in a particular order

01:27:21.460-01:27:24.860
if it issued them in the order and got the response back, that sort of thing.

01:27:25.720-01:27:32.900
But we'll see later, though, that there are cases where the client can do request one and then request two,

01:27:34.000-01:27:35.420
but request two gets done first.

01:27:35.740-01:27:37.540
That's allowed, and we'll see that later.

01:27:37.600-01:27:40.720
But you wouldn't do that sort of thing in an ATM sort of application.

01:27:41.300-01:27:43.180
The bank users would get very mad at you.

01:27:44.580-01:27:45.400
Okay, other comments?

01:27:47.980-01:27:48.640
Yes, in the back.

01:27:48.960-01:27:49.920
I have a question

01:27:49.920-01:27:50.940
about the different models.

01:27:51.340-01:27:51.560
Uh-huh.

01:27:52.340-01:27:52.660
In terms

01:27:52.660-01:27:56.580
of, you were mentioning that you think the client server model is up to scale.

01:27:57.030-01:27:59.560
Is there a difference where you actually just want to change your model?

01:28:01.840-01:28:05.920
So the idea is you maybe started off with client server,

01:28:06.580-01:28:08.900
and then all of a sudden you got deluged with a million users,

01:28:09.030-01:28:10.540
and now you've got to switch, that sort of thing?

01:28:11.040-01:28:15.360
Yeah, that is a situation that can happen,

01:28:16.280-01:28:22.000
and you kind of should have a plan, right?

01:28:24.240-01:28:28.520
And there are ways to attack this problem that's sort of beyond the scope of this lecture.

01:28:29.240-01:28:30.160
But let's put it this way.

01:28:30.570-01:28:32.820
I like to call that a problem of success.

01:28:33.980-01:28:38.900
A problem of success is when you all of a sudden discover that you're really popular.

01:28:39.170-01:28:40.860
And there's a lot of people that want to use your stuff.

01:28:40.970-01:28:42.300
And you're making lots of money.

01:28:42.660-01:28:44.640
Take that money and invest it in a better system.

01:28:45.380-01:28:47.400
You want to have problems of success.

01:28:48.490-01:28:49.900
So that's one way of looking at it.

01:28:50.980-01:28:56.960
All right, so let's go back in time next.

01:28:58.200-01:29:00.680
I'm doing this lecture in sort of reverse order, right?

01:29:02.260-01:29:04.900
We did Node, now we do this sort of the general thing.

01:29:05.340-01:29:06.640
I want to go back in time.

01:29:07.010-01:29:07.520
Oh, question.

01:29:08.900-01:29:10.720
Are caches like cookies?

01:29:11.540-01:29:12.560
Are caches like what?

01:29:14.760-01:29:17.640
Oh, yeah, well, you can cache cookies, definitely.

01:29:17.940-01:29:22.060
And in fact, most people, most applications will cache cookies, absolutely.

01:29:22.740-01:29:24.360
But you don't have to.

01:29:25.300-01:29:26.900
In some sense, they're orthogonal.

01:29:27.240-01:29:29.620
It's just that they're closely associated, absolutely.

01:29:30.120-01:29:36.560
I normally, by the way, throw away all my cookies at the end of every web session.

01:29:37.240-01:29:40.500
Because I'm security oriented, I don't like to have those cookies floating around.

01:29:40.640-01:29:42.620
So I clear the cache all the time with my cookies.

01:29:42.740-01:29:44.700
But not everybody is as paranoid as I am.

01:29:45.520-01:29:46.640
All right, other comments?

01:29:48.000-01:29:51.040
All right, well, let's go back before the internet.

01:29:57.620-01:30:01.380
So what we're doing now is we're going way down the stack.

01:30:02.280-01:30:06.620
We started off at the node level and then went down to the JavaScript level

01:30:06.880-01:30:09.560
and then went down to the client server level and all that sort of thing.

01:30:10.040-01:30:12.800
Now I'm going to go down practically to the hardware level

01:30:13.420-01:30:16.240
to see how this stuff works really at the lowest level.

01:30:17.280-01:30:22.320
because the way the problems sort of bite you at the lowest level

01:30:23.280-01:30:25.840
will turn around and sometimes bite you at these higher levels.

01:30:26.080-01:30:27.100
That's why we're doing this.

01:30:28.240-01:30:32.760
So before the Internet, the way that we hooked together computers

01:30:33.040-01:30:37.400
and other automated devices was with a technology called circuit switching.

01:30:42.580-01:30:44.840
It's a technology that's still used in some places,

01:30:45.200-01:30:47.440
although other techniques have taken over.

01:30:48.480-01:30:50.160
And here's how it works.

01:30:50.960-01:30:56.100
Here we are in, I don't know, Engineering 6, 363, my office.

01:30:56.680-01:30:57.460
Here's a phone.

01:30:57.900-01:31:01.240
And back then, you know, they were dial phones and all that sort of thing.

01:31:02.380-01:31:05.220
Very traditional phone, just like the icons you see at a phone.

01:31:05.360-01:31:06.700
Nobody has phones like this anymore.

01:31:07.600-01:31:11.040
They were connected by a pair of wires,

01:31:11.290-01:31:13.760
just a pair of copper wires twisted around each other.

01:31:13.830-01:31:14.780
So it's a twisted pair.

01:31:15.580-01:31:16.920
to something called a central office.

01:31:18.780-01:31:21.240
This central office would, you know,

01:31:21.270-01:31:23.100
have a whole bunch of phones connected to it.

01:31:24.000-01:31:28.160
But what I wanted to do is I wanted to call somebody at MIT,

01:31:28.430-01:31:29.380
way over here in Boston,

01:31:31.980-01:31:33.580
who had a similar setup, right?

01:31:33.860-01:31:36.000
Here's a dial phone, right,

01:31:36.500-01:31:39.760
connected by a twisted pair of wires to a central office over here.

01:31:40.340-01:31:42.560
The limit on this length is fairly small,

01:31:43.800-01:31:45.760
you know, maybe a half mile, something like that.

01:31:45.920-01:31:49.400
Can't be much longer than that, but it's just wires that go to the central office.

01:31:50.140-01:31:56.900
And the reason you can't make it any longer than that is because the signals sort of decay with distance,

01:31:57.680-01:31:58.720
and they won't get there.

01:31:59.150-01:32:01.180
And also, you know, the power and all that sort of thing.

01:32:03.000-01:32:10.200
Now, if I want to call my colleague in Boston, I pick up the phone, I dial the number.

01:32:10.820-01:32:13.620
The number that I'm dialing gets sent to the central office.

01:32:14.200-01:32:19.020
There's a computer in here that figures out, oh, we want to talk to Boston.

01:32:19.920-01:32:26.620
But there's no wire that goes all the way from the central office at UCLA to the central office at MIT.

01:32:27.420-01:32:28.980
That's just asking too much.

01:32:29.740-01:32:33.380
Electrical wires just, you know, the signals won't go that far.

01:32:34.140-01:32:41.120
So instead, what the telephone system had was it had a bunch of locations scattered across the country.

01:32:43.340-01:32:49.420
So I don't know, here's Chicago, here's Houston, over here is New York.

01:32:51.280-01:32:54.000
It was actually, obviously, much more complicated than this.

01:32:55.060-01:32:58.020
Over here is Tucson, over here is Phoenix, and all that sort of thing.

01:32:58.920-01:33:22.440
And what this computer in the central office would do is it would basically query the entire network of all of these systems that were connected to each other by copper
wires and say, you know, I'd like to, you know, here's somebody who wants to talk over here to this, you know, central office in Boston.

01:33:22.730-01:33:24.200
Oh, I guess it's over here, right?

01:33:26.880-01:33:38.600
And what this set of computers would do, because there's a computer inside each box, is arrange to find what they call the circuit that connects this phone to this phone.

01:33:39.040-01:33:47.360
So it's a twisted pair of wires here that connects to a twisted pair of wires in Phoenix, which compares to a twisted pair of wires in Albuquerque,

01:33:47.840-01:33:55.540
which connects over here to Kansas City, which goes up to Chicago, which goes to Cleveland, which goes to Boston, and finally we're talking.

01:33:55.700-01:34:03.340
So there's a single path of basically electrical wires.

01:34:04.360-01:34:07.160
It's not really one long pair of wires.

01:34:07.770-01:34:13.400
It's a bunch of shorter twisted pairs of wires connected via switches in the central office.

01:34:14.260-01:34:20.880
While I'm talking to Boston, I have this entire circuit reserved.

01:34:22.140-01:34:27.100
Nobody else can use it because if they could use it, then we'd hear cross talk and all that sort of thing.

01:34:29.840-01:34:38.520
And as a result, when I talk, the guy in Boston immediately hears what I talk, speed of light practically, almost as fast as the speed of light.

01:34:38.690-01:34:41.140
Okay, it has to go around some corners, but it's really fast.

01:34:42.120-01:34:44.140
And when they talk to me, I hear them.

01:34:44.150-01:34:50.600
In fact, we can talk simultaneously and we'll each hear the other person's conversation because, you know,

01:34:50.700-01:34:52.320
we have two wires rather than just one.

01:34:54.060-01:34:54.300
Okay.

01:34:55.500-01:34:57.680
What's wrong with this system?

01:34:58.760-01:35:00.380
Why does nobody use it anymore?

01:35:03.460-01:35:05.440
It's very simple, very straightforward.

01:35:06.520-01:35:08.760
The U.S. telephone system ran this way for decades,

01:35:10.480-01:35:12.180
but we don't like it anymore.

01:35:14.020-01:35:14.740
Why not? Yes?

01:35:15.160-01:35:16.040
It's extremely

01:35:16.040-01:35:16.760
unscathed.

01:35:17.120-01:35:19.099
Because, like, if you want multiple people...

01:35:19.200-01:35:21.720
We had millions of phones that had all worked, right?

01:35:22.520-01:35:25.380
You know, the scaling occurs as follows.

01:35:25.960-01:35:28.780
Each central office only had, you know, a few hundred connections.

01:35:29.340-01:35:32.500
All of these other guys had lots more connections that I'm talking about here.

01:35:32.980-01:35:35.940
There's, you know, they had a whole bunch of these things scattered.

01:35:36.360-01:35:40.440
And as the number of people grew and the number of conversations grew, they just added boxes.

01:35:42.240-01:35:45.820
You're right about scalability, but it's not the number of people.

01:35:46.040-01:35:47.400
There's something else going on.

01:35:47.510-01:35:47.620
Yes?

01:35:47.900-01:35:48.160
The

01:35:48.160-01:35:50.400
number of changes for data corruption?

01:35:51.980-01:35:53.640
Well, okay, yeah.

01:35:53.750-01:35:58.200
If one of these wires, say, goes bad, this wire goes down,

01:35:58.880-01:36:02.640
then my conversation with my colleague at MIT goes,

01:36:03.260-01:36:05.320
and the phone connection drops,

01:36:05.370-01:36:07.160
and then I have to pick up the phone and call again.

01:36:07.650-01:36:08.460
So that's a problem.

01:36:08.940-01:36:13.300
But AT&T and its competitors spend a lot of money

01:36:14.300-01:36:15.580
making this system more reliable.

01:36:15.740-01:36:20.640
In fact, it was more reliable than today's telephone system.

01:36:21.460-01:36:26.440
I get a lot more drops in conversations now than I did back in 1960.

01:36:27.240-01:36:29.220
Well, all right, 1970, right?

01:36:29.880-01:36:35.600
I mean, it's just like, you know, really, it really worked well in terms of a reliability point of view.

01:36:35.820-01:36:35.940
Yes?

01:36:36.380-01:36:37.300
You mean scalability

01:36:37.300-01:36:38.080
in terms of distance?

01:36:39.900-01:36:40.960
Distance is fine.

01:36:41.320-01:36:45.140
You know, yes, each wire here can only be a certain distance.

01:36:45.840-01:36:47.680
but you just build more boxes, right?

01:36:48.420-01:36:51.340
We'll put one here in, I don't know, Columbus or something, right?

01:36:52.040-01:36:55.400
So as long as you are rich, like the tele...

01:36:55.770-01:37:00.060
You know, AT&T was the biggest company in the U.S. for a while.

01:37:00.640-01:37:02.400
You just pay for it, and it works. Yes?

01:37:02.920-01:37:03.780
Each location

01:37:03.780-01:37:05.880
has a chance to, like, listen in on the conversation?

01:37:06.360-01:37:09.420
Oh, yes. So you have to trust the phone company.

01:37:10.320-01:37:12.080
Under this system, there's no encryption.

01:37:13.120-01:37:18.520
The only security is the fact that if the telephone company gives away your conversation, you throw them in jail.

01:37:18.880-01:37:20.400
That's the only security there was.

01:37:20.550-01:37:22.200
So that is an issue.

01:37:22.690-01:37:26.460
But to some extent, you know, how shall I say it?

01:37:27.040-01:37:33.480
I've spent this whole lecture ignoring one of the biggest problems we have in software construction, which is security.

01:37:33.530-01:37:34.240
Did you notice that?

01:37:34.460-01:37:36.600
Over here, I talked about throughput and latency.

01:37:37.210-01:37:38.360
I didn't mention security.

01:37:39.000-01:37:40.560
Security is like one of the big gorillas.

01:37:40.800-01:37:41.520
I've been skipping it.

01:37:41.800-01:37:43.400
I want to continue to skip that here.

01:37:44.820-01:37:45.020
All

01:37:45.020-01:37:45.160
right?

01:37:45.300-01:37:45.500
Yes?

01:37:51.280-01:37:51.840
Right.

01:37:52.860-01:37:57.960
So what's going on here is its efficiency problem, right?

01:37:58.180-01:38:03.300
One of the problems here is I have to reserve a complete pair of lines,

01:38:03.560-01:38:05.300
one way or another, between here and Boston.

01:38:06.320-01:38:10.879
And let's face it, even the most animated conversation I have

01:38:11.300-01:38:15.200
with a professor at MIT is mostly blank space.

01:38:16.720-01:38:19.480
We're thinking, or one person's talking,

01:38:19.630-01:38:20.720
the other person is not.

01:38:20.720-01:38:23.120
That means one of those two wires is basically useless.

01:38:23.960-01:38:26.040
So this is inefficient.

01:38:27.200-01:38:29.200
We could, if we were clever,

01:38:31.160-01:38:34.800
use the same amount of copper to build a system,

01:38:35.410-01:38:38.160
and that system could carry more conversations.

01:38:40.320-01:38:41.360
So that's one problem.

01:38:42.200-01:38:42.320
Yes?

01:38:43.160-01:38:43.640
Portability?

01:38:44.400-01:38:44.880
Portability.

01:38:45.040-01:38:47.600
Oh, yeah, nothing was mobile about this, right?

01:38:47.800-01:38:51.480
This is, you know, don't get me started.

01:38:51.680-01:38:54.540
I mean, there were portable phones even back in the 1950s,

01:38:54.680-01:38:55.780
but it's terrible technology.

01:38:56.420-01:38:57.620
But let's not worry about that.

01:38:58.140-01:38:58.300
Yes?

01:38:58.920-01:38:59.560
The number

01:38:59.560-01:39:01.440
of the box of increasements,

01:39:01.900-01:39:05.580
the algorithm to find the path between two different phones?

01:39:05.960-01:39:08.380
The algorithms get hairier and hairier, yes.

01:39:08.500-01:39:11.220
And the phone companies spent a lot of money figuring good algorithms.

01:39:11.740-01:39:20.640
And, you know, they had algorithms that used sort of statistical approximations of the expected phone calls in the next minute using Erlang distributions, that sort
of thing.

01:39:20.860-01:39:22.060
They were really good at that.

01:39:23.220-01:39:27.840
There was one other thing, though, that motivated people from switching away from this.

01:39:29.060-01:39:33.740
And it's a very sad motivation, but it has to be said.

01:39:35.180-01:39:38.120
And the sad motivation is the possibility of nuclear war.

01:39:40.160-01:40:04.140
If you take, say, Chicago and blow it up, then the airbase commander in Boston, who's trying to talk to the airbase commander at LAX, their conversation will be
interrupted and you won't be able to fight the war as effectively as you could if we had a better system.

01:40:07.660-01:40:16.020
And for this reason, the Department of Defense in the 1960s and 1970s said,

01:40:16.420-01:40:22.760
"We need to invest in a better networking system, one that can survive wholesale destruction

01:40:22.870-01:40:26.780
of nodes and still let our commanders talk to each other."

01:40:27.980-01:40:28.660
Okay.

01:40:30.180-01:40:38.920
The seminal work in that area was done by someone called Paul Baran,

01:40:40.270-01:40:44.120
who did that at the Rand Corporation,

01:40:49.770-01:40:55.140
which is short for Research and Development in Santa Monica.

01:41:00.560-01:41:03.700
and what he designed in the 1960s

01:41:04.140-01:41:05.580
and kept after people saying,

01:41:05.670-01:41:08.120
we really need to solve this problem

01:41:08.400-01:41:11.000
because there could be a nuclear war any day.

01:41:12.460-01:41:14.520
We need to sort of come up with a better approach.

01:41:15.580-01:41:16.560
And his approach,

01:41:17.130-01:41:18.820
because Rand Corporation was full of people

01:41:18.890-01:41:20.220
that were thinking about what to do

01:41:20.250-01:41:21.380
in case of a nuclear war,

01:41:22.060-01:41:23.840
his approach is called packet switching.

01:41:30.980-01:41:35.440
It takes quite a different attitude towards how to do communications.

01:41:36.050-01:41:39.740
You still, at least at the start, assume the same kind of physical network.

01:41:40.620-01:41:41.960
So we assume copper wires.

01:41:42.520-01:41:46.680
We assume a whole network of boxes connected to each other via copper wires.

01:41:47.330-01:41:50.260
But we don't do the conversations this way.

01:41:51.000-01:41:58.820
We do the conversations in such a way that even if Chicago vanishes, our conversations still keep going.

01:42:00.770-01:42:03.540
And the basic idea of packet switching is as follows.

01:42:04.330-01:42:18.500
You divide your communication contents into small packets.

01:42:24.580-01:42:27.400
Each packet contains only a few bits.

01:42:28.040-01:42:32.760
How many depends on the, you know, technology and all that sort of thing.

01:42:33.070-01:42:36.280
But a typical value here is a thousand bytes, right?

01:42:36.670-01:42:37.520
Eight thousand bits.

01:42:38.240-01:42:40.440
The exact number depends on the technology.

01:42:41.320-01:42:46.260
You don't want to make the packets too small because if you do, they can't carry enough

01:42:46.560-01:42:47.500
information to do anything.

01:42:48.660-01:42:54.220
But also, you don't want them to be too big because if they're too big, they're going

01:42:54.380-01:42:58.900
to sort of break other parts of the system and we'll see what they would break if we

01:42:58.960-01:42:59.720
made them too big.

01:43:00.420-01:43:06.900
In some sense, circuit switching is packet switching in which the packets have infinite

01:43:07.180-01:43:10.300
length or length equal to the length of your conversation.

01:43:11.380-01:43:12.800
Well, that's not exactly true either.

01:43:13.040-01:43:14.720
Anyhow, all right, so this is the basic idea.

01:43:14.960-01:43:23.860
So now, if we are here in Santa-- at UCLA, right, Engineering 6363, and we use our now

01:43:24.160-01:43:25.240
fancy new phone.

01:43:26.000-01:43:27.260
I have one on my desk.

01:43:28.200-01:43:29.340
It uses packet switching.

01:43:30.020-01:43:33.420
It still has a, you know, it has a touch and all that sort of thing, right?

01:43:34.500-01:43:39.260
The conversation is split up into roughly one kibibyte pieces.

01:43:42.040-01:43:44.680
And we send off each of these packets into the network.

01:43:46.060-01:43:51.460
It hooks up to something that acts like a central office except we don't call them central offices.

01:43:51.670-01:43:52.520
We call them routers.

01:43:55.620-01:44:04.420
And the router makes, in theory, an independent decision for each packet as to how to get

01:44:04.560-01:44:06.040
that packet to where it wants to go.

01:44:07.160-01:44:12.000
So each packet individually says, "Where do I want to go?"

01:44:12.020-01:44:16.980
to go to Boston. Oh, I want to go to Boston too. Oh, I want to go to Boston 3. Oftentimes

01:44:17.280-01:44:22.180
you'll see a string of packets that all go to the same spot, but you don't know that

01:44:22.260-01:44:26.960
in advance if you're a router. You just keep getting packets over the place, and whenever

01:44:27.040-01:44:33.140
you get a packet, you look at where it wants to go, and you say, "Probably Phoenix. I think

01:44:33.200-01:44:39.900
Phoenix is going to make progress." Right? But it's possible that this router will start

01:44:39.900-01:44:46.540
sending stuff to Phoenix but then maybe Phoenix is flaky or maybe if it's

01:44:46.720-01:44:49.980
overloaded or maybe it hasn't heard anything from Phoenix because and it

01:44:50.020-01:44:55.580
worries with it Phoenix is now you know a pile of rubble so it'll send packets

01:44:55.880-01:45:03.420
off to Denver and so forth and so on you still have a complicated network all

01:45:03.530-01:45:07.099
over the country eventually you get to Boston where there's a phone on the

01:45:06.980-01:45:16.620
other end, but each of these routers independently just gets little pieces of data. It's almost

01:45:16.800-01:45:20.500
like they get like a little post-it note and the post-it says I want to go to Boston.

01:45:20.540-01:45:28.820
They say maybe if I give it to Georgia, Georgia will figure out what to do with it. And if

01:45:28.980-01:45:34.960
this packet switching approach works well enough, we've addressed this problem.

01:45:36.660-01:45:43.720
Granted, maybe some of my conversation will have been lost because the packets happened

01:45:43.790-01:45:46.380
to be in Chicago when Chicago went down.

01:45:47.540-01:45:50.040
But the rest of my conversation will keep going.

01:45:50.280-01:45:54.440
Kansas City will notice that Chicago no longer is this and so I'll rewrite it, reroute to

01:45:54.520-01:45:56.120
Memphis and so that sort of thing.

01:45:56.840-01:46:02.080
So anything that goes down is considered to be a problem to be routed around.

01:46:02.610-01:46:02.740
Yes?

01:46:06.870-01:46:12.760
Well, one possibility is that these routers not only can send data,

01:46:13.540-01:46:15.960
but there's actually a control link with a little heartbeat,

01:46:16.610-01:46:18.760
and it listens to the heartbeat of the other side.

01:46:19.030-01:46:21.280
And if there's no heartbeat, it says, must be dead.

01:46:23.200-01:46:24.560
There are other approaches, but that's one.

01:46:24.610-01:46:24.760
Yes?

01:46:24.980-01:46:25.880
- How do you get the packets

01:46:26.140-01:46:26.760
right in the right order?

01:46:27.300-01:46:28.100
- Oh, they don't.

01:46:28.480-01:46:29.640
They won't get there in the right order.

01:46:29.860-01:46:30.180
Boston

01:46:30.180-01:46:32.300
can get these packets completely in the wrong order.

01:46:33.320-01:46:34.880
And next time, we'll have to figure out

01:46:34.890-01:46:35.680
what to do about that.

